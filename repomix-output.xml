This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  schemas/
    com.mydeck.app.io.db.MyDeckDatabase/
      1.json
      2.json
      3.json
      4.json
      5.json
  src/
    androidTest/
      java/
        com/
          mydeck/
            app/
              ExampleInstrumentedTest.kt
    main/
      assets/
        html_template_dark.html
        html_template_light.html
        html_template_sepia.html
      java/
        com/
          mydeck/
            app/
              coroutine/
                ApplicationScope.kt
                IoDispatcher.kt
              di/
                ViewModelModule.kt
              domain/
                mapper/
                  BookmarkMapper.kt
                model/
                  AuthenticationDetails.kt
                  AutoSyncTimeframe.kt
                  Bookmark.kt
                  BookmarkCounts.kt
                  BookmarkListItem.kt
                  LayoutMode.kt
                  SharedText.kt
                  SortOption.kt
                  Template.kt
                  Theme.kt
                  User.kt
                sync/
                  ConnectivityMonitor.kt
                  ConnectivityMonitorImpl.kt
                  ContentSyncPolicy.kt
                  ContentSyncPolicyEvaluator.kt
                usecase/
                  AuthenticateUseCase.kt
                  FullSyncUseCase.kt
                  LoadArticleUseCase.kt
                  LoadBookmarksUseCase.kt
                  UpdateBookmarkUseCase.kt
                BookmarkRepository.kt
                BookmarkRepositoryImpl.kt
                UserRepository.kt
                UserRepositoryImpl.kt
              io/
                db/
                  dao/
                    BookmarkDao.kt
                  model/
                    ArticleContentEntity.kt
                    BookmarkCountsEntity.kt
                    BookmarkEntity.kt
                    BookmarkListItemEntity.kt
                    BookmarkWithArticleContent.kt
                    RemoteBookmarkIdEntity.kt
                    ResourceEntity.kt
                  Converters.kt
                  DatabaseModule.kt
                  MyDeckDatabase.kt
                prefs/
                  EncryptionHelper.kt
                  SettingsDataStore.kt
                  SettingsDataStoreImpl.kt
                rest/
                  auth/
                    AuthInterceptor.kt
                    NotificationHelper.kt
                    NotificationUtil.kt
                    TokenManager.kt
                  model/
                    ArticleResourceDTO.kt
                    AuthenticationRequestDto.kt
                    AuthenticationResponseDto.kt
                    BookmarkDto.kt
                    CreateBookmarkDto.kt
                    EditBookmarkDto.kt
                    EditBookmarkErrorDto.kt
                    EditBookmarkResponseDto.kt
                    IconResourceDTO.kt
                    ImageResourceDTO.kt
                    LogResourceDTO.kt
                    PropsResourceDTO.kt
                    ResourcesDTO.kt
                    StatusMessageDto.kt
                    SyncContentRequestDto.kt
                    SyncStatusDto.kt
                    ThumbnailResourceDTO.kt
                    UserProfileDto.kt
                  NetworkModule.kt
                  ReadeckApi.kt
                  ReadeckApiService.kt
                  UrlInterceptor.kt
                AssetLoader.kt
              ui/
                about/
                  AboutScreen.kt
                  AboutViewModel.kt
                components/
                  ImageComponents.kt
                  ShareBookmarkChooser.kt
                  VerticalScrollbar.kt
                detail/
                  BookmarkDetailScreen.kt
                  BookmarkDetailsDialog.kt
                  BookmarkDetailViewModel.kt
                list/
                  BookmarkCard.kt
                  BookmarkListScreen.kt
                  BookmarkListViewModel.kt
                navigation/
                  Routes.kt
                settings/
                  AccountSettingsScreen.kt
                  AccountSettingsViewModel.kt
                  AutoSyncTimeframeDialog.kt
                  LogViewScreen.kt
                  LogViewViewModel.kt
                  NotificationRationaleDialog.kt
                  OpenSourceLibrariesScreen.kt
                  OpenSourceLibrariesViewModel.kt
                  SettingsScreen.kt
                  SettingsViewModel.kt
                  SyncSettingsScreen.kt
                  SyncSettingsViewModel.kt
                  ThemeDialog.kt
                  UiSettingsScreen.kt
                  UiSettingsViewModel.kt
                theme/
                  sepia/
                    Color.kt
                    Theme.kt
                  Color.kt
                  Theme.kt
                  Type.kt
              util/
                LoggerUtil.kt
                SearchOperators.kt
                Utils.kt
              worker/
                BatchArticleLoadWorker.kt
                CustomWorkManagerInitializer.kt
                DateRangeContentSyncWorker.kt
                FullSyncWorker.kt
                LoadArticleWorker.kt
                LoadBookmarksWorker.kt
              AppModule.kt
              MainActivity.kt
              MainViewModel.kt
              MyDeckApplication.kt
      res/
        drawable/
          ic_dashboard_black_24dp.xml
          ic_home_black_24dp.xml
          ic_label_24px.xml
          ic_launcher_background.xml
          ic_launcher_foreground.xml
          ic_notifications_black_24dp.xml
        drawable-anydpi/
          ic_notification_logo.xml
        drawable-hdpi/
          ic_notification_logo.png
        drawable-mdpi/
          ic_notification_logo.png
        drawable-xhdpi/
          ic_notification_logo.png
        drawable-xxhdpi/
          ic_notification_logo.png
        mipmap-anydpi-v26/
          ic_launcher.xml
        mipmap-hdpi/
          ic_launcher_background.png
          ic_launcher_foreground.png
          ic_launcher_monochrome.png
          ic_launcher.png
        mipmap-mdpi/
          ic_launcher_background.png
          ic_launcher_foreground.png
          ic_launcher_monochrome.png
          ic_launcher.png
        mipmap-xhdpi/
          ic_launcher_background.png
          ic_launcher_foreground.png
          ic_launcher_monochrome.png
          ic_launcher.png
        mipmap-xxhdpi/
          ic_launcher_background.png
          ic_launcher_foreground.png
          ic_launcher_monochrome.png
          ic_launcher.png
        mipmap-xxxhdpi/
          ic_launcher_background.png
          ic_launcher_foreground.png
          ic_launcher_monochrome.png
          ic_launcher.png
        raw/
          aboutlibraries.json
        values/
          colors.xml
          dimens.xml
          ic_launcher_background.xml
          strings.xml
          themes.xml
        values-de-rDE/
          strings.xml
        values-es-rES/
          strings.xml
        values-fr/
          strings.xml
        values-gl-rES/
          strings.xml
        values-pl/
          strings.xml
        values-pt-rPT/
          strings.xml
        values-ru/
          strings.xml
        values-uk/
          strings.xml
        values-zh-rCN/
          strings.xml
        xml/
          backup_rules.xml
          data_extraction_rules.xml
          filepaths.xml
          network_security_config.xml
      AndroidManifest.xml
      ic_launcher-playstore.png
    test/
      java/
        com/
          mydeck/
            app/
              domain/
                usecase/
                  LoadBookmarksUseCaseTest.kt
                BookmarkRepositoryImplTest.kt
                UserRepositoryImplTest.kt
              io/
                db/
                  BookmarkDaoTest.kt
                  MyDeckDatabaseMigrationTest.kt
                rest/
                  ReadeckApiTest.kt
              test/
                logging/
                  TimberTestTree.kt
              ui/
                detail/
                  BookmarkDetailViewModelTest.kt
                list/
                  BookmarkListViewModelTest.kt
                settings/
                  AccountSettingsViewModelTest.kt
                  SettingsScreenRobolectricTest.kt
                  SettingsScreenUnitTest.kt
                  SettingsViewModelTest.kt
              util/
                UtilsTest.kt
              ExampleUnitTest.kt
      resources/
        api/
          auth-failure.json
          auth.json
          bookmarks.json
          update-invalid-data.json
          update-success.json
  .gitignore
  build.gradle.kts
  lint-baseline.xml
  proguard-rules.pro
config/
  libraries/
    sakura.json
gradle/
  wrapper/
    gradle-wrapper.jar
    gradle-wrapper.properties
  libs.versions.toml
.gitignore
.repomixignore
build.gradle.kts
CHANGELOG.md
export-libraries.sh
gradle.properties
gradlew
gradlew.bat
LICENSE
README.md
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/schemas/com.mydeck.app.io.db.MyDeckDatabase/1.json">
{
  "formatVersion": 1,
  "database": {
    "version": 1,
    "identityHash": "d17c5ce265499bcc9c30f9c3d479fc59",
    "entities": [
      {
        "tableName": "bookmarks",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `href` TEXT NOT NULL, `created` INTEGER NOT NULL, `updated` INTEGER NOT NULL, `state` INTEGER NOT NULL, `loaded` INTEGER NOT NULL, `url` TEXT NOT NULL, `title` TEXT NOT NULL, `siteName` TEXT NOT NULL, `site` TEXT NOT NULL, `authors` TEXT NOT NULL, `lang` TEXT NOT NULL, `textDirection` TEXT NOT NULL, `documentTpe` TEXT NOT NULL, `type` TEXT NOT NULL, `hasArticle` INTEGER NOT NULL, `description` TEXT NOT NULL, `isDeleted` INTEGER NOT NULL, `isMarked` INTEGER NOT NULL, `isArchived` INTEGER NOT NULL, `labels` TEXT NOT NULL, `readProgress` INTEGER NOT NULL, `wordCount` INTEGER, `readingTime` INTEGER, `articleContent` TEXT, `article_src` TEXT NOT NULL, `icon_src` TEXT NOT NULL, `icon_width` INTEGER NOT NULL, `icon_height` INTEGER NOT NULL, `image_src` TEXT NOT NULL, `image_width` INTEGER NOT NULL, `image_height` INTEGER NOT NULL, `log_src` TEXT NOT NULL, `props_src` TEXT NOT NULL, `thumbnail_src` TEXT NOT NULL, `thumbnail_width` INTEGER NOT NULL, `thumbnail_height` INTEGER NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "href",
            "columnName": "href",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "created",
            "columnName": "created",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "updated",
            "columnName": "updated",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "state",
            "columnName": "state",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "loaded",
            "columnName": "loaded",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "url",
            "columnName": "url",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "title",
            "columnName": "title",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "siteName",
            "columnName": "siteName",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "site",
            "columnName": "site",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "authors",
            "columnName": "authors",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "lang",
            "columnName": "lang",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "textDirection",
            "columnName": "textDirection",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "documentTpe",
            "columnName": "documentTpe",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "type",
            "columnName": "type",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "hasArticle",
            "columnName": "hasArticle",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "description",
            "columnName": "description",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "isDeleted",
            "columnName": "isDeleted",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isMarked",
            "columnName": "isMarked",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isArchived",
            "columnName": "isArchived",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "labels",
            "columnName": "labels",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "readProgress",
            "columnName": "readProgress",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "wordCount",
            "columnName": "wordCount",
            "affinity": "INTEGER",
            "notNull": false
          },
          {
            "fieldPath": "readingTime",
            "columnName": "readingTime",
            "affinity": "INTEGER",
            "notNull": false
          },
          {
            "fieldPath": "articleContent",
            "columnName": "articleContent",
            "affinity": "TEXT",
            "notNull": false
          },
          {
            "fieldPath": "article.src",
            "columnName": "article_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.src",
            "columnName": "icon_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.width",
            "columnName": "icon_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "icon.height",
            "columnName": "icon_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.src",
            "columnName": "image_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "image.width",
            "columnName": "image_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.height",
            "columnName": "image_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "log.src",
            "columnName": "log_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "props.src",
            "columnName": "props_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.src",
            "columnName": "thumbnail_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.width",
            "columnName": "thumbnail_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.height",
            "columnName": "thumbnail_height",
            "affinity": "INTEGER",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "index_bookmarks_readProgress",
            "unique": false,
            "columnNames": [
              "readProgress"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_readProgress` ON `${TABLE_NAME}` (`readProgress`)"
          },
          {
            "name": "index_bookmarks_type",
            "unique": false,
            "columnNames": [
              "type"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_type` ON `${TABLE_NAME}` (`type`)"
          },
          {
            "name": "index_bookmarks_isArchived",
            "unique": false,
            "columnNames": [
              "isArchived"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isArchived` ON `${TABLE_NAME}` (`isArchived`)"
          },
          {
            "name": "index_bookmarks_isMarked",
            "unique": false,
            "columnNames": [
              "isMarked"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isMarked` ON `${TABLE_NAME}` (`isMarked`)"
          }
        ],
        "foreignKeys": []
      }
    ],
    "views": [],
    "setupQueries": [
      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, 'd17c5ce265499bcc9c30f9c3d479fc59')"
    ]
  }
}
</file>

<file path="app/schemas/com.mydeck.app.io.db.MyDeckDatabase/2.json">
{
  "formatVersion": 1,
  "database": {
    "version": 2,
    "identityHash": "40710bc55251427d44ed40814f64f0e1",
    "entities": [
      {
        "tableName": "bookmarks",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `href` TEXT NOT NULL, `created` INTEGER NOT NULL, `updated` INTEGER NOT NULL, `state` INTEGER NOT NULL, `loaded` INTEGER NOT NULL, `url` TEXT NOT NULL, `title` TEXT NOT NULL, `siteName` TEXT NOT NULL, `site` TEXT NOT NULL, `authors` TEXT NOT NULL, `lang` TEXT NOT NULL, `textDirection` TEXT NOT NULL, `documentTpe` TEXT NOT NULL, `type` TEXT NOT NULL, `hasArticle` INTEGER NOT NULL, `description` TEXT NOT NULL, `isDeleted` INTEGER NOT NULL, `isMarked` INTEGER NOT NULL, `isArchived` INTEGER NOT NULL, `labels` TEXT NOT NULL, `readProgress` INTEGER NOT NULL, `wordCount` INTEGER, `readingTime` INTEGER, `article_src` TEXT NOT NULL, `icon_src` TEXT NOT NULL, `icon_width` INTEGER NOT NULL, `icon_height` INTEGER NOT NULL, `image_src` TEXT NOT NULL, `image_width` INTEGER NOT NULL, `image_height` INTEGER NOT NULL, `log_src` TEXT NOT NULL, `props_src` TEXT NOT NULL, `thumbnail_src` TEXT NOT NULL, `thumbnail_width` INTEGER NOT NULL, `thumbnail_height` INTEGER NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "href",
            "columnName": "href",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "created",
            "columnName": "created",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "updated",
            "columnName": "updated",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "state",
            "columnName": "state",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "loaded",
            "columnName": "loaded",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "url",
            "columnName": "url",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "title",
            "columnName": "title",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "siteName",
            "columnName": "siteName",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "site",
            "columnName": "site",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "authors",
            "columnName": "authors",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "lang",
            "columnName": "lang",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "textDirection",
            "columnName": "textDirection",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "documentTpe",
            "columnName": "documentTpe",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "type",
            "columnName": "type",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "hasArticle",
            "columnName": "hasArticle",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "description",
            "columnName": "description",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "isDeleted",
            "columnName": "isDeleted",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isMarked",
            "columnName": "isMarked",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isArchived",
            "columnName": "isArchived",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "labels",
            "columnName": "labels",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "readProgress",
            "columnName": "readProgress",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "wordCount",
            "columnName": "wordCount",
            "affinity": "INTEGER",
            "notNull": false
          },
          {
            "fieldPath": "readingTime",
            "columnName": "readingTime",
            "affinity": "INTEGER",
            "notNull": false
          },
          {
            "fieldPath": "article.src",
            "columnName": "article_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.src",
            "columnName": "icon_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.width",
            "columnName": "icon_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "icon.height",
            "columnName": "icon_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.src",
            "columnName": "image_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "image.width",
            "columnName": "image_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.height",
            "columnName": "image_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "log.src",
            "columnName": "log_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "props.src",
            "columnName": "props_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.src",
            "columnName": "thumbnail_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.width",
            "columnName": "thumbnail_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.height",
            "columnName": "thumbnail_height",
            "affinity": "INTEGER",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "index_bookmarks_readProgress",
            "unique": false,
            "columnNames": [
              "readProgress"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_readProgress` ON `${TABLE_NAME}` (`readProgress`)"
          },
          {
            "name": "index_bookmarks_type",
            "unique": false,
            "columnNames": [
              "type"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_type` ON `${TABLE_NAME}` (`type`)"
          },
          {
            "name": "index_bookmarks_isArchived",
            "unique": false,
            "columnNames": [
              "isArchived"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isArchived` ON `${TABLE_NAME}` (`isArchived`)"
          },
          {
            "name": "index_bookmarks_isMarked",
            "unique": false,
            "columnNames": [
              "isMarked"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isMarked` ON `${TABLE_NAME}` (`isMarked`)"
          }
        ],
        "foreignKeys": []
      },
      {
        "tableName": "article_content",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`bookmarkId` TEXT NOT NULL, `content` TEXT NOT NULL, PRIMARY KEY(`bookmarkId`), FOREIGN KEY(`bookmarkId`) REFERENCES `bookmarks`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE )",
        "fields": [
          {
            "fieldPath": "bookmarkId",
            "columnName": "bookmarkId",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "content",
            "columnName": "content",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "bookmarkId"
          ]
        },
        "indices": [],
        "foreignKeys": [
          {
            "table": "bookmarks",
            "onDelete": "CASCADE",
            "onUpdate": "NO ACTION",
            "columns": [
              "bookmarkId"
            ],
            "referencedColumns": [
              "id"
            ]
          }
        ]
      }
    ],
    "views": [],
    "setupQueries": [
      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '40710bc55251427d44ed40814f64f0e1')"
    ]
  }
}
</file>

<file path="app/schemas/com.mydeck.app.io.db.MyDeckDatabase/3.json">
{
  "formatVersion": 1,
  "database": {
    "version": 3,
    "identityHash": "b087bbe44cd3990fbea51e8ccb8fcd5a",
    "entities": [
      {
        "tableName": "bookmarks",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `href` TEXT NOT NULL, `created` INTEGER NOT NULL, `updated` INTEGER NOT NULL, `state` INTEGER NOT NULL, `loaded` INTEGER NOT NULL, `url` TEXT NOT NULL, `title` TEXT NOT NULL, `siteName` TEXT NOT NULL, `site` TEXT NOT NULL, `authors` TEXT NOT NULL, `lang` TEXT NOT NULL, `textDirection` TEXT NOT NULL, `documentTpe` TEXT NOT NULL, `type` TEXT NOT NULL, `hasArticle` INTEGER NOT NULL, `description` TEXT NOT NULL, `isDeleted` INTEGER NOT NULL, `isMarked` INTEGER NOT NULL, `isArchived` INTEGER NOT NULL, `labels` TEXT NOT NULL, `readProgress` INTEGER NOT NULL, `wordCount` INTEGER, `readingTime` INTEGER, `article_src` TEXT NOT NULL, `icon_src` TEXT NOT NULL, `icon_width` INTEGER NOT NULL, `icon_height` INTEGER NOT NULL, `image_src` TEXT NOT NULL, `image_width` INTEGER NOT NULL, `image_height` INTEGER NOT NULL, `log_src` TEXT NOT NULL, `props_src` TEXT NOT NULL, `thumbnail_src` TEXT NOT NULL, `thumbnail_width` INTEGER NOT NULL, `thumbnail_height` INTEGER NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "href",
            "columnName": "href",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "created",
            "columnName": "created",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "updated",
            "columnName": "updated",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "state",
            "columnName": "state",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "loaded",
            "columnName": "loaded",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "url",
            "columnName": "url",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "title",
            "columnName": "title",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "siteName",
            "columnName": "siteName",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "site",
            "columnName": "site",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "authors",
            "columnName": "authors",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "lang",
            "columnName": "lang",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "textDirection",
            "columnName": "textDirection",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "documentTpe",
            "columnName": "documentTpe",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "type",
            "columnName": "type",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "hasArticle",
            "columnName": "hasArticle",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "description",
            "columnName": "description",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "isDeleted",
            "columnName": "isDeleted",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isMarked",
            "columnName": "isMarked",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isArchived",
            "columnName": "isArchived",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "labels",
            "columnName": "labels",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "readProgress",
            "columnName": "readProgress",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "wordCount",
            "columnName": "wordCount",
            "affinity": "INTEGER",
            "notNull": false
          },
          {
            "fieldPath": "readingTime",
            "columnName": "readingTime",
            "affinity": "INTEGER",
            "notNull": false
          },
          {
            "fieldPath": "article.src",
            "columnName": "article_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.src",
            "columnName": "icon_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.width",
            "columnName": "icon_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "icon.height",
            "columnName": "icon_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.src",
            "columnName": "image_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "image.width",
            "columnName": "image_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.height",
            "columnName": "image_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "log.src",
            "columnName": "log_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "props.src",
            "columnName": "props_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.src",
            "columnName": "thumbnail_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.width",
            "columnName": "thumbnail_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.height",
            "columnName": "thumbnail_height",
            "affinity": "INTEGER",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "index_bookmarks_readProgress",
            "unique": false,
            "columnNames": [
              "readProgress"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_readProgress` ON `${TABLE_NAME}` (`readProgress`)"
          },
          {
            "name": "index_bookmarks_type",
            "unique": false,
            "columnNames": [
              "type"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_type` ON `${TABLE_NAME}` (`type`)"
          },
          {
            "name": "index_bookmarks_isArchived",
            "unique": false,
            "columnNames": [
              "isArchived"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isArchived` ON `${TABLE_NAME}` (`isArchived`)"
          },
          {
            "name": "index_bookmarks_isMarked",
            "unique": false,
            "columnNames": [
              "isMarked"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isMarked` ON `${TABLE_NAME}` (`isMarked`)"
          }
        ],
        "foreignKeys": []
      },
      {
        "tableName": "article_content",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`bookmarkId` TEXT NOT NULL, `content` TEXT NOT NULL, PRIMARY KEY(`bookmarkId`), FOREIGN KEY(`bookmarkId`) REFERENCES `bookmarks`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE )",
        "fields": [
          {
            "fieldPath": "bookmarkId",
            "columnName": "bookmarkId",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "content",
            "columnName": "content",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "bookmarkId"
          ]
        },
        "indices": [],
        "foreignKeys": [
          {
            "table": "bookmarks",
            "onDelete": "CASCADE",
            "onUpdate": "NO ACTION",
            "columns": [
              "bookmarkId"
            ],
            "referencedColumns": [
              "id"
            ]
          }
        ]
      },
      {
        "tableName": "remote_bookmark_ids",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [],
        "foreignKeys": []
      }
    ],
    "views": [],
    "setupQueries": [
      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, 'b087bbe44cd3990fbea51e8ccb8fcd5a')"
    ]
  }
}
</file>

<file path="app/schemas/com.mydeck.app.io.db.MyDeckDatabase/5.json">
{
  "formatVersion": 1,
  "database": {
    "version": 5,
    "identityHash": "71a33bbf212fec652baf33d0a88ae495",
    "entities": [
      {
        "tableName": "bookmarks",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `href` TEXT NOT NULL, `created` INTEGER NOT NULL, `updated` INTEGER NOT NULL, `state` INTEGER NOT NULL, `loaded` INTEGER NOT NULL, `url` TEXT NOT NULL, `title` TEXT NOT NULL, `siteName` TEXT NOT NULL, `site` TEXT NOT NULL, `authors` TEXT NOT NULL, `lang` TEXT NOT NULL, `textDirection` TEXT NOT NULL, `documentTpe` TEXT NOT NULL, `type` TEXT NOT NULL, `hasArticle` INTEGER NOT NULL, `description` TEXT NOT NULL, `isDeleted` INTEGER NOT NULL, `isMarked` INTEGER NOT NULL, `isArchived` INTEGER NOT NULL, `labels` TEXT NOT NULL, `readProgress` INTEGER NOT NULL, `wordCount` INTEGER, `readingTime` INTEGER, `published` INTEGER, `embed` TEXT, `embedHostname` TEXT, `contentState` INTEGER NOT NULL, `contentFailureReason` TEXT, `article_src` TEXT NOT NULL, `icon_src` TEXT NOT NULL, `icon_width` INTEGER NOT NULL, `icon_height` INTEGER NOT NULL, `image_src` TEXT NOT NULL, `image_width` INTEGER NOT NULL, `image_height` INTEGER NOT NULL, `log_src` TEXT NOT NULL, `props_src` TEXT NOT NULL, `thumbnail_src` TEXT NOT NULL, `thumbnail_width` INTEGER NOT NULL, `thumbnail_height` INTEGER NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "href",
            "columnName": "href",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "created",
            "columnName": "created",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "updated",
            "columnName": "updated",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "state",
            "columnName": "state",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "loaded",
            "columnName": "loaded",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "url",
            "columnName": "url",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "title",
            "columnName": "title",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "siteName",
            "columnName": "siteName",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "site",
            "columnName": "site",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "authors",
            "columnName": "authors",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "lang",
            "columnName": "lang",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "textDirection",
            "columnName": "textDirection",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "documentTpe",
            "columnName": "documentTpe",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "type",
            "columnName": "type",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "hasArticle",
            "columnName": "hasArticle",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "description",
            "columnName": "description",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "isDeleted",
            "columnName": "isDeleted",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isMarked",
            "columnName": "isMarked",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isArchived",
            "columnName": "isArchived",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "labels",
            "columnName": "labels",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "readProgress",
            "columnName": "readProgress",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "wordCount",
            "columnName": "wordCount",
            "affinity": "INTEGER"
          },
          {
            "fieldPath": "readingTime",
            "columnName": "readingTime",
            "affinity": "INTEGER"
          },
          {
            "fieldPath": "published",
            "columnName": "published",
            "affinity": "INTEGER"
          },
          {
            "fieldPath": "embed",
            "columnName": "embed",
            "affinity": "TEXT"
          },
          {
            "fieldPath": "embedHostname",
            "columnName": "embedHostname",
            "affinity": "TEXT"
          },
          {
            "fieldPath": "contentState",
            "columnName": "contentState",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "contentFailureReason",
            "columnName": "contentFailureReason",
            "affinity": "TEXT"
          },
          {
            "fieldPath": "article.src",
            "columnName": "article_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.src",
            "columnName": "icon_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.width",
            "columnName": "icon_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "icon.height",
            "columnName": "icon_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.src",
            "columnName": "image_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "image.width",
            "columnName": "image_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.height",
            "columnName": "image_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "log.src",
            "columnName": "log_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "props.src",
            "columnName": "props_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.src",
            "columnName": "thumbnail_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.width",
            "columnName": "thumbnail_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.height",
            "columnName": "thumbnail_height",
            "affinity": "INTEGER",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "index_bookmarks_readProgress",
            "unique": false,
            "columnNames": [
              "readProgress"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_readProgress` ON `${TABLE_NAME}` (`readProgress`)"
          },
          {
            "name": "index_bookmarks_type",
            "unique": false,
            "columnNames": [
              "type"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_type` ON `${TABLE_NAME}` (`type`)"
          },
          {
            "name": "index_bookmarks_isArchived",
            "unique": false,
            "columnNames": [
              "isArchived"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isArchived` ON `${TABLE_NAME}` (`isArchived`)"
          },
          {
            "name": "index_bookmarks_isMarked",
            "unique": false,
            "columnNames": [
              "isMarked"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isMarked` ON `${TABLE_NAME}` (`isMarked`)"
          }
        ]
      },
      {
        "tableName": "article_content",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`bookmarkId` TEXT NOT NULL, `content` TEXT NOT NULL, PRIMARY KEY(`bookmarkId`), FOREIGN KEY(`bookmarkId`) REFERENCES `bookmarks`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE )",
        "fields": [
          {
            "fieldPath": "bookmarkId",
            "columnName": "bookmarkId",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "content",
            "columnName": "content",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "bookmarkId"
          ]
        },
        "foreignKeys": [
          {
            "table": "bookmarks",
            "onDelete": "CASCADE",
            "onUpdate": "NO ACTION",
            "columns": [
              "bookmarkId"
            ],
            "referencedColumns": [
              "id"
            ]
          }
        ]
      },
      {
        "tableName": "remote_bookmark_ids",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        }
      }
    ],
    "setupQueries": [
      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '71a33bbf212fec652baf33d0a88ae495')"
    ]
  }
}
</file>

<file path="app/src/androidTest/java/com/mydeck/app/ExampleInstrumentedTest.kt">
package com.mydeck.app

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.mydeck.app", appContext.packageName)
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/coroutine/ApplicationScope.kt">
package com.mydeck.app.coroutine

import javax.inject.Qualifier

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class ApplicationScope()
</file>

<file path="app/src/main/java/com/mydeck/app/coroutine/IoDispatcher.kt">
package com.mydeck.app.coroutine

import javax.inject.Qualifier

@Qualifier
@Retention(AnnotationRetention.RUNTIME)
annotation class IoDispatcher()
</file>

<file path="app/src/main/java/com/mydeck/app/di/ViewModelModule.kt">
package com.mydeck.app.di

import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ViewModelComponent
import com.mydeck.app.io.AssetLoader
import com.mydeck.app.io.AssetLoaderImpl

@Module
@InstallIn(ViewModelComponent::class)
interface ViewModelModule {
    @Binds
    fun bindAssetLoader(assetLoaderImpl: AssetLoaderImpl): AssetLoader
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/AuthenticationDetails.kt">
package com.mydeck.app.domain.model

data class AuthenticationDetails(
    val url: String,
    val username: String,
    val password: String,
    val token: String
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/AutoSyncTimeframe.kt">
package com.mydeck.app.domain.model

import java.util.concurrent.TimeUnit


enum class AutoSyncTimeframe(val repeatInterval: Long, val repeatIntervalTimeUnit: TimeUnit) {
    MANUAL(0L, TimeUnit.MILLISECONDS),
    HOURS_01(1L, TimeUnit.HOURS),
    HOURS_06(6L, TimeUnit.HOURS),
    HOURS_12(12L, TimeUnit.HOURS),
    DAYS_01(1L, TimeUnit.DAYS),
    DAYS_07(7L, TimeUnit.DAYS),
    DAYS_14(14L, TimeUnit.DAYS),
    DAYS_30(30L, TimeUnit.DAYS)
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/BookmarkCounts.kt">
package com.mydeck.app.domain.model

data class BookmarkCounts(
    val unread: Int = 0,
    val archived: Int = 0,
    val favorite: Int = 0,
    val article: Int = 0,
    val video: Int = 0,
    val picture: Int = 0,
    val total: Int = 0
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/SharedText.kt">
package com.mydeck.app.domain.model

import kotlinx.serialization.Serializable

@Serializable
data class SharedText(
    val url: String,
    val title: String? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/Template.kt">
package com.mydeck.app.domain.model

sealed interface Template {
    fun getTemplate(isSystemInDarkMode: Boolean): String
    data class SimpleTemplate(val template: String): Template {
        override fun getTemplate(isSystemInDarkMode: Boolean): String {
            return template
        }
    }
    data class DynamicTemplate(val light: String, val dark: String): Template {
        override fun getTemplate(isSystemInDarkMode: Boolean): String {
            return if (isSystemInDarkMode) {
                dark
            } else {
                light
            }
        }
    }
    companion object {
        const val LIGHT_TEMPLATE_FILE = "html_template_light.html"
        const val DARK_TEMPLATE_FILE = "html_template_dark.html"
        const val SEPIA_TEMPLATE_FILE = "html_template_sepia.html"
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/Theme.kt">
package com.mydeck.app.domain.model

enum class Theme {
    LIGHT,
    DARK,
    SEPIA,
    SYSTEM
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/User.kt">
package com.mydeck.app.domain.model

data class User(
    val username: String,
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/usecase/AuthenticateUseCase.kt">
package com.mydeck.app.domain.usecase

import android.content.Context
import dagger.hilt.android.qualifiers.ApplicationContext
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.UserRepository
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.worker.LoadBookmarksWorker
import kotlinx.datetime.Instant
import javax.inject.Inject

sealed class AuthenticationResult {
    data object Success : AuthenticationResult()
    data class AuthenticationFailed(val message: String) : AuthenticationResult()
    data class NetworkError(val message: String) : AuthenticationResult()
    data class GenericError(val message: String) : AuthenticationResult()
}

class AuthenticateUseCase @Inject constructor(
    private val settingsDataStore: SettingsDataStore,
    private val userRepository: UserRepository,
    private val bookmarkRepository: BookmarkRepository,
    @ApplicationContext private val context: Context // Need context to enqueue worker
) {
    suspend fun execute(url: String, username: String, password: String): AuthenticationResult {

        return when(val loginResult = userRepository.login(url, username, password)) {
            is UserRepository.LoginResult.Success -> {
                bookmarkRepository.deleteAllBookmarks()
                settingsDataStore.saveLastBookmarkTimestamp(Instant.fromEpochMilliseconds(0))
                LoadBookmarksWorker.enqueue(context, isInitialLoad = true)
                settingsDataStore.setInitialSyncPerformed(true)
                AuthenticationResult.Success
            }
            is UserRepository.LoginResult.Error -> AuthenticationResult.GenericError(loginResult.errorMessage)
            is UserRepository.LoginResult.NetworkError -> AuthenticationResult.NetworkError(loginResult.errorMessage)
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/usecase/FullSyncUseCase.kt">
package com.mydeck.app.domain.usecase

import androidx.work.Constraints
import androidx.work.Data
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.worker.FullSyncWorker
import kotlinx.coroutines.flow.map
import timber.log.Timber
import javax.inject.Inject

class FullSyncUseCase @Inject constructor(
    private val workManager: WorkManager
) {
    val workInfoFlow = workManager.getWorkInfosForUniqueWorkFlow(FullSyncWorker.UNIQUE_NAME_AUTO)
    val syncIsRunning = workManager.getWorkInfosByTagFlow(FullSyncWorker.TAG)
        .map { it.any { it.state == WorkInfo.State.RUNNING } }

    fun performFullSync() {
        Timber.d("Start Full Sync Worker")
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val inputData = Data.Builder()
            .putBoolean(FullSyncWorker.INPUT_IS_MANUAL_SYNC, true)
            .build()

        val request = OneTimeWorkRequestBuilder<FullSyncWorker>()
            .setConstraints(constraints)
            .addTag(FullSyncWorker.TAG)
            .setInputData(inputData)
            .build()
        workManager.enqueueUniqueWork(
            FullSyncWorker.UNIQUE_NAME_MANUAL,
            ExistingWorkPolicy.REPLACE,
            request
        )
    }

    fun scheduleFullSyncWorker(autoSyncTimeframe: AutoSyncTimeframe) {
        Timber.i("Schedule Full Sync Worker [autoSyncTimeframe=$autoSyncTimeframe]")
        if (autoSyncTimeframe == AutoSyncTimeframe.MANUAL) {
            cancelFullSyncWorker()
        } else {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()
            val workRequest = PeriodicWorkRequestBuilder<FullSyncWorker>(
                autoSyncTimeframe.repeatInterval,
                autoSyncTimeframe.repeatIntervalTimeUnit
            )
                .setConstraints(constraints)
                .addTag(FullSyncWorker.TAG)
                .build()
            workManager.enqueueUniquePeriodicWork(
                FullSyncWorker.UNIQUE_NAME_AUTO,
                ExistingPeriodicWorkPolicy.UPDATE,
                workRequest
            )
        }
    }

    fun cancelFullSyncWorker() {
        Timber.i("Cancel Full Sync Worker")
        workManager.cancelUniqueWork(FullSyncWorker.UNIQUE_NAME_AUTO)
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/usecase/UpdateBookmarkUseCase.kt">
package com.mydeck.app.domain.usecase

import com.mydeck.app.domain.BookmarkRepository
import javax.inject.Inject

class UpdateBookmarkUseCase @Inject constructor(
    private val bookmarkRepository: BookmarkRepository
) {
    suspend fun updateIsFavorite(bookmarkId: String, isFavorite: Boolean): Result {
        return handleResult(bookmarkRepository.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = isFavorite,
            isArchived = null,
            isRead = null
        ))
    }

    suspend fun updateIsArchived(bookmarkId: String, isArchived: Boolean): Result {
        return handleResult(bookmarkRepository.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = null,
            isArchived = isArchived,
            isRead = null
        ))
    }

    suspend fun updateIsRead(bookmarkId: String, isRead: Boolean): Result {
        return handleResult(bookmarkRepository.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = null,
            isArchived = null,
            isRead = isRead
        ))
    }

    suspend fun deleteBookmark(bookmarkId: String): Result {
        return handleResult(bookmarkRepository.deleteBookmark(bookmarkId))
    }

    private fun handleResult(result: BookmarkRepository.UpdateResult): Result {
        return when(result) {
            is BookmarkRepository.UpdateResult.Success -> Result.Success
            is BookmarkRepository.UpdateResult.Error -> Result.GenericError(result.errorMessage)
            is BookmarkRepository.UpdateResult.NetworkError -> Result.NetworkError(result.errorMessage)
        }
    }

    sealed class Result {
        data object Success : Result()
        data class GenericError(val message: String) : Result()
        data class NetworkError(val message: String) : Result()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/UserRepository.kt">
package com.mydeck.app.domain

import com.mydeck.app.domain.model.AuthenticationDetails
import com.mydeck.app.domain.model.User
import kotlinx.coroutines.flow.Flow

interface UserRepository {
    fun observeIsLoggedIn(): Flow<Boolean>
    fun observeUser(): Flow<User?>
    fun observeAuthenticationDetails(): Flow<AuthenticationDetails?>
    suspend fun login(url: String, username: String, password: String): LoginResult
    suspend fun login(url: String, appToken: String): LoginResult
    suspend fun logout()
    sealed class LoginResult {
        data object Success: LoginResult()
        data class Error(val errorMessage: String, val code: Int? = null, val ex: Exception? = null): LoginResult()
        data class NetworkError(val errorMessage: String): LoginResult()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/UserRepositoryImpl.kt">
package com.mydeck.app.domain

import com.mydeck.app.domain.model.AuthenticationDetails
import com.mydeck.app.domain.model.User
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.io.rest.ReadeckApi
import com.mydeck.app.io.rest.model.AuthenticationRequestDto
import com.mydeck.app.io.rest.model.StatusMessageDto
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerializationException
import kotlinx.serialization.json.Json
import timber.log.Timber
import java.io.IOException
import javax.inject.Inject

class UserRepositoryImpl @Inject constructor(
    private val settingsDataStore: SettingsDataStore,
    private val readeckApi: ReadeckApi,
    private val json: Json
) : UserRepository {
    override fun observeAuthenticationDetails(): Flow<AuthenticationDetails?> =
        combine(
            settingsDataStore.urlFlow,
            settingsDataStore.usernameFlow,
            settingsDataStore.passwordFlow,
            settingsDataStore.tokenFlow
        ) { url, username, password, token ->
            if (url != null && username != null && password != null && token != null) {
                AuthenticationDetails(url, username, password, token)
            } else {
                null
            }
        }.flowOn(Dispatchers.IO)

    override suspend fun login(
        url: String,
        username: String,
        password: String
    ): UserRepository.LoginResult {
        return withContext(Dispatchers.IO) {
            // save url early to allow call to authenticate endpoint
            settingsDataStore.saveUrl(url)
            try {
                val response = readeckApi.authenticate(
                    AuthenticationRequestDto(
                        username,
                        password,
                        "readeck-app"
                    )
                )
                if (response.isSuccessful && response.body() != null) {
                    response.body()?.let {
                        settingsDataStore.saveCredentials(url, username, password, it.token)
                        UserRepository.LoginResult.Success
                    } ?: UserRepository.LoginResult.Error("Empty response body")
                } else {
                    val errorBodyString = response.errorBody()?.string()
                    val errorState: StatusMessageDto = if (!errorBodyString.isNullOrBlank()) {
                        try {
                            json.decodeFromString<StatusMessageDto>(errorBodyString) // Use json.decodeFromString
                        } catch (e: SerializationException) { // Catch SerializationException
                            StatusMessageDto(
                                response.code(),
                                "Failed to parse error: ${e.message}"
                            )
                        }
                    } else {
                        StatusMessageDto(response.code(), "Empty error body")
                    }
                    UserRepository.LoginResult.Error(
                        errorMessage = errorState.message,
                        code = errorState.status
                    )
                }
            } catch (e: IOException) {
                UserRepository.LoginResult.Error("Network error: ${e.message}", ex = e)
            } catch (e: Exception) {
                UserRepository.LoginResult.Error(
                    "An unexpected error occurred: ${e.message}",
                    ex = e
                )
            }.also {
                if (it !is UserRepository.LoginResult.Success) {
                    // clear credentials in case of error
                    settingsDataStore.clearCredentials()
                    Timber.e("LoginResult is $it -> clearCredentials")
                }
            }
        }
    }

    override suspend fun login(url: String, appToken: String): UserRepository.LoginResult {
        TODO("Not yet implemented")
    }

    override suspend fun logout() {
        TODO("Not yet implemented")
    }

    override fun observeIsLoggedIn(): Flow<Boolean> = observeAuthenticationDetails().map {
        it != null
    }

    override fun observeUser(): Flow<User?> = observeAuthenticationDetails().map {
        if (it != null) {
            User(it.username)
        } else {
            null
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/ArticleContentEntity.kt">
package com.mydeck.app.io.db.model

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.PrimaryKey

@Entity(
    tableName = "article_content",
    foreignKeys = [ForeignKey(
        entity = BookmarkEntity::class,
        parentColumns = ["id"],
        childColumns = ["bookmarkId"],
        onDelete = ForeignKey.CASCADE
    )]
)
data class ArticleContentEntity(
    @PrimaryKey
    val bookmarkId: String,
    val content: String
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/BookmarkCountsEntity.kt">
package com.mydeck.app.io.db.model

import androidx.room.ColumnInfo

data class BookmarkCountsEntity(
    @ColumnInfo(name = "unread_count") val unread: Int,
    @ColumnInfo(name = "archived_count") val archived: Int,
    @ColumnInfo(name = "favorite_count") val favorite: Int,
    @ColumnInfo(name = "article_count") val article: Int,
    @ColumnInfo(name = "video_count") val video: Int,
    @ColumnInfo(name = "picture_count") val picture: Int,
    @ColumnInfo(name = "total_count") val total: Int
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/BookmarkWithArticleContent.kt">
package com.mydeck.app.io.db.model

import androidx.room.Embedded
import androidx.room.Relation

data class BookmarkWithArticleContent(
    @Embedded
    val bookmark: BookmarkEntity,
    @Relation(
        entity = ArticleContentEntity::class,
        parentColumn = "id",
        entityColumn = "bookmarkId"

    )
    val articleContent: ArticleContentEntity?
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/RemoteBookmarkIdEntity.kt">
package com.mydeck.app.io.db.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "remote_bookmark_ids")
data class RemoteBookmarkIdEntity(
    @PrimaryKey val id: String
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/ResourceEntity.kt">
package com.mydeck.app.io.db.model

data class ResourceEntity(
    val src: String
)

data class ImageResourceEntity(
    val src: String,
    val width: Int,
    val height: Int
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/prefs/EncryptionHelper.kt">
package com.mydeck.app.io.prefs

import android.content.Context
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKeys

object EncryptionHelper {

    private const val PREF_FILE_NAME = "encrypted_prefs"

    fun getEncryptedSharedPreferences(context: Context): EncryptedSharedPreferences {
        val masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)

        return EncryptedSharedPreferences.create(
            PREF_FILE_NAME,
            masterKeyAlias,
            context,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        ) as EncryptedSharedPreferences
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/auth/AuthInterceptor.kt">
package com.mydeck.app.io.rest.auth

import okhttp3.Interceptor
import okhttp3.Response
import timber.log.Timber
import javax.inject.Inject

class AuthInterceptor @Inject constructor(
    private val tokenManager: TokenManager,
    private val notificationHelper: NotificationHelper
) : Interceptor {

    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()

        tokenManager.getToken()?.let { token ->
            request.addHeader("Authorization", "Bearer $token")
        }

        val response = chain.proceed(request.build())

        if (response.code == 401) {
            Timber.d("Received 401, showing notification")
            notificationHelper.showUnauthorizedNotification()
        }

        return response
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/auth/NotificationUtil.kt">
package com.mydeck.app.io.rest.auth

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.annotation.RequiresPermission
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.app.TaskStackBuilder
import androidx.core.content.res.ResourcesCompat
import com.mydeck.app.MainActivity
import com.mydeck.app.R

object NotificationUtil {
    @RequiresPermission(Manifest.permission.POST_NOTIFICATIONS)
    fun showUnauthorizedNotification(context: Context, notificationManager: NotificationManagerCompat) {
        val notificationId = 1 // Unique ID for the notification
        val channelId = "synchronization_channel" // Unique channel ID

        // Create an explicit intent for an Activity in your app
        val resultIntent = Intent(context, MainActivity::class.java).apply {
            putExtra("navigateToAccountSettings", true)
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }

        val pendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
            // Add the intent, which inflates the back stack
            addNextIntentWithParentStack(resultIntent)
            // Get the PendingIntent containing the entire back stack
            getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
        }

        // Create the NotificationChannel, but only on API 26+ because
        // the NotificationChannel class is not in the Support Library.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = context.getString(R.string.notification_channel_sync_name)
            val descriptionText = context.getString(R.string.notification_channel_sync_description)
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel = NotificationChannel(channelId, name, importance).apply {
                description = descriptionText
            }
            // Register the channel with the system.
            val notificationService: NotificationManager =
                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationService.createNotificationChannel(channel)
        }

        val builder = NotificationCompat.Builder(context, channelId)
            .setSmallIcon(R.mipmap.ic_launcher_monochrome)
            .setContentTitle(context.getString(R.string.notification_authentication_error_title))
            .setContentText(context.getString(R.string.notification_authentication_error_message))
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setAutoCancel(true)

        // Show the notification
        notificationManager.notify(notificationId, builder.build())
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/auth/TokenManager.kt">
package com.mydeck.app.io.rest.auth

import com.mydeck.app.coroutine.ApplicationScope
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TokenManager @Inject constructor(
    @ApplicationScope applicationScope: CoroutineScope,
    settingsDataStore: SettingsDataStore
) {
    init {
        applicationScope.launch {
            settingsDataStore.tokenFlow.collectLatest {
                token = it
            }
        }
    }

    @Volatile
    private var token: String? = null

    fun getToken(): String? = token
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/ArticleResourceDTO.kt">
package com.mydeck.app.io.rest.model

data class ArticleResourceDTO(
    val src: String? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/AuthenticationRequestDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable

@Serializable
data class AuthenticationRequestDto(
    val username: String,
    val password: String,
    val application: String
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/AuthenticationResponseDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable

@Serializable
data class AuthenticationResponseDto(
    val id: String,
    val token: String,
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/CreateBookmarkDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable

@Serializable
data class CreateBookmarkDto(
    val labels: List<String> = emptyList(),
    val title: String,
    val url: String
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/EditBookmarkDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName

@Serializable
data class EditBookmarkDto(
    @SerialName("add_labels")
    val addLabels: List<String>? = null,
    @SerialName("is_archived")
    val isArchived: Boolean? = null,
    @SerialName("is_deleted")
    val isDeleted: Boolean? = null,
    @SerialName("is_marked")
    val isMarked: Boolean? = null,
    val labels: List<String>? = null,
    @SerialName("read_anchor")
    val readAnchor: String? = null,
    @SerialName("read_progress")
    val readProgress: Int? = null,
    @SerialName("remove_labels")
    val removeLabels: List<String>? = null,
    val title: String? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/EditBookmarkErrorDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.json.JsonIgnoreUnknownKeys

@Serializable
data class EditBookmarkErrorDto(
    val errors: List<String>? = null,
    val fields: Map<String, FieldError>? = null,
    @SerialName("is_valid")
    val isValid: Boolean? = null
) {
    @OptIn(ExperimentalSerializationApi::class)
    @Serializable
    @JsonIgnoreUnknownKeys
    data class FieldError(
        val errors: List<String>? = null,
        @SerialName("is_bound")
        val isBound: Boolean? = null,
        @SerialName("is_null")
        val isNull: Boolean? = null
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/EditBookmarkResponseDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.datetime.Instant
import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName

@Serializable
data class EditBookmarkResponseDto(
    val href: String,
    val id: String,
    @SerialName("is_archived")
    val isArchived: Boolean? = null,
    @SerialName("is_deleted")
    val isDeleted: Boolean? = null,
    @SerialName("is_marked")
    val isMarked: Boolean? = null,
    val labels: List<String>? = null,
    @SerialName("read_anchor")
    val readAnchor: String? = null,
    @SerialName("read_progress")
    val readProgress: Int? = null,
    val title: String? = null,
    val updated: Instant
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/IconResourceDTO.kt">
package com.mydeck.app.io.rest.model

data class IconResourceDTO(
    val src: String? = null,
    val width: Int? = null,
    val height: Int? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/ImageResourceDTO.kt">
package com.mydeck.app.io.rest.model

data class ImageResourceDTO(
    val src: String? = null,
    val width: Int? = null,
    val height: Int? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/LogResourceDTO.kt">
package com.mydeck.app.io.rest.model

data class LogResourceDTO(
    val src: String? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/PropsResourceDTO.kt">
package com.mydeck.app.io.rest.model

data class PropsResourceDTO(
    val src: String? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/ResourcesDTO.kt">
package com.mydeck.app.io.rest.model

data class ResourcesDTO(
    val article: ArticleResourceDTO? = null,
    val icon: IconResourceDTO? = null,
    val image: ImageResourceDTO? = null,
    val log: LogResourceDTO? = null,
    val props: PropsResourceDTO? = null,
    val thumbnail: ThumbnailResourceDTO? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/StatusMessageDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable

@Serializable
data class StatusMessageDto(
    val status: Int,
    val message: String,
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/SyncContentRequestDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable

@Serializable
data class SyncContentRequestDto(
    val ids: List<String>
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/SyncStatusDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.serialization.Serializable

@Serializable
data class SyncStatusDto(
    val id: String,
    val status: String,  // "ok" or "deleted"
    val updated: String? = null  // ISO 8601 timestamp
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/ThumbnailResourceDTO.kt">
package com.mydeck.app.io.rest.model

data class ThumbnailResourceDTO(
    val src: String? = null,
    val width: Int? = null,
    val height: Int? = null
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/UserProfileDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.datetime.Instant
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class UserProfileDto(
    val provider: ProviderDto,
    val user: UserDto
)

@Serializable
data class ProviderDto(
    val name: String,
    val id: String,
    val application: String,
    val roles: List<String>,
    val permissions: List<String>
)

@Serializable
data class UserDto(
    val username: String,
    val email: String,
    val created: Instant,
    val updated: Instant,
    val settings: SettingsDto
)

@Serializable
data class SettingsDto(
    @SerialName("debug_info")
    val debugInfo: Boolean,
    val lang: String,
    @SerialName("reader_settings")
    val readerSettings: ReaderSettingsDto
)

@Serializable
data class ReaderSettingsDto(
    val width: Int,
    val font: String,
    @SerialName("font_size")
    val fontSize: Int,
    @SerialName("line_height")
    val lineHeight: Int,
    val justify: Int,
    val hyphenation: Int
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/NetworkModule.kt">
package com.mydeck.app.io.rest

import android.content.Context
import androidx.core.app.NotificationManagerCompat
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import com.mydeck.app.BuildConfig
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.io.prefs.SettingsDataStoreImpl
import com.mydeck.app.io.rest.auth.AuthInterceptor
import com.mydeck.app.io.rest.auth.NotificationHelper
import com.mydeck.app.io.rest.auth.NotificationHelperImpl
import kotlinx.serialization.json.Json
import okhttp3.OkHttpClient
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.kotlinx.serialization.asConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.create
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideOkHttpClient(
        authInterceptor: AuthInterceptor,
        baseUrlInterceptor: UrlInterceptor
    ): OkHttpClient {
        val builder = OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .addInterceptor(baseUrlInterceptor)

        if (BuildConfig.DEBUG) {
            val loggingInterceptor = HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BASIC
            }
            builder.addInterceptor(loggingInterceptor)
        }

        return builder.build()
    }

    @Provides
    @Singleton
    fun provideRetrofit(
        okHttpClient: OkHttpClient,
        json: Json
    ): Retrofit {
        val mediaType = "application/json; charset=UTF8".toMediaType()
        return Retrofit.Builder()
            .baseUrl("http://readeck.invalid/")
            .client(okHttpClient)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(json.asConverterFactory(mediaType))
            .build()
    }

    @Provides
    @Singleton
    fun provideReadeckApiService(retrofit: Retrofit): ReadeckApi {
        return retrofit.create()
    }

    @Provides
    @Singleton
    fun provideSettingsDataStore(impl: SettingsDataStoreImpl): SettingsDataStore {
        return impl
    }

    @Provides
    @Singleton
    fun provideNotificationManagerCompat(@ApplicationContext context: Context): NotificationManagerCompat {
        return NotificationManagerCompat.from(context)
    }

    @Provides
    fun provideNotificationHelper(
        @ApplicationContext context: Context,
        notificationManager: NotificationManagerCompat
    ): NotificationHelper {
        return NotificationHelperImpl(context, notificationManager)
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/ReadeckApi.kt">
package com.mydeck.app.io.rest

import com.mydeck.app.io.rest.model.AuthenticationRequestDto
import com.mydeck.app.io.rest.model.AuthenticationResponseDto
import com.mydeck.app.io.rest.model.BookmarkDto
import com.mydeck.app.io.rest.model.UserProfileDto
import com.mydeck.app.io.rest.model.CreateBookmarkDto
import com.mydeck.app.io.rest.model.StatusMessageDto
import com.mydeck.app.io.rest.model.EditBookmarkDto
import com.mydeck.app.io.rest.model.EditBookmarkErrorDto
import com.mydeck.app.io.rest.model.EditBookmarkResponseDto
import com.mydeck.app.io.rest.model.SyncContentRequestDto
import com.mydeck.app.io.rest.model.SyncStatusDto
import kotlinx.datetime.Instant
import retrofit2.Response
import retrofit2.http.GET
import retrofit2.http.POST
import retrofit2.http.PATCH
import retrofit2.http.Query
import retrofit2.http.DELETE
import retrofit2.http.Body
import retrofit2.http.Headers
import retrofit2.http.Path

interface ReadeckApi {
    @GET("bookmarks")
    suspend fun getBookmarks(
        @Query("limit") limit: Int,
        @Query("offset") offset: Int,
        @Query("updated_since") updatedSince: Instant?,
        @Query("sort") sortOrder: SortOrder
    ): Response<List<BookmarkDto>>


    @GET("bookmarks/sync")
    suspend fun getSyncStatus(
        @Query("since") since: String?  // ISO 8601 formatted timestamp
    ): Response<List<SyncStatusDto>>

    @POST("bookmarks/sync")
    suspend fun syncContent(
        @Body body: SyncContentRequestDto
    ): Response<List<BookmarkDto>>

    @POST("auth")
    suspend fun authenticate(
        @Body body: AuthenticationRequestDto
    ): Response<AuthenticationResponseDto>

    @GET("profile")
    suspend fun userprofile(): Response<UserProfileDto>

    @Headers("Content-Type: text/html")
    @GET("bookmarks/{id}/article")
    suspend fun getArticle(@Path("id") id: String): Response<String>

    @GET("bookmarks/{id}")
    suspend fun getBookmarkById(@Path("id") id: String): Response<BookmarkDto>

    @POST("bookmarks")
    suspend fun createBookmark(
        @Body body: CreateBookmarkDto
    ): Response<StatusMessageDto>

    @Headers("Accept: application/json")
    @PATCH("bookmarks/{id}")
    suspend fun editBookmark(
        @Path("id") id: String,
        @Body body: EditBookmarkDto
    ): Response<EditBookmarkResponseDto>

    @Headers("Accept: application/json")
    @DELETE("bookmarks/{id}")
    suspend fun deleteBookmark(@Path("id") id: String): Response<Unit>

    data class SortOrder(val sort: Sort, val order: Order = Order.Ascending) {
        override fun toString(): String {
            return "${order.value}${sort.value}"
        }
    }

    sealed class Sort(val value: String) {
        data object Created: Sort("created")
        data object Title: Sort("title")
        data object Domain: Sort("domain")
        data object Duration: Sort("duration")
        data object Published: Sort("published")
        data object Site: Sort("site")
    }

    sealed class Order(val value: String) {
        data object Ascending: Order("")
        data object Descending: Order("-")
    }

    interface Header {
        companion object {
            const val TOTAL_PAGES = "total-pages"
            const val TOTAL_COUNT = "total-count"
            const val CURRENT_PAGE = "current-page"
            const val BOOKMARK_ID = "bookmark-id"
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/ReadeckApiService.kt">

</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/UrlInterceptor.kt">
package com.mydeck.app.io.rest

import com.mydeck.app.coroutine.ApplicationScope
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import okhttp3.Interceptor
import okhttp3.Request
import okhttp3.Response
import timber.log.Timber
import java.io.IOException
import javax.inject.Inject

class UrlInterceptor @Inject constructor(
    private val settingsDataStore: SettingsDataStore
) : Interceptor {

    override fun intercept(chain: Interceptor.Chain): Response {
        val request: Request = chain.request()
        val originalUrl = request.url.toString()

        // Retrieve the baseUrl synchronously
        val baseUrl = runBlocking { settingsDataStore.urlFlow.first() }

        if (baseUrl.isNullOrEmpty()) {
            throw IOException("baseUrl is not set")
        } else {
            // Modify the request's URL to use the current baseUrl
            val newUrl = originalUrl.replace(
                "http://readeck.invalid",
                baseUrl
            )
            val newRequest: Request = request.newBuilder()
                .url(newUrl)
                .build()

            return chain.proceed(newRequest)
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/AssetLoader.kt">
package com.mydeck.app.io

import android.content.Context
import dagger.hilt.android.qualifiers.ApplicationContext
import timber.log.Timber
import java.io.IOException
import javax.inject.Inject

interface AssetLoader {
    fun loadAsset(fileName: String): String?
}

class AssetLoaderImpl @Inject constructor(@ApplicationContext private val context: Context) : AssetLoader {
    override fun loadAsset(fileName: String): String? {
        return try {
            context.assets.open(fileName).bufferedReader().use { it.readText() }
        } catch (e: IOException) {
            Timber.e(e, "Error loading asset: $fileName")
            null
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/about/AboutViewModel.kt">
package com.mydeck.app.ui.about

import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import javax.inject.Inject

@HiltViewModel
class AboutViewModel @Inject constructor() : ViewModel() {

    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()

    fun onClickBack() {
        _navigationEvent.value = NavigationEvent.NavigateBack
    }

    fun onClickOpenSourceLibraries() {
        _navigationEvent.value = NavigationEvent.NavigateToOpenSourceLibraries
    }

    fun onNavigationEventConsumed() {
        _navigationEvent.value = null
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
        data object NavigateToOpenSourceLibraries : NavigationEvent()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/components/ShareBookmarkChooser.kt">
package com.mydeck.app.ui.components

import androidx.compose.runtime.Composable
import android.content.Intent
import android.content.Context

@Composable
fun ShareBookmarkChooser(
    context: Context,
    intent: Intent?,
    onShareIntentConsumed: () -> Unit
){
    if (intent != null) {
        val chooser = Intent.createChooser(intent, null)
        context.startActivity(chooser)
        onShareIntentConsumed.invoke()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/components/VerticalScrollbar.kt">
package com.mydeck.app.ui.components

import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.BiasAlignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.delay

@Composable
fun VerticalScrollbar(
    modifier: Modifier = Modifier,
    scrollState: ScrollState,
    width: Dp = 4.dp,
    color: Color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
    padding: Dp = 4.dp
) {
    var isVisible by remember { mutableStateOf(false) }
    
    // Auto-hide logic
    LaunchedEffect(scrollState.isScrollInProgress, scrollState.value) {
        if (scrollState.isScrollInProgress) {
            isVisible = true
        } else {
            // Wait for 1 second after scroll stops before hiding
            delay(1000)
            isVisible = false
        }
    }

    val alpha by animateFloatAsState(
        targetValue = if (isVisible) 1f else 0f,
        animationSpec = tween(durationMillis = 300),
        label = "ScrollbarAlpha"
    )

    if (scrollState.maxValue > 0) {
        // Calculate scrollbar size and position
        // Viewport size calculation is approximate as we don't have direct access to viewport height here easily 
        // without BoxWithConstraints or LayoutCoordinates. 
        // However, a common scrollbar pattern is to represent the proportion of "visible" area.
        // Since we are overlaying this on the content, we can use a simpler approach:
        // Just show a knob moving proportionally?
        // Or a bar that shrinks as content grows?
        // Native android scrollbars changes size.
        // But for "Reading Progress Bar", often a fixed "thumb" or just simple proportional thumb is enough.
        
        // Let's implement a proportional thumb. 
        // Position relative to container height.
        // We assume 'modifier' has fillMaxHeight() on the container Box.
        
        Box(
            modifier = modifier
                .alpha(alpha)
                .fillMaxHeight()
                .padding(end = padding)
        ) {
            // We need to know the height of this track (the viewport height).
            // But in a simple Box overlay, we can use BiasAlignment or just percentage offset.
             
            // Fraction of content scrolled:
            val scrollValue = scrollState.value.toFloat()
            val maxScroll = scrollState.maxValue.toFloat()
            // Total content height = viewport + maxScroll
            // Ideally we need viewport height. 
            // scrollState doesn't expose viewport height directly. 
            // BUT: maxScroll = contentHeight - viewportHeight.
            // So contentHeight = maxScroll + viewportHeight.
            // Thumb height / Viewport Height = Viewport Height / Content Height
            // This requires Viewport Height.
            
            // SIMPLIFICATION:
            // Since accessing viewport height needs `BoxWithConstraints`, let's just 
            // place the thumb purely based on scroll percentage [0, 1] mapped to alignment [-1, 1].
            // This won't change thumb size but will indicate position correctly.
            // OR we use a fixed small thumb.
            
            // Let's use a fixed-width bar that aligns vertically based on progress.
            // Using `BiasAlignment` is easiest for positioning.
            // -1f is top, 1f is bottom.
            
            val progress = if (maxScroll > 0) scrollValue / maxScroll else 0f
            val alignBias = (progress * 2) - 1f // Map [0, 1] to [-1, 1]
            
            Box(
                modifier = Modifier
                    .align(BiasAlignment(0f, alignBias))
                    .width(width)
                    // Static height for the thumb for now, or we could try to make it proportional if requested later.
                    // A fixed small thumb (e.g. 48dp) is often cleaner for very long content than a 1px proportional one.
                    .fillMaxHeight(0.1f) // 10% of screen height as thumb? Or fixed dp?
                    // Let's stick to fixed dp for consistent visibility.
                    // But 10% is nicer for "how much is left".
                    // Let's use a dynamic height clamped.
                    .clip(RoundedCornerShape(width))
                    .background(color)
            )
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/AutoSyncTimeframeDialog.kt">
package com.mydeck.app.ui.settings

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.sizeIn
import androidx.compose.foundation.selection.selectable
import androidx.compose.material3.Card
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.mydeck.app.R
import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.ui.theme.Typography

@Composable
fun AutoSyncTimeframeDialog(
    autoSyncTimeframeOptions: List<AutoSyncTimeframeOption>,
    onDismissRequest: () -> Unit,
    onElementSelected: (selected: AutoSyncTimeframe) -> Unit,
) {
    Dialog(
        onDismissRequest = onDismissRequest
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .sizeIn(
                    minWidth = 280.dp,
                    maxWidth = 560.dp
                ),
            shape = androidx.compose.foundation.shape.RoundedCornerShape(28.dp),
        ) {
            Column(
                modifier = Modifier.padding(24.dp)
            ) {
                Text(
                    text = stringResource(R.string.settings_sync_dialog_support_text),
                    style = Typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                HorizontalDivider()
                autoSyncTimeframeOptions.forEach { option ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(56.dp)
                            .selectable(
                                selected = option.selected,
                                onClick = { onElementSelected(option.autoSyncTimeframe) },
                                role = Role.RadioButton
                            ),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = option.selected,
                            onClick = null
                        )
                        Text(
                            text = stringResource(option.label),
                            modifier = Modifier.padding(start = 16.dp)
                        )
                    }
                }
                HorizontalDivider()
                Row(
                    horizontalArrangement = Arrangement.End,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    TextButton(
                        modifier = Modifier.padding(top = 24.dp),
                        onClick = onDismissRequest
                    ) {
                        Text(text = stringResource(R.string.ok))
                    }
                }
            }
        }
    }
}

@Preview
@Composable
fun AutoSyncTimeframeDialogPreview() {
    AutoSyncTimeframeDialog(
        autoSyncTimeframeOptions = listOf(
            AutoSyncTimeframeOption(
                autoSyncTimeframe = AutoSyncTimeframe.MANUAL,
                label = R.string.auto_sync_timeframe_manual,
                selected = true
            ),
            AutoSyncTimeframeOption(
                autoSyncTimeframe = AutoSyncTimeframe.HOURS_06,
                label = R.string.auto_sync_timeframe_06_hours,
                selected = false
            )
        ),
        onDismissRequest = {},
        onElementSelected = {}
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/LogViewScreen.kt">
package com.mydeck.app.ui.settings

import android.content.Intent
import android.net.Uri
import android.widget.Toast
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Share
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import com.mydeck.app.R
import kotlinx.coroutines.launch
import timber.log.Timber

@Composable
fun LogViewScreen(navController: NavHostController) {
    val viewModel: LogViewViewModel = androidx.hilt.navigation.compose.hiltViewModel()
    val uiState = viewModel.uiState.collectAsState()
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    val shareTitleText = stringResource(R.string.log_view_share_title)
    val shareErrorText = stringResource(R.string.log_view_no_log_file_found)
    val logsClearedText = stringResource(R.string.log_view_logs_cleared)

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                LogViewViewModel.NavigationEvent.NavigateBack -> {
                    navController.popBackStack()
                }

                LogViewViewModel.NavigationEvent.ShowShareDialog -> {
                    if (uiState.value is LogViewViewModel.UiState.Success) {
                        val uri = (uiState.value as LogViewViewModel.UiState.Success).shareIntentUri
                        val shareIntent = Intent(Intent.ACTION_SEND).apply {
                            type = "text/plain"
                            putExtra(Intent.EXTRA_STREAM, uri)
                            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        }

                        val chooserIntent = Intent.createChooser(shareIntent, shareTitleText)
                        context.startActivity(chooserIntent)

                    } else {
                        scope.launch {
                            Toast.makeText(context, shareErrorText, Toast.LENGTH_SHORT).show()
                        }
                    }
                }

                LogViewViewModel.NavigationEvent.LogsCleared -> {
                    scope.launch {
                        Toast.makeText(context, logsClearedText, Toast.LENGTH_SHORT).show()
                    }
                }
            }
            viewModel.onNavigationEventConsumed()
        }
    }

    LogViewScreenView(
        uiState = uiState.value,
        onClickBack = { viewModel.onClickBack() },
        onShareLogs = { viewModel.onShareLogs() },
        onRefresh = { viewModel.onRefresh() },
        onClearLogs = { viewModel.onClearLogs() }
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LogViewScreenView(
    uiState: LogViewViewModel.UiState,
    onClickBack: () -> Unit,
    onShareLogs: () -> Unit,
    onRefresh: () -> Unit,
    onClearLogs: () -> Unit
) {
    val scrollState = rememberScrollState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(stringResource(id = R.string.log_view_title)) },
                navigationIcon = {
                    IconButton(onClick = onClickBack) {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(id = R.string.back)
                        )
                    }
                },
                actions = {
                    IconButton(onClick = onShareLogs) {
                        Icon(
                            imageVector = Icons.Filled.Share,
                            contentDescription = stringResource(id = R.string.log_view_send_logs)
                        )
                    }
                    IconButton(onClick = onRefresh) {
                        Icon(
                            imageVector = Icons.Filled.Refresh,
                            contentDescription = stringResource(id = R.string.log_view_refresh)
                        )
                    }
                    IconButton(onClick = onClearLogs) {
                        Icon(
                            imageVector = Icons.Filled.Delete,
                            contentDescription = stringResource(id = R.string.log_view_clear_logs)
                        )
                    }
                }
            )
        }
    ) { paddingValues ->

        when (uiState) {
            is LogViewViewModel.UiState.Success -> {
                Column(
                    modifier = Modifier
                        .padding(paddingValues)
                        .padding(16.dp)
                        .verticalScroll(scrollState)
                ) {
                    Text(text = uiState.logContent)
                }
            }

            is LogViewViewModel.UiState.Error -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(stringResource(uiState.message))
                }
            }

            is LogViewViewModel.UiState.Loading -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
        }
    }
}

@androidx.compose.ui.tooling.preview.Preview(showBackground = true)
@Composable
fun LogViewScreenPreview() {
    LogViewScreenView(
        uiState = LogViewViewModel.UiState.Success(
            logContent = "This is a test log\n".repeat(100),
            shareIntentUri = Uri.EMPTY
        ),
        onClickBack = {},
        onShareLogs = {},
        onRefresh = {},
        onClearLogs = {}
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/LogViewViewModel.kt">
package com.mydeck.app.ui.settings

import android.content.Context
import android.net.Uri
import androidx.annotation.StringRes
import androidx.core.content.FileProvider
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import com.mydeck.app.R
import com.mydeck.app.util.clearLogFiles
import com.mydeck.app.util.getLatestLogFile
import com.mydeck.app.util.logAppInfo
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@HiltViewModel
class LogViewViewModel @Inject constructor(
    @ApplicationContext private val context: Context
) : ViewModel() {

    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()
    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)
    val uiState = _uiState.asStateFlow()

    init {
        onRefresh()
    }

    fun onClickBack() {
        _navigationEvent.update { NavigationEvent.NavigateBack }
    }

    fun onRefresh() {
        Timber.d("refresh")
        viewModelScope.launch {
            _uiState.value = getLatestLogFile()?.let {
                Timber.d("file=$it")
                UiState.Success(
                    logContent = it.readText(),
                    shareIntentUri = FileProvider.getUriForFile(
                            context,
                            "${context.packageName}.provider",
                            it
                        )
                )
            }  ?: UiState.Error(R.string.log_view_no_log_file_found)
        }
    }

    fun onShareLogs() {
        logAppInfo()
        _navigationEvent.update { NavigationEvent.ShowShareDialog }
    }

    fun onClearLogs() {
        viewModelScope.launch {
            clearLogFiles()
            onRefresh()
            _navigationEvent.update { NavigationEvent.LogsCleared }
        }
    }

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null }
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
        data object ShowShareDialog : NavigationEvent()
        data object LogsCleared : NavigationEvent()
    }

    sealed class UiState {
        data object Loading : UiState()
        data class Success(
            val logContent: String,
            val shareIntentUri: Uri
        ) : UiState()
        data class Error(@StringRes val message: Int) : UiState()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/NotificationRationaleDialog.kt">
package com.mydeck.app.ui.settings

import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.res.stringResource
import com.mydeck.app.R

@Composable
fun NotificationRationaleDialog(
    onRationaleDialogConfirm: () -> Unit,
    onRationaleDialogDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onRationaleDialogDismiss,
        title = { Text(stringResource(R.string.auto_sync_notification_rationale_dialog_title)) },
        text = { Text(stringResource(R.string.auto_sync_notification_rationale_dialog_text)) },
        confirmButton = {
            Button(onClick = onRationaleDialogConfirm) {
                Text(stringResource(R.string.auto_sync_notification_rationale_dialog_grant_button))
            }
        },
        dismissButton = {
            Button(onClick = onRationaleDialogDismiss) {
                Text(stringResource(R.string.cancel))
            }
        }
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/OpenSourceLibrariesScreen.kt">
package com.mydeck.app.ui.settings

import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.mikepenz.aboutlibraries.ui.compose.m3.LibrariesContainer
import com.mydeck.app.R

@Composable
fun OpenSourceLibrariesScreen(navHostController: NavHostController) {
    val viewModel: OpenSourceLibrariesViewModel = hiltViewModel()
    val navigationEvent = viewModel.navigationEvent.collectAsState()

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                OpenSourceLibrariesViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
            }
            viewModel.onNavigationEventConsumed()
        }
    }

    OpenSourceLibrariesScreenContent(onBackClick = { viewModel.onClickBack() })
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OpenSourceLibrariesScreenContent(onBackClick: () -> Unit) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(stringResource(R.string.settings_open_source_libraries)) },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.back))
                    }
                }
            )
        }
    ) { padding ->
        LibrariesContainer(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        )
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/OpenSourceLibrariesViewModel.kt">
package com.mydeck.app.ui.settings

import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import javax.inject.Inject

@HiltViewModel
class OpenSourceLibrariesViewModel @Inject constructor() : ViewModel() {

    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()

    fun onClickBack() {
        _navigationEvent.update { NavigationEvent.NavigateBack }
    }

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null }
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/SettingsScreen.kt">
package com.mydeck.app.ui.settings

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.AccountCircle
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.List
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Sync
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.mydeck.app.R
import com.mydeck.app.ui.navigation.AccountSettingsRoute
import com.mydeck.app.ui.navigation.LogViewRoute
import com.mydeck.app.ui.navigation.OpenSourceLibrariesRoute
import com.mydeck.app.ui.navigation.SyncSettingsRoute
import com.mydeck.app.ui.navigation.UiSettingsRoute

@Composable
fun SettingsScreen(
    navHostController: NavHostController
) {
    val viewModel: SettingsViewModel = hiltViewModel()
    val settingsUiState = viewModel.uiState.collectAsState().value
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val onClickAccount: () -> Unit = { viewModel.onClickAccount() }
    val onClickBack: () -> Unit = { viewModel.onClickBack() }
    val onClickOpenSourceLibraries: () -> Unit = { viewModel.onClickOpenSourceLibraries() }
    val onClickLogs: () -> Unit = { viewModel.onClickLogs() }
    val onClickSync: () -> Unit = { viewModel.onClickSync() }
    val onClickUi: () -> Unit = { viewModel.onClickView() }
    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                is SettingsViewModel.NavigationEvent.NavigateToAccountSettings -> {
                    navHostController.navigate(AccountSettingsRoute)
                }
                is SettingsViewModel.NavigationEvent.NavigateToOpenSourceLibraries -> {
                    navHostController.navigate(OpenSourceLibrariesRoute)
                }
                is SettingsViewModel.NavigationEvent.NavigateToLogView -> {
                    navHostController.navigate(LogViewRoute)
                }
                is SettingsViewModel.NavigationEvent.NavigateToSyncView -> {
                    navHostController.navigate(SyncSettingsRoute)
                }
                is SettingsViewModel.NavigationEvent.NavigateToUiSettings -> {
                    navHostController.navigate(UiSettingsRoute)
                }
                is SettingsViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
            }
            viewModel.onNavigationEventConsumed() // Consume the event
        }
    }
    SettingScreenView(
        settingsUiState = settingsUiState,
        onClickAccount = onClickAccount,
        onClickBack = onClickBack,
        onClickOpenSourceLibraries = onClickOpenSourceLibraries,
        onClickLogs = onClickLogs,
        onClickSync = onClickSync,
        onClickUi = onClickUi
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingScreenView(
    settingsUiState: SettingsUiState,
    onClickAccount: () -> Unit,
    onClickBack: () -> Unit,
    onClickOpenSourceLibraries: () -> Unit,
    onClickLogs: () -> Unit,
    onClickSync: () -> Unit,
    onClickUi: () -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                modifier = Modifier.testTag(SettingsScreenTestTags.TOPBAR),
                title = { Text(stringResource(R.string.settings_topbar_title)) },
                navigationIcon = {
                    IconButton(
                        onClick = onClickBack,
                        modifier = Modifier.testTag(SettingsScreenTestTags.BACK_BUTTON)
                    ) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .padding(16.dp)
        ) {
            SettingItem(
                icon = Icons.Filled.AccountCircle,
                title = stringResource(R.string.settings_account_title),
                subtitle = settingsUiState.username
                    ?: stringResource(R.string.settings_account_subtitle_default),
                onClick = onClickAccount,
                testTag = SettingsScreenTestTags.SETTINGS_ITEM_ACCOUNT
            )


            SettingItem(
                icon = Icons.Filled.Sync,
                title = stringResource(R.string.settings_sync),
                subtitle = stringResource(R.string.settings_sync_subtitle),
                onClick = onClickSync,
                testTag = SettingsScreenTestTags.SETTINGS_ITEM_SYNC
            )

            SettingItem(
                icon = Icons.Filled.Visibility,
                title = stringResource(R.string.settings_ui),
                subtitle = stringResource(R.string.settings_ui_subtitle),
                onClick = onClickUi,
                testTag = SettingsScreenTestTags.SETTINGS_ITEM_UI
            )
            SettingItem(
                icon = Icons.Filled.Info,
                title = stringResource(R.string.settings_logs),
                subtitle = stringResource(R.string.settings_logs_subtitle),
                onClick = onClickLogs,
                testTag = SettingsScreenTestTags.SETTINGS_ITEM_LOGS
            )
        }
    }
}

@Composable
fun SettingItem(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    title: String,
    subtitle: String,
    onClick: () -> Unit,
    testTag: String
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp)
            .clickable { onClick() }
            .testTag("${SettingsScreenTestTags.SETTINGS_ITEM}.$testTag"),
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Icon(icon, contentDescription = title, modifier = Modifier.padding(end = 16.dp))
        Column {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.testTag("${SettingsScreenTestTags.SETTINGS_ITEM_TITLE}.$testTag")
            )
            Text(
                text = subtitle,
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.testTag("${SettingsScreenTestTags.SETTINGS_ITEM_SUBTITLE}.$testTag")
            )
        }
    }
}

@Preview(showBackground = true)
@Composable
fun SettingScreenViewPreview() {
    SettingScreenView(
        settingsUiState = SettingsUiState(
            username = "test",
        ),
        onClickAccount = {},
        onClickBack = {},
        onClickOpenSourceLibraries = {},
        onClickLogs = {},
        onClickSync = {},
        onClickUi = {}
    )
}

@Preview(showBackground = true)
@Composable
fun SettingItemPreview() {
    SettingItem(
        icon = Icons.Filled.Lock,
        title = "test",
        subtitle = "test1",
        onClick = {},
        testTag = "account"
    )
}

object SettingsScreenTestTags {
    const val BACK_BUTTON = "SettingsScreenTestTags.BackButton"
    const val TOPBAR = "SettingsScreenTestTags.TopBar"
    const val SETTINGS_ITEM = "SettingsScreenTestTags.SettingsItem"
    const val SETTINGS_ITEM_TITLE = "SettingsScreenTestTags.SettingsItem.Title"
    const val SETTINGS_ITEM_SUBTITLE = "SettingsScreenTestTags.SettingsItem.Subtitle"
    const val SETTINGS_ITEM_ACCOUNT = "Account"
    const val SETTINGS_ITEM_OPEN_SOURCE = "OpenSource"
    const val SETTINGS_ITEM_LOGS = "Logs"
    const val SETTINGS_ITEM_SYNC = "Sync"
    const val SETTINGS_ITEM_UI = "Ui"
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/SettingsViewModel.kt">
package com.mydeck.app.ui.settings

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import com.mydeck.app.domain.UserRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import javax.inject.Inject

@HiltViewModel
class SettingsViewModel @Inject constructor(
    userRepository: UserRepository
) : ViewModel() {
    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()
    val uiState: StateFlow<SettingsUiState> = userRepository.observeAuthenticationDetails().map { SettingsUiState(username = it?.username) }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5000),
        SettingsUiState(username = null)
    )

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null } // Reset the event
    }

    fun onClickAccount() {
        _navigationEvent.update { NavigationEvent.NavigateToAccountSettings }
    }

    fun onClickBack() {
        _navigationEvent.update { NavigationEvent.NavigateBack }
    }

    fun onClickOpenSourceLibraries() {
        _navigationEvent.update { NavigationEvent.NavigateToOpenSourceLibraries }
    }

    fun onClickLogs() {
        _navigationEvent.update { NavigationEvent.NavigateToLogView }
    }

    fun onClickSync() {
        _navigationEvent.update { NavigationEvent.NavigateToSyncView }
    }

    fun onClickView() {
        _navigationEvent.update { NavigationEvent.NavigateToUiSettings }
    }

    sealed class NavigationEvent {
        data object NavigateToAccountSettings : NavigationEvent()
        data object NavigateToOpenSourceLibraries : NavigationEvent()
        data object NavigateBack : NavigationEvent()
        data object NavigateToLogView : NavigationEvent()
        data object NavigateToSyncView : NavigationEvent()
        data object NavigateToUiSettings : NavigationEvent()
    }

}

data class SettingsUiState(
    val username: String?,
)
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/ThemeDialog.kt">
package com.mydeck.app.ui.settings

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.sizeIn
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Card
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.mydeck.app.R
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.ui.theme.Typography

@Composable
fun ThemeDialog(
    themeOptions: List<ThemeOption>,
    onDismissRequest: () -> Unit,
    onElementSelected: (selected: Theme) -> Unit,
) {
    Dialog(
        onDismissRequest = onDismissRequest
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .sizeIn(
                    minWidth = 280.dp,
                    maxWidth = 560.dp
                ),
            shape = RoundedCornerShape(28.dp),
        ) {
            Column(
                modifier = Modifier.padding(24.dp)
            ) {
                Text(
                    text = stringResource(R.string.ui_settings_theme_dialog_support_text),
                    style = Typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                HorizontalDivider()
                themeOptions.forEach { option ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(56.dp)
                            .selectable(
                                selected = option.selected,
                                onClick = { onElementSelected(option.theme) },
                                role = Role.RadioButton
                            ),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = option.selected,
                            onClick = null
                        )
                        Text(
                            text = stringResource(option.label),
                            modifier = Modifier.padding(start = 16.dp)
                        )
                    }
                }
                HorizontalDivider()
                Row(
                    horizontalArrangement = Arrangement.End,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    TextButton(
                        modifier = Modifier.padding(top = 24.dp),
                        onClick = onDismissRequest
                    ) {
                        Text(text = stringResource(R.string.ok))
                    }
                }
            }
        }
    }
}

@Preview
@Composable
fun ThemeDialogPreview() {
    ThemeDialog(
        themeOptions = listOf(
            ThemeOption(
                theme = Theme.SYSTEM,
                label = R.string.theme_system,
                selected = true
            ),
            ThemeOption(
                theme = Theme.LIGHT,
                label = R.string.theme_light,
                selected = false
            ),
            ThemeOption(
                theme = Theme.DARK,
                label = R.string.theme_dark,
                selected = false
            ),
        ),
        onDismissRequest = {},
        onElementSelected = {}
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/UiSettingsScreen.kt">
package com.mydeck.app.ui.settings

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.mydeck.app.R
import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.ui.theme.Typography

@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun UiSettingsScreen(
    navHostController: NavHostController
) {
    val viewModel: UiSettingsViewModel = hiltViewModel()
    val settingsUiState = viewModel.uiState.collectAsState().value
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val onClickBack: () -> Unit = { viewModel.onClickBack() }
    val onClickTheme: () -> Unit = { viewModel.onClickTheme() }
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                is UiSettingsViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
            }
            viewModel.onNavigationEventConsumed() // Consume the event
        }
    }

    if (settingsUiState.showDialog) {
        ThemeDialog(
            themeOptions = settingsUiState.themeOptions,
            onDismissRequest = { viewModel.onDismissDialog() },
            onElementSelected = { viewModel.onThemeSelected(it) }
        )
    }

    UiSettingsView(
        modifier = Modifier,
        snackbarHostState = snackbarHostState,
        onClickBack = onClickBack,
        onClickTheme = onClickTheme,
        settingsUiState = settingsUiState
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun UiSettingsView(
    modifier: Modifier = Modifier,
    snackbarHostState: SnackbarHostState,
    settingsUiState: UiSettingsUiState,
    onClickTheme: () -> Unit,
    onClickBack: () -> Unit,
) {
    Scaffold(
        modifier = modifier,
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text(stringResource(R.string.ui_settings_topbar_title)) },
                navigationIcon = {
                    IconButton(
                        onClick = onClickBack,
                        modifier = Modifier.testTag(UiSettingsScreenTestTags.BACK_BUTTON)
                    ) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .padding(16.dp)
                .fillMaxSize(),
            horizontalAlignment = Alignment.Start,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.clickable(enabled = true, onClick = onClickTheme)
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(stringResource(R.string.ui_settings_theme_title))
                    Text(
                        text = stringResource(settingsUiState.themeLabel),
                        style = Typography.bodySmall
                    )
                }
            }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun UiSettingsScreenViewPreview() {
    val settingsUiState = UiSettingsUiState(
        theme = Theme.SYSTEM,
        themeOptions = listOf(),
        showDialog = false,
        themeLabel = Theme.SYSTEM.toLabelResource(),
    )
    UiSettingsView(
        modifier = Modifier,
        snackbarHostState = SnackbarHostState(),
        onClickBack = {},
        onClickTheme = {},
        settingsUiState = settingsUiState
    )
}

object UiSettingsScreenTestTags {
    const val BACK_BUTTON = "AccountSettingsScreenTestTags.BackButton"
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/UiSettingsViewModel.kt">
package com.mydeck.app.ui.settings

import android.content.Context
import androidx.annotation.StringRes
import androidx.compose.runtime.Immutable
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import com.mydeck.app.R
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@OptIn(ExperimentalPermissionsApi::class)
@HiltViewModel
class UiSettingsViewModel @Inject constructor(
    private val settingsDataStore: SettingsDataStore,
    @ApplicationContext private val context: Context,
) : ViewModel() {
    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()
    private val theme = MutableStateFlow(Theme.SYSTEM)
    private val showDialog = MutableStateFlow(false)

    init {
        viewModelScope.launch {
            theme.value = settingsDataStore.getTheme()
        }
    }


    val uiState = combine(theme, showDialog) { theme, showDialog ->
        UiSettingsUiState(
            theme = theme,
            themeOptions = getThemeOptionList(theme),
            showDialog = showDialog,
            themeLabel = theme.toLabelResource(),
        )
    }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue =
                UiSettingsUiState(
                    theme = Theme.SYSTEM,
                    themeOptions = getThemeOptionList(Theme.SYSTEM),
                    showDialog = false,
                    themeLabel = Theme.SYSTEM.toLabelResource(),
                )
        )

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null } // Reset the event
    }

    fun onClickTheme() {
        showDialog.value = true
    }

    fun onDismissDialog() {
        showDialog.value = false
    }

    fun onThemeSelected(selected: Theme) {
        Timber.d("onThemeSyncTimeframeSelected [selected=$selected]")
        updateTheme(selected)
    }

    fun onClickBack() {
        _navigationEvent.update { NavigationEvent.NavigateBack }
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
    }

    private fun getThemeOptionList(selected: Theme): List<ThemeOption> {
        return Theme.entries.map {
            ThemeOption(
                theme = it,
                label = it.toLabelResource(),
                selected = it == selected
            )
        }
    }

    private fun updateTheme(value: Theme) {
        viewModelScope.launch {
            settingsDataStore.saveTheme(value)
            theme.value = settingsDataStore.getTheme()
        }
    }
}

@Immutable
data class UiSettingsUiState(
    val theme: Theme,
    val themeOptions: List<ThemeOption>,
    val showDialog: Boolean,
    @StringRes
    val themeLabel: Int,
)

data class ThemeOption(
    val theme: Theme,
    @StringRes
    val label: Int,
    val selected: Boolean
)

@StringRes
fun Theme.toLabelResource(): Int {
    return when (this) {
        Theme.LIGHT -> R.string.theme_light
        Theme.DARK -> R.string.theme_dark
        Theme.SEPIA -> R.string.theme_sepia
        Theme.SYSTEM -> R.string.theme_system
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/theme/sepia/Color.kt">
package com.mydeck.app.ui.theme.sepia
import androidx.compose.ui.graphics.Color

// Colors created using https://material-foundation.github.io/material-theme-builder/

val primaryLight = Color(0xFF552C00)
val onPrimaryLight = Color(0xFFFFFFFF)
val primaryContainerLight = Color(0xFF704214)
val onPrimaryContainerLight = Color(0xFFF1B179)
val secondaryLight = Color(0xFF552C00)
val onSecondaryLight = Color(0xFFFFFFFF)
val secondaryContainerLight = Color(0xFF704214)
val onSecondaryContainerLight = Color(0xFFF1B179)
val tertiaryLight = Color(0xFF552C00)
val onTertiaryLight = Color(0xFFFFFFFF)
val tertiaryContainerLight = Color(0xFF704214)
val onTertiaryContainerLight = Color(0xFFF1B179)
val errorLight = Color(0xFFBA1A1A)
val onErrorLight = Color(0xFFFFFFFF)
val errorContainerLight = Color(0xFFFFDAD6)
val onErrorContainerLight = Color(0xFF93000A)
val backgroundLight = Color(0xFFF4ECD8)
val onBackgroundLight = Color(0xFF201B17)
val surfaceLight = Color(0xFFF5E8C8)
val onSurfaceLight = Color(0xFF1C1B1A)
val surfaceVariantLight = Color(0xFFF3DFD1)
val onSurfaceVariantLight = Color(0xFF51443A)
val outlineLight = Color(0xFF847469)
val outlineVariantLight = Color(0xFFD6C3B6)
val scrimLight = Color(0xFF000000)
val inverseSurfaceLight = Color(0xFF31302F)
val inverseOnSurfaceLight = Color(0xFFF4F0ED)
val inversePrimaryLight = Color(0xFFFBB980)
val surfaceDimLight = Color(0xFFDDD9D7)
val surfaceBrightLight = Color(0xFFFDF8F6)
val surfaceContainerLowestLight = Color(0xFFFFFFFF)
val surfaceContainerLowLight = Color(0xFFF7F3F0)
val surfaceContainerLight = Color(0xFFF1EDEA)
val surfaceContainerHighLight = Color(0xFFECE7E5)
val surfaceContainerHighestLight = Color(0xFFE6E2DF)
</file>

<file path="app/src/main/java/com/mydeck/app/ui/theme/sepia/Theme.kt">
package com.mydeck.app.ui.theme.sepia
import androidx.compose.material3.lightColorScheme

val SepiaColorScheme = lightColorScheme(
    primary = primaryLight,
    onPrimary = onPrimaryLight,
    primaryContainer = primaryContainerLight,
    onPrimaryContainer = onPrimaryContainerLight,
    secondary = secondaryLight,
    onSecondary = onSecondaryLight,
    secondaryContainer = secondaryContainerLight,
    onSecondaryContainer = onSecondaryContainerLight,
    tertiary = tertiaryLight,
    onTertiary = onTertiaryLight,
    tertiaryContainer = tertiaryContainerLight,
    onTertiaryContainer = onTertiaryContainerLight,
    error = errorLight,
    onError = onErrorLight,
    errorContainer = errorContainerLight,
    onErrorContainer = onErrorContainerLight,
    background = backgroundLight,
    onBackground = onBackgroundLight,
    surface = surfaceLight,
    onSurface = onSurfaceLight,
    surfaceVariant = surfaceVariantLight,
    onSurfaceVariant = onSurfaceVariantLight,
    outline = outlineLight,
    outlineVariant = outlineVariantLight,
    scrim = scrimLight,
    inverseSurface = inverseSurfaceLight,
    inverseOnSurface = inverseOnSurfaceLight,
    inversePrimary = inversePrimaryLight,
    surfaceDim = surfaceDimLight,
    surfaceBright = surfaceBrightLight,
    surfaceContainerLowest = surfaceContainerLowestLight,
    surfaceContainerLow = surfaceContainerLowLight,
    surfaceContainer = surfaceContainerLight,
    surfaceContainerHigh = surfaceContainerHighLight,
    surfaceContainerHighest = surfaceContainerHighestLight,
)
</file>

<file path="app/src/main/java/com/mydeck/app/ui/theme/Color.kt">
package com.mydeck.app.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
</file>

<file path="app/src/main/java/com/mydeck/app/ui/theme/Theme.kt">
package com.mydeck.app.ui.theme

import android.os.Build
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.ui.theme.sepia.SepiaColorScheme

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun MyDeckTheme(
    theme: Theme = Theme.LIGHT,
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S && theme in listOf(
            Theme.DARK,
            Theme.LIGHT
        ) -> {
            val context = LocalContext.current
            if (theme == Theme.DARK) dynamicDarkColorScheme(context)
            else dynamicLightColorScheme(context)
        }
        theme == Theme.DARK -> DarkColorScheme
        theme == Theme.SEPIA -> SepiaColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/theme/Type.kt">
package com.mydeck.app.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)
</file>

<file path="app/src/main/java/com/mydeck/app/util/SearchOperators.kt">
package com.mydeck.app.util

data class ParsedSearchQuery(
    val textQuery: String
)

fun parseSearchQuery(query: String): ParsedSearchQuery {
    return ParsedSearchQuery(textQuery = query.trim())
}
</file>

<file path="app/src/main/java/com/mydeck/app/worker/CustomWorkManagerInitializer.kt">
package com.mydeck.app.worker

import android.content.Context
import androidx.hilt.work.HiltWorkerFactory
import androidx.startup.Initializer
import androidx.work.Configuration
import androidx.work.WorkManager
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent

class CustomWorkManagerInitializer : Initializer<WorkManager> {

    override fun create(context: Context): WorkManager {
        val workerFactory = getWorkerFactory(appContext = context.applicationContext)
        val config = Configuration.Builder()
            .setWorkerFactory(workerFactory)
            .build()
        WorkManager.initialize(context, config)
        return WorkManager.getInstance(context)
    }

    override fun dependencies(): MutableList<Class<out Initializer<*>>> = mutableListOf()

    private fun getWorkerFactory(appContext: Context): HiltWorkerFactory {
        val workManagerEntryPoint = EntryPointAccessors.fromApplication(
            appContext,
            WorkManagerInitializerEntryPoint::class.java
        )
        return workManagerEntryPoint.hiltWorkerFactory()
    }

    @InstallIn(SingletonComponent::class)
    @EntryPoint
    interface WorkManagerInitializerEntryPoint {
        fun hiltWorkerFactory(): HiltWorkerFactory
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/worker/FullSyncWorker.kt">
package com.mydeck.app.worker

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat.getSystemService
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import com.mydeck.app.MainActivity
import com.mydeck.app.R
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.BookmarkRepository.SyncResult
import com.mydeck.app.domain.usecase.LoadBookmarksUseCase
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.datetime.Clock
import timber.log.Timber
import kotlin.time.Duration.Companion.hours

@HiltWorker
class FullSyncWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted val workerParams: WorkerParameters,
    val bookmarkRepository: BookmarkRepository,
    val settingsDataStore: SettingsDataStore,
    val loadBookmarksUseCase: LoadBookmarksUseCase,
) : CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result {
        try {
            Timber.d("Start Work")
            val lastSyncTimestamp = settingsDataStore.getLastSyncTimestamp()
            val lastFullSyncTimestamp = settingsDataStore.getLastFullSyncTimestamp()

            // Step 1: Determine if we need a full sync for deletion detection
            val needsFullSync = lastFullSyncTimestamp == null ||
                Clock.System.now() - lastFullSyncTimestamp > FULL_SYNC_INTERVAL

            var syncResult = if (needsFullSync) {
                Timber.d("Performing full sync for deletion detection")
                val result = bookmarkRepository.performFullSync()
                if (result is SyncResult.Success) {
                    settingsDataStore.saveLastFullSyncTimestamp(Clock.System.now())
                }
                result
            } else {
                // Skip deletion detection - we did a full sync recently
                Timber.d("Skipping deletion check (last full sync was recent)")
                SyncResult.Success(countDeleted = 0)
            }

            // Check if deletion sync failed
            when (syncResult) {
                is SyncResult.Error -> {
                    showNotification(syncResult)
                    return Result.failure()
                }
                is SyncResult.NetworkError -> {
                    showNotification(syncResult)
                    return Result.retry()
                }
                is SyncResult.Success -> {
                    Timber.d("Deletion sync successful: ${syncResult.countDeleted} deleted")
                }
            }

            // Step 2: Fetch updated/new bookmarks (this also triggers article content loading)
            Timber.d("Fetching updated bookmarks")
            val loadResult = loadBookmarksUseCase.execute()

            val workResult = when (loadResult) {
                is LoadBookmarksUseCase.UseCaseResult.Error -> {
                    Timber.e(loadResult.exception, "Failed to load updated bookmarks")
                    showNotification(SyncResult.Error("Failed to load bookmarks", ex = loadResult.exception as? Exception))
                    Result.failure()
                }
                is LoadBookmarksUseCase.UseCaseResult.Success -> {
                    // Save the current timestamp after successful sync
                    settingsDataStore.saveLastSyncTimestamp(Clock.System.now())
                    showNotification(syncResult)
                    Result.success(
                        Data.Builder().putInt(OUTPUT_DATA_COUNT, (syncResult as SyncResult.Success).countDeleted).build()
                    )
                }
            }
            return workResult
        } catch (e: Exception) {
            Timber.e(e, "Error performing sync")
            return Result.failure()
        }
    }

    private val notificationChannelId = "FullSyncNotificationChannelId"


    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {

            val notificationChannel = NotificationChannel(
                notificationChannelId,
                applicationContext.getString(R.string.auto_sync_notification_channel),
                NotificationManager.IMPORTANCE_DEFAULT,
            )

            val notificationManager: NotificationManager? =
                getSystemService(
                    applicationContext,
                    NotificationManager::class.java
                )

            notificationManager?.createNotificationChannel(
                notificationChannel
            )
        }
    }

    private suspend fun showNotification(syncResult: SyncResult) {
        // Skip notification for manual sync (user triggered from settings page)
        val isManualSync = inputData.getBoolean(INPUT_IS_MANUAL_SYNC, false)
        if (isManualSync) {
            Timber.d("Skipping notification for manual sync")
            return
        }

        // Check if notifications are enabled in settings
        if (!settingsDataStore.isSyncNotificationsEnabled()) {
            Timber.d("Sync notifications are disabled")
            return
        }

        createNotificationChannel()

        val contentText = when (syncResult) {
            is SyncResult.Success -> {
                applicationContext.getString(R.string.auto_sync_notification_success)
            }
            else -> {
                applicationContext.getString(R.string.auto_sync_notification_failure)
            }
        }

        val notification = NotificationCompat.Builder(
            applicationContext,
            notificationChannelId
        )
            .setSmallIcon(R.drawable.ic_notification_logo)
            .setContentTitle(applicationContext.getString(R.string.app_name))
            .setContentText(contentText)
            .setAutoCancel(true)
            .build()

        if (ActivityCompat.checkSelfPermission(
                applicationContext,
                Manifest.permission.POST_NOTIFICATIONS
            )
            == PackageManager.PERMISSION_GRANTED
        ) {
            with(NotificationManagerCompat.from(applicationContext)) {
                notify(NOTIFICATION_ID, notification)
            }
        } else {
            Timber.w("No permission to show notification")
        }
    }


    override suspend fun getForegroundInfo(): ForegroundInfo {
        val mainActivityIntent = Intent(
            applicationContext,
            MainActivity::class.java
        )

        val mainActivityPendingIntent = PendingIntent.getActivity(
            applicationContext,
            0,
            mainActivityIntent,
            PendingIntent.FLAG_IMMUTABLE
        )

        val notification = NotificationCompat.Builder(
            applicationContext,
            notificationChannelId
        )
            .setSmallIcon(R.drawable.ic_notification_logo)
            .setContentTitle(applicationContext.getString(R.string.app_name))
            .setContentText(applicationContext.getString(R.string.auto_sync_notification_running))
            .setContentIntent(mainActivityPendingIntent)
            .setAutoCancel(true)
            .build()

        return ForegroundInfo(0, notification)
    }


    companion object {
        const val UNIQUE_NAME_AUTO = "auto_full_sync_work"
        const val UNIQUE_NAME_MANUAL = "manual_full_sync_work"
        const val TAG = "full_sync"
        const val OUTPUT_DATA_COUNT = "count"
        const val NOTIFICATION_ID = 0
        const val INPUT_IS_MANUAL_SYNC = "is_manual_sync"
        val FULL_SYNC_INTERVAL = 24.hours  // Run full sync once per day
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/worker/LoadArticleWorker.kt">
package com.mydeck.app.worker

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import com.mydeck.app.domain.usecase.LoadArticleUseCase
import timber.log.Timber

@HiltWorker
class LoadArticleWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted val workerParams: WorkerParameters,
    val loadArticleUseCase: LoadArticleUseCase
) : CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result {
        try {
            Timber.d("Start Work with params=$workerParams")
            val bookmarkId = workerParams.inputData.getString(PARAM_BOOKMARK_ID)
            return if (bookmarkId != null) {
                Timber.i("Start loading article [bookmarkId=$bookmarkId]")
                loadArticleUseCase.execute(bookmarkId)
                Result.success()
            } else {
                Timber.w("No bookmarkId provided")
                Result.failure()
            }
        } catch (e: Exception) {
            Timber.e(e, "Error loading article")
            return Result.failure()
        }
    }
    companion object {
        const val PARAM_BOOKMARK_ID = "bookmarkId"
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/worker/LoadBookmarksWorker.kt">
package com.mydeck.app.worker

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.Constraints
import androidx.work.CoroutineWorker
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.usecase.LoadBookmarksUseCase
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.datetime.Instant
import timber.log.Timber

@HiltWorker
class LoadBookmarksWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val loadBookmarksUseCase: LoadBookmarksUseCase,
    private val bookmarkRepository: BookmarkRepository,
    private val settingsDataStore: SettingsDataStore,
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        val isInitialLoad = inputData.getBoolean(PARAM_IS_INITIAL_LOAD, false)

        if (isInitialLoad && isAnotherWorkerRunning()) {
            Timber.i("Another LoadBookmarksWorker is running, exiting early.")
            return Result.success() // Or Result.failure() if you want to signal an error
        }

        if (isInitialLoad) {
            try {
                Timber.i("Performing initial sync: Deleting all bookmarks.")
                bookmarkRepository.deleteAllBookmarks()
                Timber.i("Performing initial sync: Reset lastBookmarkTimestamp.")
                settingsDataStore.saveLastBookmarkTimestamp(Instant.fromEpochMilliseconds(0))
            } catch (e: Exception) {
                Timber.e(e, "Error preparing for initial loading.")
                return Result.failure()
            }
        }

        return when (val result = loadBookmarksUseCase.execute()) {
            is LoadBookmarksUseCase.UseCaseResult.Success -> {
                Result.success()
            }
            is LoadBookmarksUseCase.UseCaseResult.Error -> {
                Timber.e(result.exception, "Error loading bookmarks")
                Result.failure() // Or Result.retry() depending on the error
            }
        }
    }

    private suspend fun isAnotherWorkerRunning(): Boolean {
        return withContext(Dispatchers.IO) {
            val workInfos = WorkManager.getInstance(applicationContext)
                .getWorkInfosForUniqueWork(UNIQUE_WORK_NAME)
                .get()

            // Check if there's another worker running with a different ID.
            // This prevents the worker from exiting early if it's briefly interrupted
            // and then rescheduled.
            workInfos.any { it.id != id && it.state == WorkInfo.State.RUNNING }
        }
    }

    companion object {
        const val PARAM_IS_INITIAL_LOAD = "isInitialLoad"
        const val UNIQUE_WORK_NAME = "LoadBookmarksSync"

        fun enqueue(context: Context, isInitialLoad: Boolean = false) {
            val data = Data.Builder().putBoolean(PARAM_IS_INITIAL_LOAD, isInitialLoad).build()

            val request = OneTimeWorkRequestBuilder<LoadBookmarksWorker>()
                .setInputData(data)
                .setConstraints(
                    Constraints.Builder()
                        .setRequiredNetworkType(NetworkType.CONNECTED)
                        .build()
                )
                .build()

            WorkManager.getInstance(context)
                .enqueueUniqueWork(UNIQUE_WORK_NAME, ExistingWorkPolicy.KEEP, request)

        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/MainViewModel.kt">
package com.mydeck.app

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import javax.inject.Inject

@HiltViewModel
class MainViewModel @Inject constructor(
    val settingsDataStore: SettingsDataStore
): ViewModel() {
    val theme = settingsDataStore.themeFlow.map {
        it?.let { Theme.valueOf(it) } ?: Theme.SYSTEM
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = Theme.SYSTEM
    )
}
</file>

<file path="app/src/main/res/drawable/ic_dashboard_black_24dp.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0">
    <path
        android:fillColor="#FF000000"
        android:pathData="M3,13h8L11,3L3,3v10zM3,21h8v-6L3,15v6zM13,21h8L21,11h-8v10zM13,3v6h8L21,3h-8z" />
</vector>
</file>

<file path="app/src/main/res/drawable/ic_home_black_24dp.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0">
    <path
        android:fillColor="#FF000000"
        android:pathData="M10,20v-6h4v6h5v-8h3L12,3 2,12h3v8z" />
</vector>
</file>

<file path="app/src/main/res/drawable/ic_label_24px.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960"
    android:tint="?attr/colorControlNormal"
    android:autoMirrored="true">
  <path
      android:fillColor="@android:color/white"
      android:pathData="M160,800Q127,800 103.5,776.5Q80,753 80,720L80,240Q80,207 103.5,183.5Q127,160 160,160L600,160Q619,160 636,168.5Q653,177 664,192L880,480L664,768Q653,783 636,791.5Q619,800 600,800L160,800ZM160,720L600,720Q600,720 600,720Q600,720 600,720L780,480L600,240Q600,240 600,240Q600,240 600,240L160,240Q160,240 160,240Q160,240 160,240L160,720Q160,720 160,720Q160,720 160,720ZM380,480Q380,480 380,480Q380,480 380,480L380,480Q380,480 380,480Q380,480 380,480L380,480Q380,480 380,480Q380,480 380,480L380,480L380,480Q380,480 380,480Q380,480 380,480Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="200"
    android:viewportHeight="300">
  <group android:scaleX="0.30555555"
      android:scaleY="0.45833334"
      android:translateX="69.44444"
      android:translateY="81.25">
    <path
        android:pathData="M0,0l0,300l100,-100l0,-200z"
        android:fillColor="#46BBD6"/>
    <path
        android:pathData="M100,0l0,200l100,100l0,-300z"
        android:fillColor="#FBCE55"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_notifications_black_24dp.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24.0"
    android:viewportHeight="24.0">
    <path
        android:fillColor="#FF000000"
        android:pathData="M12,22c1.1,0 2,-0.9 2,-2h-4c0,1.1 0.89,2 2,2zM18,16v-5c0,-3.07 -1.64,-5.64 -4.5,-6.32L13.5,4c0,-0.83 -0.67,-1.5 -1.5,-1.5s-1.5,0.67 -1.5,1.5v0.68C7.63,5.36 6,7.92 6,11v5l-2,2v1h16v-1l-2,-2z" />
</vector>
</file>

<file path="app/src/main/res/drawable-anydpi/ic_notification_logo.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="200"
    android:viewportHeight="300"
    android:tint="#FFFFFF">
  <group android:scaleX="0.44834307"
      android:scaleY="0.6725146"
      android:translateX="55.16569"
      android:translateY="49.122807">
    <path
        android:pathData="M0,0l0,300l100,-100l0,-200z"
        android:fillColor="#46BBD6"/>
    <path
        android:pathData="M100,0l0,200l100,100l0,-300z"
        android:fillColor="#FBCE55"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@mipmap/ic_launcher_background"/>
  <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
  <monochrome android:drawable="@mipmap/ic_launcher_monochrome"/>
</adaptive-icon>
</file>

<file path="app/src/main/res/raw/aboutlibraries.json">
{
    "libraries": [
        {
            "uniqueId": "androidx.activity:activity",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Provides the base Activity subclass and the relevant hooks to build a composable structure on top.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Activity",
            "website": "https://developer.android.com/jetpack/androidx/releases/activity#1.10.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.activity:activity-compose",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Compose integration with Activity",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Activity Compose",
            "website": "https://developer.android.com/jetpack/androidx/releases/activity#1.10.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.activity:activity-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Kotlin extensions for 'activity' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Activity Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/activity#1.10.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.annotation:annotation-experimental",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.4.1",
            "description": "Java annotation for use on unstable Android API surfaces. When used in conjunction with the Experimental annotation lint checks, this annotation provides functional parity with Kotlin's Experimental annotation.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Experimental annotation",
            "website": "https://developer.android.com/jetpack/androidx/releases/annotation#1.4.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.annotation:annotation-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.9.1",
            "description": "Provides source annotations for tooling and readability.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Annotation",
            "website": "https://developer.android.com/jetpack/androidx/releases/annotation#1.9.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.appcompat:appcompat",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.0",
            "description": "Provides backwards-compatible implementations of UI-related Android SDK functionality, including dark mode and Material theming.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "AppCompat",
            "website": "https://developer.android.com/jetpack/androidx/releases/appcompat#1.7.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.appcompat:appcompat-resources",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.0",
            "description": "Provides backward-compatible implementations of resource-related Android SDKfunctionality, including color state list theming.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "AppCompat Resources",
            "website": "https://developer.android.com/jetpack/androidx/releases/appcompat#1.7.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.arch.core:core-common",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.2.0",
            "description": "Android Arch-Common",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Arch-Common",
            "website": "https://developer.android.com/jetpack/androidx/releases/arch-core#2.2.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.arch.core:core-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.2.0",
            "description": "Android Arch-Runtime",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Arch-Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/arch-core#2.2.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.autofill:autofill",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "AndroidX Autofill",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "AndroidX Autofill",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.browser:browser",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.8.0",
            "description": "Provides support for embedding Custom Tabs in an app.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Browser",
            "website": "https://developer.android.com/jetpack/androidx/releases/browser#1.8.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.cardview:cardview",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "Android Support CardView v7",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support CardView v7",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.collection:collection-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.4.4",
            "description": "Standalone efficient collections.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "collections",
            "website": "https://developer.android.com/jetpack/androidx/releases/collection#1.4.4",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.collection:collection-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.4.4",
            "description": "Kotlin extensions for 'collection' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Collections Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/collection#1.4.4",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.animation:animation-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose animation library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Animation",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-animation#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.animation:animation-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Animation engine and animation primitives that are the building blocks of the Compose animation library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Animation Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-animation#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.foundation:foundation-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Higher level abstractions of the Compose UI primitives. This library is design system agnostic, providing the high-level building blocks for both application and design-system developers",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Foundation",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-foundation#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.foundation:foundation-layout-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose layout implementations",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Layouts",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-foundation#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.material3:material3-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.3.1",
            "description": "Compose Material You Design Components library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Material3 Components",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-material3#1.3.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.material:material-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose Material Design Components library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Material Components",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-material#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.material:material-icons-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose Material Design core icons. This module contains the most commonly used set of Material icons.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Material Icons Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-material#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.material:material-icons-extended-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose Material Design extended icons. This module contains all Material icons. It is a very large dependency and should not be included directly.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Material Icons Extended",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-material#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.material:material-ripple-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Material ripple used to build interactive components",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Material Ripple",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-material#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.runtime:runtime-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Tree composition support for code generated by the Compose compiler plugin and corresponding public API",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-runtime#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.runtime:runtime-saveable-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose components that allow saving and restoring the local ui state",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Saveable",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-runtime#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose UI primitives. This library contains the primitives that form the Compose UI Toolkit, such as drawing, measurement and layout.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose UI",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-geometry-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose classes related to dimensions without units",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Geometry",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-graphics-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose graphics",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Graphics",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-test-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose testing library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Testing",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-test-junit4-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose testing integration with JUnit4",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Testing for JUnit4",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-test-manifest",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose testing library that should be added as a debugImplementation dependency to add properties to the debug manifest necessary for testing an application",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Testing manifest dependency",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-text-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose Text primitives and utilities",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose UI Text",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-tooling-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose tooling library. This library exposes information to our tools for better IDE support.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Tooling",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-tooling-data-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose tooling library data. This library provides data about compose for different tooling purposes.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Tooling Data",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-tooling-preview-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose tooling library API. This library provides the API required to declare @Preview composables in user apps.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose UI Preview Tooling",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-unit-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Compose classes for simple units",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Unit",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose.ui:ui-util-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.8",
            "description": "Internal Compose utilities used by other modules",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Util",
            "website": "https://developer.android.com/jetpack/androidx/releases/compose-ui#1.7.8",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.compose:compose-bom",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2025.03.00",
            "description": "A compatible set of Jetpack Compose libraries.",
            "name": "Jetpack Compose Libraries BOM",
            "website": "https://developer.android.com/jetpack",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.concurrent:concurrent-futures",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "Androidx implementation of Guava's ListenableFuture",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "AndroidX Futures",
            "website": "https://developer.android.com/topic/libraries/architecture/index.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.concurrent:concurrent-futures-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "Kotlin Extensions for Androidx implementation of Guava's ListenableFuture",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "AndroidX Futures Kotlin Extensions",
            "website": "https://developer.android.com/topic/libraries/architecture/index.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.constraintlayout:constraintlayout",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.2.1",
            "description": "This library offers a flexible and adaptable way to position and animate widgets",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "ConstraintLayout",
            "website": "https://developer.android.com/jetpack/androidx/releases/constraintlayout#2.2.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.constraintlayout:constraintlayout-core",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.1",
            "description": "This library contains engines and algorithms for constraint based layout and complex animations (it is used by the ConstraintLayout library)",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "ConstraintLayout Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/constraintlayout#1.1.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.coordinatorlayout:coordinatorlayout",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Coordinator Layout",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.core:core",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.15.0",
            "description": "Provides backward-compatible implementations of Android platform APIs and features.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/core#1.15.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.core:core-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.15.0",
            "description": "Kotlin extensions for 'core' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Core Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/core#1.15.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.core:core-viewtree",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "Provides ViewTree extensions packaged for use by other core androidx libraries",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "androidx.core:core-viewtree",
            "website": "https://developer.android.com/jetpack/androidx/releases/core#1.0.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.cursoradapter:cursoradapter",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Cursor Adapter",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.customview:customview",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Custom View",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.customview:customview-poolingcontainer",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "Utilities for listening to the lifecycle of containers that manage their child Views' lifecycle, such as RecyclerView",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "androidx.customview:poolingcontainer",
            "website": "https://developer.android.com/jetpack/androidx/releases/customview#1.0.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.databinding:viewbinding",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "8.8.2",
            "description": "",
            "name": "androidx.databinding:viewbinding",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.datastore:datastore-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Android DataStore - contains the underlying store used by each serialization method along with components that require an Android dependency",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "DataStore",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.datastore:datastore-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Android DataStore Core - contains the underlying store used by each serialization method",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "DataStore Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.datastore:datastore-core-okio-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Android DataStore Core Okio- contains APIs to use datastore-core in multiplatform via okio",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "DataStore Core Okio",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.datastore:datastore-preferences-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Android Preferences DataStore",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Preferences DataStore",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.datastore:datastore-preferences-core-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Android Preferences DataStore without the Android Dependencies",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Preferences DataStore Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.datastore:datastore-preferences-external-protobuf",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Repackaged proto-lite dependency for use by datastore preferences",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Preferences External Protobuf",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "BSD-3-Clause"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.datastore:datastore-preferences-proto",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.3",
            "description": "Jarjar the generated proto for use by datastore-preferences.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Preferences DataStore Proto",
            "website": "https://developer.android.com/jetpack/androidx/releases/datastore#1.1.3",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.documentfile:documentfile",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Document File",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.drawerlayout:drawerlayout",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.1",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Drawer Layout",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.dynamicanimation:dynamicanimation",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "Physics-based animation in support library, where the animations are driven by physics force. You can use this Animation library to create smooth and realistic animations.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support DynamicAnimation",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.emoji2:emoji2",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.3.0",
            "description": "Core library to enable emoji compatibility in Kitkat and newer devices to avoid the empty emoji characters.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Emoji2 Compat",
            "website": "https://developer.android.com/jetpack/androidx/releases/emoji2#1.3.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.emoji2:emoji2-views-helper",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.3.0",
            "description": "View helpers for Emoji2",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Emoji2 Compat view helpers",
            "website": "https://developer.android.com/jetpack/androidx/releases/emoji2#1.3.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.exifinterface:exifinterface",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.3.7",
            "description": "Android Support ExifInterface",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Support ExifInterface",
            "website": "https://developer.android.com/jetpack/androidx/releases/exifinterface#1.3.7",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.fragment:fragment",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.6.2",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Support fragment",
            "website": "https://developer.android.com/jetpack/androidx/releases/fragment#1.6.2",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.fragment:fragment-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.6.2",
            "description": "Kotlin extensions for 'fragment' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Fragment Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/fragment#1.6.2",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.graphics:graphics-path",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.1",
            "description": "Query segment data for android.graphics.Path objects",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Graphics Path",
            "website": "https://developer.android.com/jetpack/androidx/releases/graphics#1.0.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.hilt:hilt-common",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "AndroidX Hilt Extension Annotations",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Hilt Common",
            "website": "https://developer.android.com/jetpack/androidx/releases/hilt#1.2.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.hilt:hilt-navigation",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "Android Navigation Hilt Extension",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Hilt Extension",
            "website": "https://developer.android.com/jetpack/androidx/releases/hilt#1.2.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.hilt:hilt-navigation-compose",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "Navigation Compose Hilt Integration",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Compose Hilt Integration",
            "website": "https://developer.android.com/jetpack/androidx/releases/hilt#1.2.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.hilt:hilt-work",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "Android Lifecycle WorkManager Hilt Extension",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "WorkManager Hilt Extension",
            "website": "https://developer.android.com/jetpack/androidx/releases/hilt#1.2.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.interpolator:interpolator",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Interpolators",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.legacy:legacy-support-core-utils",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support core utils",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-common-java8",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle-Common for Java 8 Language",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle-Common for Java 8",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-common-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle-Common",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle-Common",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-livedata",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle LiveData",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle LiveData",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-livedata-core",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle LiveData Core",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle LiveData Core",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-livedata-core-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Kotlin extensions for 'livedata-core' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "LiveData Core Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-livedata-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Kotlin extensions for 'livedata' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "LiveData Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-process",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle Process",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle Process",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-runtime-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle Runtime",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-runtime-compose-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Compose integration with Lifecycle",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle Runtime Compose",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-runtime-ktx-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Kotlin extensions for 'lifecycle' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-service",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle Service",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle Service",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-viewmodel",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle ViewModel",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle ViewModel",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-viewmodel-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle ViewModel",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle ViewModel",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-viewmodel-compose-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Compose integration with Lifecycle ViewModel",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle ViewModel Compose",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-viewmodel-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Kotlin extensions for 'viewmodel' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle ViewModel Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.lifecycle:lifecycle-viewmodel-savedstate",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.7",
            "description": "Android Lifecycle ViewModel",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Lifecycle ViewModel with SavedState",
            "website": "https://developer.android.com/jetpack/androidx/releases/lifecycle#2.8.7",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.loader:loader",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support loader",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.localbroadcastmanager:localbroadcastmanager",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Local Broadcast Manager",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.multidex:multidex",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.0.1",
            "description": "Library for legacy multi-dex support",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/multidex",
                "url": "http://source.android.com"
            },
            "name": "Android Multi-Dex Library",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.navigation:navigation-common",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-Common",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Common",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-common-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-Common-Ktx",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Common Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-compose",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Compose integration with Navigation",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Compose Navigation",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-fragment",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-Fragment",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Fragment",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-fragment-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-Fragment-Ktx",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Fragment Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-Runtime",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-runtime-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-Runtime-Ktx",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation Runtime Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-ui",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-UI",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation UI",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.navigation:navigation-ui-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.8.9",
            "description": "Android Navigation-UI-Ktx",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Navigation UI Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/navigation#2.8.9",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.print:print",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support Print",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.profileinstaller:profileinstaller",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.4.1",
            "description": "Allows libraries to prepopulate ahead of time compilation traces to be read by ART",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Profile Installer",
            "website": "https://developer.android.com/jetpack/androidx/releases/profileinstaller#1.4.1",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.recyclerview:recyclerview",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "Android Support RecyclerView v7",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support RecyclerView v7",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.resourceinspection:resourceinspection-annotation",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.1",
            "description": "Annotation processors for Android resource and layout inspection",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Resource Inspection - Annotations",
            "website": "https://developer.android.com/jetpack/androidx/releases/resourceinspection#1.0.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.room:room-common",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.6.1",
            "description": "Android Room-Common",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Room-Common",
            "website": "https://developer.android.com/jetpack/androidx/releases/room#2.6.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.room:room-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.6.1",
            "description": "Android Room Kotlin Extensions",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Room Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/room#2.6.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.room:room-migration",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.6.1",
            "description": "Android Room Migration",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Room Migration",
            "website": "https://developer.android.com/jetpack/androidx/releases/room#2.6.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.room:room-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.6.1",
            "description": "Android Room-Runtime",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Room-Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/room#2.6.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.room:room-testing",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.6.1",
            "description": "Android Room Testing",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Room Testing",
            "website": "https://developer.android.com/jetpack/androidx/releases/room#2.6.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.savedstate:savedstate",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.1",
            "description": "Android Lifecycle Saved State",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Saved State",
            "website": "https://developer.android.com/jetpack/androidx/releases/savedstate#1.2.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.savedstate:savedstate-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.1",
            "description": "Kotlin extensions for 'savedstate' artifact",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "SavedState Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/savedstate#1.2.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.security:security-crypto",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0-alpha06",
            "description": "AndroidX Security",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "AndroidX Security",
            "website": "https://developer.android.com/jetpack/androidx/releases/security#1.1.0-alpha06",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.slidingpanelayout:slidingpanelayout",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "SlidingPaneLayout offers a responsive, two pane layout that automatically switches between overlapping panes on smaller devices to a side by side view on larger devices.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Support Sliding Pane Layout",
            "website": "https://developer.android.com/jetpack/androidx/releases/slidingpanelayout#1.2.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.sqlite:sqlite",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.4.0",
            "description": "Android DB",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "SQLite",
            "website": "https://developer.android.com/jetpack/androidx/releases/sqlite#2.4.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.sqlite:sqlite-framework",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.4.0",
            "description": "The implementation of Support SQLite library using the framework code.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "SQLite Framework Integration",
            "website": "https://developer.android.com/jetpack/androidx/releases/sqlite#2.4.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.startup:startup-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.1",
            "description": "Android App Startup Runtime",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android App Startup Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/startup#1.1.1",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test.espresso:espresso-core",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "3.5.0",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test.espresso:espresso-idling-resource",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "3.5.0",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test.ext:junit",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.1",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test.services:storage",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.5.0",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test:annotation",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.1",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test:core",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.6.1",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test:monitor",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.7.1",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.test:runner",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.5.0",
            "description": "The AndroidX Test Library provides an extensive framework for testing Android apps",
            "name": "AndroidX Test Library",
            "website": "https://developer.android.com/testing",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.tracing:tracing",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "Android Tracing",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Tracing",
            "website": "https://developer.android.com/jetpack/androidx/releases/tracing#1.2.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.tracing:tracing-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "Android Tracing",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Android Tracing Runtime Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/tracing#1.2.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.transition:transition",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.5.0",
            "description": "Android Transition Support Library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Transition",
            "website": "https://developer.android.com/jetpack/androidx/releases/transition#1.5.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.vectordrawable:vectordrawable",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "Android Support VectorDrawable",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support VectorDrawable",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.vectordrawable:vectordrawable-animated",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.0",
            "description": "Android Support AnimatedVectorDrawable",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support AnimatedVectorDrawable",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.versionedparcelable:versionedparcelable",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.1.1",
            "description": "Provides a stable but relatively compact binary serialization format that can be passed across processes or persisted safely.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "VersionedParcelable",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.viewpager2:viewpager2",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "AndroidX Widget ViewPager2",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "AndroidX Widget ViewPager2",
            "website": "https://developer.android.com/jetpack/androidx",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.viewpager:viewpager",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "The Support Library is a static library that you can add to your Android application in order to use APIs that are either not available for older platform versions or utility APIs that aren't a part of the framework APIs. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "http://source.android.com"
            },
            "name": "Support View Pager",
            "website": "http://developer.android.com/tools/extras/support-library.html",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.window:window",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "WindowManager Jetpack library. Currently only provides additional functionality on foldable devices.",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "Jetpack WindowManager Library",
            "website": "https://developer.android.com/jetpack/androidx/releases/window#1.0.0",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "androidx.work:work-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.10.0",
            "description": "Android WorkManager runtime library",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "WorkManager Runtime",
            "website": "https://developer.android.com/jetpack/androidx/releases/work#2.10.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "androidx.work:work-runtime-ktx",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "2.10.0",
            "description": "Android WorkManager Kotlin Extensions",
            "scm": {
                "connection": "scm:git:https://android.googlesource.com/platform/frameworks/support",
                "url": "https://cs.android.com/androidx/platform/frameworks/support"
            },
            "name": "WorkManager Kotlin Extensions",
            "website": "https://developer.android.com/jetpack/androidx/releases/work#2.10.0",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "The Android Open Source Project"
            }
        },
        {
            "uniqueId": "com.almworks.sqlite4java:sqlite4java",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Igor Sereda"
                },
                {
                    "name": "Eugene Vagin"
                },
                {
                    "name": "Dmitry Peshehonov"
                }
            ],
            "artifactVersion": "1.0.392",
            "description": "Minimalistic high-performance Java wrapper for SQLite",
            "scm": {
                "connection": "scm:svn:http://sqlite4java.googlecode.com/svn/trunk/",
                "url": "http://sqlite4java.googlecode.com/svn/trunk/",
                "developerConnection": "scm:svn:https://sqlite4java.googlecode.com/svn/trunk/"
            },
            "name": "sqlite4java",
            "website": "http://code.google.com/p/sqlite4java",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "http://almworks.com",
                "name": "ALM Works"
            }
        },
        {
            "uniqueId": "com.caverock:androidsvg-aar",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Paul LeBeau"
                }
            ],
            "artifactVersion": "1.4",
            "description": "SVG rendering library for Android.",
            "scm": {
                "connection": "https://github.com/BigBadaboom/androidsvg.git",
                "url": "https://github.com/BigBadaboom/androidsvg",
                "developerConnection": "https://github.com/BigBadaboom/androidsvg.git"
            },
            "name": "AndroidSVG",
            "website": "https://github.com/BigBadaboom/androidsvg",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.github.bastienpaulfr:Treessence",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "BP"
                }
            ],
            "artifactVersion": "1.1.2",
            "description": "Some trees for Timber lib",
            "scm": {
                "connection": "scm:git://github.com/bastienpaulfr/Treessence.git",
                "url": "git://github.com/bastienpaulfr/Treessence.git",
                "developerConnection": "scm:git://github.com/bastienpaulfr/Treessence.git"
            },
            "name": "bastienpaulfr/Treessence",
            "website": "https://github.com/bastienpaulfr/Treessence",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.accompanist:accompanist-drawablepainter",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Google"
                }
            ],
            "artifactVersion": "0.36.0",
            "description": "Utilities for Jetpack Compose",
            "scm": {
                "connection": "scm:git:git://github.com/google/accompanist.git",
                "url": "https://github.com/google/accompanist/",
                "developerConnection": "scm:git:git://github.com/google/accompanist.git"
            },
            "name": "Accompanist Drawable Painter library",
            "website": "https://github.com/google/accompanist/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.accompanist:accompanist-permissions",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Google"
                }
            ],
            "artifactVersion": "0.37.3",
            "description": "Utilities for Jetpack Compose",
            "scm": {
                "connection": "scm:git:git://github.com/google/accompanist.git",
                "url": "https://github.com/google/accompanist/",
                "developerConnection": "scm:git:git://github.com/google/accompanist.git"
            },
            "name": "Accompanist Permissions",
            "website": "https://github.com/google/accompanist/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.android.material:material",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Project"
                }
            ],
            "artifactVersion": "1.12.0",
            "description": "Material Components for Android is a static library that you can add to your Android application in order to use APIs that provide implementations of the Material Design specification. Compatible on devices running API 14 or later.",
            "scm": {
                "connection": "scm:git:https://github.com/material-components/material-components-android.git",
                "url": "https://github.com/material-components/material-components-android"
            },
            "name": "Material Components for Android",
            "website": "https://github.com/material-components/material-components-android",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.auto.value:auto-value-annotations",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.11.0",
            "description": "Immutable value-type code generation for Java 8+.",
            "scm": {
                "connection": "scm:git:git://github.com/google/auto.git",
                "url": "http://github.com/google/auto",
                "developerConnection": "scm:git:ssh://git@github.com/google/auto.git"
            },
            "name": "AutoValue Annotations",
            "website": "https://github.com/google/auto/tree/main/value",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "http://www.google.com",
                "name": "Google LLC"
            }
        },
        {
            "uniqueId": "com.google.code.findbugs:jsr305",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "3.0.2",
            "description": "JSR305 Annotations for Findbugs",
            "scm": {
                "connection": "scm:git:https://code.google.com/p/jsr-305/",
                "url": "https://code.google.com/p/jsr-305/",
                "developerConnection": "scm:git:https://code.google.com/p/jsr-305/"
            },
            "name": "FindBugs-jsr305",
            "website": "http://findbugs.sourceforge.net/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.code.gson:gson",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.8.9",
            "description": "Gson JSON library",
            "scm": {
                "connection": "scm:git:https://github.com/google/gson.git",
                "url": "https://github.com/google/gson/",
                "developerConnection": "scm:git:git@github.com:google/gson.git"
            },
            "name": "Gson",
            "website": "https://github.com/google/gson",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.crypto.tink:tink-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.google.com"
                }
            ],
            "artifactVersion": "1.8.0",
            "description": "Tink is a small cryptographic library that provides a safe, simple, agile and fast way to accomplish some common cryptographic tasks.",
            "scm": {
                "connection": "scm:git:git@github.com:tink-crypto/tink-java.git",
                "url": "https://github.com/tink-crypto/tink-java.git",
                "developerConnection": "scm:git:git@github.com:tink-crypto/tink-java.git"
            },
            "name": "Tink Cryptography API for Android",
            "website": "http://github.com/tink-crypto/tink-java",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.dagger:dagger",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.55",
            "description": "A fast dependency injector for Android and Java.",
            "scm": {
                "connection": "scm:git:git://github.com/google/dagger.git",
                "url": "https://github.com/google/dagger/",
                "developerConnection": "scm:git:ssh://git@github.com/google/dagger.git"
            },
            "name": "Dagger",
            "website": "https://github.com/google/dagger",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "https://www.google.com",
                "name": "Google, Inc."
            }
        },
        {
            "uniqueId": "com.google.dagger:dagger-lint-aar",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.55",
            "description": "A fast dependency injector for Android and Java.",
            "scm": {
                "connection": "scm:git:git://github.com/google/dagger.git",
                "url": "https://github.com/google/dagger/",
                "developerConnection": "scm:git:ssh://git@github.com/google/dagger.git"
            },
            "name": "Dagger Lint Rules AAR Distribution",
            "website": "https://github.com/google/dagger",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "https://www.google.com",
                "name": "Google, Inc."
            }
        },
        {
            "uniqueId": "com.google.dagger:hilt-android",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.55",
            "description": "A fast dependency injector for Android and Java.",
            "scm": {
                "connection": "scm:git:git://github.com/google/dagger.git",
                "url": "https://github.com/google/dagger/",
                "developerConnection": "scm:git:ssh://git@github.com/google/dagger.git"
            },
            "name": "Hilt Android",
            "website": "https://github.com/google/dagger",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "https://www.google.com",
                "name": "Google, Inc."
            }
        },
        {
            "uniqueId": "com.google.dagger:hilt-android-testing",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.55",
            "description": "A fast dependency injector for Android and Java.",
            "scm": {
                "connection": "scm:git:git://github.com/google/dagger.git",
                "url": "https://github.com/google/dagger/",
                "developerConnection": "scm:git:ssh://git@github.com/google/dagger.git"
            },
            "name": "Hilt Android Testing",
            "website": "https://github.com/google/dagger",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "https://www.google.com",
                "name": "Google, Inc."
            }
        },
        {
            "uniqueId": "com.google.dagger:hilt-core",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.55",
            "description": "A fast dependency injector for Android and Java.",
            "scm": {
                "connection": "scm:git:git://github.com/google/dagger.git",
                "url": "https://github.com/google/dagger/",
                "developerConnection": "scm:git:ssh://git@github.com/google/dagger.git"
            },
            "name": "Hilt Core",
            "website": "https://github.com/google/dagger",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "https://www.google.com",
                "name": "Google, Inc."
            }
        },
        {
            "uniqueId": "com.google.errorprone:error_prone_annotation",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.34.0",
            "description": "Error Prone is a static analysis tool for Java that catches common programming mistakes at compile-time.",
            "scm": {
                "connection": "scm:git:https://github.com/google/error-prone.git",
                "url": "https://github.com/google/error-prone",
                "developerConnection": "scm:git:git@github.com:google/error-prone.git"
            },
            "name": "@BugPattern annotation",
            "website": "https://errorprone.info",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "http://www.google.com",
                "name": "Google LLC"
            }
        },
        {
            "uniqueId": "com.google.errorprone:error_prone_annotations",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.28.0",
            "description": "Error Prone is a static analysis tool for Java that catches common programming mistakes at compile-time.",
            "scm": {
                "connection": "scm:git:https://github.com/google/error-prone.git",
                "url": "https://github.com/google/error-prone",
                "developerConnection": "scm:git:git@github.com:google/error-prone.git"
            },
            "name": "error-prone annotations",
            "website": "https://errorprone.info",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "http://www.google.com",
                "name": "Google LLC"
            }
        },
        {
            "uniqueId": "com.google.guava:failureaccess",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.0.2",
            "description": "Contains\n    com.google.common.util.concurrent.internal.InternalFutureFailureAccess and\n    InternalFutures. Most users will never need to use this artifact. Its\n    classes are conceptually a part of Guava, but they're in this separate\n    artifact so that Android libraries can use them without pulling in all of\n    Guava (just as they can use ListenableFuture by depending on the\n    listenablefuture artifact).",
            "scm": {
                "connection": "scm:git:https://github.com/google/guava.git",
                "url": "https://github.com/google/guava",
                "developerConnection": "scm:git:git@github.com:google/guava.git"
            },
            "name": "Guava InternalFutureFailureAccess and InternalFutures",
            "website": "https://github.com/google/guava",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.guava:listenablefuture",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "9999.0-empty-to-avoid-conflict-with-guava",
            "description": "An empty artifact that Guava depends on to signal that it is providing\n    ListenableFuture -- but is also available in a second \"version\" that\n    contains com.google.common.util.concurrent.ListenableFuture class, without\n    any other Guava classes. The idea is:\n\n    - If users want only ListenableFuture, they depend on listenablefuture-1.0.\n\n    - If users want all of Guava, they depend on guava, which, as of Guava\n    27.0, depends on\n    listenablefuture-9999.0-empty-to-avoid-conflict-with-guava. The 9999.0-...\n    version number is enough for some build systems (notably, Gradle) to select\n    that empty artifact over the \"real\" listenablefuture-1.0 -- avoiding a\n    conflict with the copy of ListenableFuture in guava itself. If users are\n    using an older version of Guava or a build system other than Gradle, they\n    may see class conflicts. If so, they can solve them by manually excluding\n    the listenablefuture artifact or manually forcing their build systems to\n    use 9999.0-....",
            "scm": {
                "connection": "scm:git:https://github.com/google/guava.git",
                "url": "https://github.com/google/guava",
                "developerConnection": "scm:git:git@github.com:google/guava.git"
            },
            "name": "Guava ListenableFuture only",
            "website": "https://github.com/google/guava",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.j2objc:j2objc-annotations",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.google.com",
                    "name": "Tom Ball"
                }
            ],
            "artifactVersion": "3.0.0",
            "description": "A set of annotations that provide additional information to the J2ObjC\n    translator to modify the result of translation.",
            "scm": {
                "connection": "scm:git:git://github.com/google/j2objc.git",
                "url": "http://github.com/google/j2objc",
                "developerConnection": "scm:git:ssh://git@github.com/google/j2objc.git"
            },
            "name": "J2ObjC Annotations",
            "website": "https://github.com/google/j2objc/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.google.testparameterinjector:test-parameter-injector",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.18",
            "description": "A simple yet powerful parameterized test runner.",
            "scm": {
                "connection": "scm:git:git://github.com/google/testparameterinjector.git",
                "url": "http://github.com/google/testparameterinjector/",
                "developerConnection": "scm:git:ssh://git@github.com/google/testparameterinjector.git"
            },
            "name": "TestParameterInjector for JUnit4",
            "website": "https://github.com/google/testparameterinjector",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "http://www.google.com/",
                "name": "Google Inc."
            }
        },
        {
            "uniqueId": "com.ibm.icu:icu4j",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "75.1",
            "description": "International Components for Unicode for Java (ICU4J) is a mature, widely used Java library\n    providing Unicode and Globalization support",
            "scm": {
                "connection": "scm:git:git://github.com/unicode-org/icu.git",
                "url": "https://github.com/unicode-org/icu",
                "developerConnection": "scm:git:git@github.com:unicode-org/icu.git"
            },
            "name": "${proj-title} (${project.artifactId})",
            "website": "https://icu.unicode.org/",
            "licenses": [
                "5be2dcb917a8d00d01258ff45d1f55b2"
            ],
            "organization": {
                "url": "https://icu.unicode.org/",
                "name": "Unicode, Inc."
            }
        },
        {
            "uniqueId": "com.jakewharton.timber:timber",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Jake Wharton"
                }
            ],
            "artifactVersion": "5.0.1",
            "description": "No-nonsense injectable logging.",
            "scm": {
                "connection": "scm:git:git://github.com/JakeWharton/timber.git",
                "url": "https://github.com/JakeWharton/timber",
                "developerConnection": "scm:git:git://github.com/JakeWharton/timber.git"
            },
            "name": "Timber",
            "website": "https://github.com/JakeWharton/timber",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.mikepenz:aboutlibraries-compose-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Mike Penz"
                }
            ],
            "artifactVersion": "12.0.0-a04",
            "description": "AboutLibraries automatically detects all dependencies of a project and collects their information including the license. Optionally visualising it via the provided ui components.",
            "scm": {
                "connection": "scm:git@github.com:mikepenz/AboutLibraries.git",
                "url": "https://github.com/mikepenz/AboutLibraries",
                "developerConnection": "scm:git@github.com:mikepenz/AboutLibraries.git"
            },
            "name": "AboutLibraries Compose UI Library",
            "website": "https://github.com/mikepenz/AboutLibraries",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.mikepenz:aboutlibraries-compose-m3-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Mike Penz"
                }
            ],
            "artifactVersion": "12.0.0-a04",
            "description": "AboutLibraries automatically detects all dependencies of a project and collects their information including the license. Optionally visualising it via the provided ui components.",
            "scm": {
                "connection": "scm:git@github.com:mikepenz/AboutLibraries.git",
                "url": "https://github.com/mikepenz/AboutLibraries",
                "developerConnection": "scm:git@github.com:mikepenz/AboutLibraries.git"
            },
            "name": "AboutLibraries Compose Material 3 Library",
            "website": "https://github.com/mikepenz/AboutLibraries",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.mikepenz:aboutlibraries-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Mike Penz"
                }
            ],
            "artifactVersion": "12.0.0-a04",
            "description": "AboutLibraries automatically detects all dependencies of a project and collects their information including the license. Optionally visualising it via the provided ui components.",
            "scm": {
                "connection": "scm:git@github.com:mikepenz/AboutLibraries.git",
                "url": "https://github.com/mikepenz/AboutLibraries",
                "developerConnection": "scm:git@github.com:mikepenz/AboutLibraries.git"
            },
            "name": "AboutLibraries Core Library",
            "website": "https://github.com/mikepenz/AboutLibraries",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.okhttp3:logging-interceptor",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "4.12.0",
            "description": "Square\u2019s meticulous HTTP client for Java and Kotlin.",
            "scm": {
                "connection": "scm:git:https://github.com/square/okhttp.git",
                "url": "https://github.com/square/okhttp",
                "developerConnection": "scm:git:ssh://git@github.com/square/okhttp.git"
            },
            "name": "okhttp-logging-interceptor",
            "website": "https://square.github.io/okhttp/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.okhttp3:mockwebserver",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "4.12.0",
            "description": "Square\u2019s meticulous HTTP client for Java and Kotlin.",
            "scm": {
                "connection": "scm:git:https://github.com/square/okhttp.git",
                "url": "https://github.com/square/okhttp",
                "developerConnection": "scm:git:ssh://git@github.com/square/okhttp.git"
            },
            "name": "mockwebserver",
            "website": "https://square.github.io/okhttp/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.okhttp3:okhttp",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "4.12.0",
            "description": "Square\u2019s meticulous HTTP client for Java and Kotlin.",
            "scm": {
                "connection": "scm:git:https://github.com/square/okhttp.git",
                "url": "https://github.com/square/okhttp",
                "developerConnection": "scm:git:ssh://git@github.com/square/okhttp.git"
            },
            "name": "okhttp",
            "website": "https://square.github.io/okhttp/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.okio:okio-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "3.10.2",
            "description": "A modern I/O library for Android, Java, and Kotlin Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/square/okio.git",
                "url": "https://github.com/square/okio/",
                "developerConnection": "scm:git:ssh://git@github.com/square/okio.git"
            },
            "name": "okio",
            "website": "https://github.com/square/okio/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.retrofit2:converter-kotlinx-serialization",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "2.11.0",
            "description": "A Retrofit Converter which uses kotlinx.serialization for serialization.",
            "scm": {
                "connection": "scm:git:git://github.com/square/retrofit.git",
                "url": "https://github.com/square/retrofit/",
                "developerConnection": "scm:git:ssh://git@github.com/square/retrofit.git"
            },
            "name": "Converter: kotlinx.serialization",
            "website": "https://github.com/square/retrofit",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.retrofit2:converter-scalars",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "2.11.0",
            "description": "A Retrofit Converter for Java's scalar value types.",
            "scm": {
                "connection": "scm:git:git://github.com/square/retrofit.git",
                "url": "https://github.com/square/retrofit/",
                "developerConnection": "scm:git:ssh://git@github.com/square/retrofit.git"
            },
            "name": "Converter: Scalars",
            "website": "https://github.com/square/retrofit",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup.retrofit2:retrofit",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Square, Inc."
                }
            ],
            "artifactVersion": "2.11.0",
            "description": "A type-safe HTTP client for Android and Java.",
            "scm": {
                "connection": "scm:git:git://github.com/square/retrofit.git",
                "url": "https://github.com/square/retrofit/",
                "developerConnection": "scm:git:ssh://git@github.com/square/retrofit.git"
            },
            "name": "Retrofit",
            "website": "https://github.com/square/retrofit",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "com.squareup:javawriter",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "2.1.1",
            "description": "A utility class which aids in generating Java source files.",
            "scm": {
                "connection": "scm:git:git://github.com/square/javawriter.git",
                "url": "http://github.com/square/javawriter/",
                "developerConnection": "scm:git:ssh://git@github.com/square/javawriter.git"
            },
            "name": "JavaWriter",
            "website": "http://github.com/square/javawriter/",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "http://squareup.com",
                "name": "Square, Inc."
            }
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-compose-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil-compose",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-compose-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil-compose-core",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil-core",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-network-core-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil-network-core",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-network-okhttp-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil-network-okhttp",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.coil-kt.coil3:coil-svg-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Coil Contributors"
                }
            ],
            "artifactVersion": "3.1.0",
            "description": "An image loading library for Android and Compose Multiplatform.",
            "scm": {
                "connection": "scm:git:git://github.com/coil-kt/coil.git",
                "url": "https://github.com/coil-kt/coil",
                "developerConnection": "scm:git:ssh://git@github.com/coil-kt/coil.git"
            },
            "name": "coil-svg",
            "website": "https://github.com/coil-kt/coil",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.mockk:mockk-agent-api-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Oleksii Pylypenko"
                },
                {
                    "name": "Mattia Tommasone"
                }
            ],
            "artifactVersion": "1.13.16",
            "description": "API to build MockK agents",
            "scm": {
                "connection": "scm:git:git@github.com:mockk/mockk.git",
                "url": "https://github.com/mockk/mockk/",
                "developerConnection": "scm:git:git@github.com:mockk/mockk.git"
            },
            "name": "MockK Agent API",
            "website": "https://mockk.io",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.mockk:mockk-agent-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Oleksii Pylypenko"
                },
                {
                    "name": "Mattia Tommasone"
                }
            ],
            "artifactVersion": "1.13.16",
            "description": "MockK inline mocking agent",
            "scm": {
                "connection": "scm:git:git@github.com:mockk/mockk.git",
                "url": "https://github.com/mockk/mockk/",
                "developerConnection": "scm:git:git@github.com:mockk/mockk.git"
            },
            "name": "MockK",
            "website": "https://mockk.io",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.mockk:mockk-core-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Oleksii Pylypenko"
                },
                {
                    "name": "Mattia Tommasone"
                }
            ],
            "artifactVersion": "1.13.16",
            "description": "MockK functionality that is used by other MockK modules",
            "scm": {
                "connection": "scm:git:git@github.com:mockk/mockk.git",
                "url": "https://github.com/mockk/mockk/",
                "developerConnection": "scm:git:git@github.com:mockk/mockk.git"
            },
            "name": "MockK Core",
            "website": "https://mockk.io",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.mockk:mockk-dsl-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Oleksii Pylypenko"
                },
                {
                    "name": "Mattia Tommasone"
                }
            ],
            "artifactVersion": "1.13.16",
            "description": "MockK DSL providing API for MockK implementation",
            "scm": {
                "connection": "scm:git:git@github.com:mockk/mockk.git",
                "url": "https://github.com/mockk/mockk/",
                "developerConnection": "scm:git:git@github.com:mockk/mockk.git"
            },
            "name": "MockK DSL",
            "website": "https://mockk.io",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "io.mockk:mockk-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Oleksii Pylypenko"
                },
                {
                    "name": "Mattia Tommasone"
                }
            ],
            "artifactVersion": "1.13.16",
            "description": "Mocking library for Kotlin",
            "scm": {
                "connection": "scm:git:git@github.com:mockk/mockk.git",
                "url": "https://github.com/mockk/mockk/",
                "developerConnection": "scm:git:git@github.com:mockk/mockk.git"
            },
            "name": "MockK",
            "website": "https://mockk.io",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "jakarta.inject:jakarta.inject-api",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Antoine Sabot-Durand"
                },
                {
                    "name": "Martin Kouba"
                },
                {
                    "name": "Tomas Remes"
                },
                {
                    "name": "Matej Novotny"
                }
            ],
            "artifactVersion": "2.0.1",
            "description": "Jakarta Dependency Injection",
            "scm": {
                "connection": "scm:git:ssh://git@github.com/eclipse-ee4j/injection-api.git",
                "url": "https://github.com/eclipse-ee4j/injection-api",
                "developerConnection": "scm:git:ssh://git@github.com/eclipse-ee4j/injection-api.git"
            },
            "name": "Jakarta Dependency Injection",
            "website": "https://github.com/eclipse-ee4j/injection-api",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "url": "https://www.eclipse.org",
                "name": "Eclipse Foundation"
            }
        },
        {
            "uniqueId": "javax.annotation:javax.annotation-api",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Linda De Michiel"
                }
            ],
            "artifactVersion": "1.3.2",
            "description": "Common Annotations for the JavaTM Platform API",
            "scm": {
                "connection": "scm:git:https://github.com/javaee/javax.annotation.git",
                "url": "https://github.com/javaee/javax.annotation",
                "developerConnection": "scm:git:git@github.com:javaee/javax.annotation.git"
            },
            "name": "${extension.name} API",
            "website": "http://jcp.org/en/jsr/detail?id=250",
            "licenses": [
                "9be0c4d7964ad9a68deb2e9706266b8c"
            ],
            "organization": {
                "url": "https://javaee.github.io/glassfish",
                "name": "GlassFish Community"
            }
        },
        {
            "uniqueId": "javax.inject:javax.inject",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1",
            "description": "The javax.inject API",
            "scm": {
                "url": "http://code.google.com/p/atinject/source/checkout"
            },
            "name": "javax.inject",
            "website": "http://code.google.com/p/atinject/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "junit:junit",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "David Saff"
                },
                {
                    "name": "Kevin Cooney"
                },
                {
                    "name": "Stefan Birkner"
                },
                {
                    "name": "Marc Philipp"
                }
            ],
            "artifactVersion": "4.13.2",
            "description": "JUnit is a unit testing framework for Java, created by Erich Gamma and Kent Beck.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit4.git",
                "url": "https://github.com/junit-team/junit4",
                "developerConnection": "scm:git:git@github.com:junit-team/junit4.git"
            },
            "name": "JUnit",
            "website": "http://junit.org",
            "licenses": [
                "EPL-1.0"
            ],
            "organization": {
                "url": "http://www.junit.org",
                "name": "JUnit"
            }
        },
        {
            "uniqueId": "net.bytebuddy:byte-buddy",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.14.17",
            "description": "Byte Buddy is a Java library for creating Java classes at run time.\n        This artifact is a build of Byte Buddy with all ASM dependencies repackaged into its own name space.",
            "scm": {
                "connection": "scm:git:${repository.url}",
                "url": "${repository.url}",
                "developerConnection": "scm:git:${repository.url}"
            },
            "name": "Byte Buddy (without dependencies)",
            "website": "https://bytebuddy.net",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "net.bytebuddy:byte-buddy-agent",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.14.17",
            "description": "The Byte Buddy agent offers convenience for attaching an agent to the local or a remote VM.",
            "scm": {
                "connection": "scm:git:${repository.url}",
                "url": "${repository.url}",
                "developerConnection": "scm:git:${repository.url}"
            },
            "name": "Byte Buddy agent",
            "website": "https://bytebuddy.net",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.bouncycastle:bcprov-jdk18on",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Legion of the Bouncy Castle Inc."
                }
            ],
            "artifactVersion": "1.78.1",
            "description": "The Bouncy Castle Crypto package is a Java implementation of cryptographic algorithms. This jar contains JCE provider and lightweight API for the Bouncy Castle Cryptography APIs for JDK 1.8 and up.",
            "scm": {
                "url": "https://github.com/bcgit/bc-java"
            },
            "name": "Bouncy Castle Provider",
            "website": "https://www.bouncycastle.org/java.html",
            "licenses": [
                "73252b46f36df25ef51a7994de439aea"
            ]
        },
        {
            "uniqueId": "org.checkerframework:checker-qual",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.cs.washington.edu/",
                    "name": "Michael Ernst"
                },
                {
                    "organisationUrl": "https://www.cs.washington.edu/",
                    "name": "Suzanne Millstein"
                }
            ],
            "artifactVersion": "3.43.0",
            "description": "checker-qual contains annotations (type qualifiers) that a programmer\nwrites to specify Java code for type-checking by the Checker Framework.",
            "scm": {
                "connection": "scm:git:https://github.com/typetools/checker-framework.git",
                "url": "https://github.com/typetools/checker-framework.git",
                "developerConnection": "scm:git:ssh://git@github.com/typetools/checker-framework.git"
            },
            "name": "Checker Qual",
            "website": "https://checkerframework.org/",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.conscrypt:conscrypt-openjdk-uber",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.google.com",
                    "name": "Conscrypt Contributors"
                }
            ],
            "artifactVersion": "2.5.2",
            "description": "Conscrypt: OpenJdk UberJAR",
            "scm": {
                "connection": "scm:git:https://github.com/google/conscrypt.git",
                "url": "https://github.com/google/conscrypt",
                "developerConnection": "scm:git:git@github.com:google/conscrypt.git"
            },
            "name": "org.conscrypt:conscrypt-openjdk-uber",
            "website": "https://conscrypt.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.hamcrest:hamcrest-core",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.3",
            "description": "This is the core API of hamcrest matcher framework to be used by third-party framework providers. This includes the a foundation set of matcher implementations for common operations.",
            "scm": {
                "connection": "scm:git:git@github.com:hamcrest/JavaHamcrest.git",
                "url": "https://github.com/hamcrest/JavaHamcrest"
            },
            "name": "Hamcrest Core",
            "website": "https://github.com/hamcrest/JavaHamcrest",
            "licenses": [
                "BSD-3-Clause"
            ]
        },
        {
            "uniqueId": "org.hamcrest:hamcrest-integration",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.3",
            "description": "Provides integration between Hamcrest and other testing tools, including JUnit (3 and 4), TestNG, jMock and EasyMock.",
            "scm": {
                "connection": "scm:git:git@github.com:hamcrest/JavaHamcrest.git",
                "url": "https://github.com/hamcrest/JavaHamcrest"
            },
            "name": "Hamcrest Integration",
            "website": "https://github.com/hamcrest/JavaHamcrest",
            "licenses": [
                "BSD-3-Clause"
            ]
        },
        {
            "uniqueId": "org.hamcrest:hamcrest-library",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "1.3",
            "description": "Hamcrest library of matcher implementations.",
            "scm": {
                "connection": "scm:git:git@github.com:hamcrest/JavaHamcrest.git",
                "url": "https://github.com/hamcrest/JavaHamcrest"
            },
            "name": "Hamcrest library",
            "website": "https://github.com/hamcrest/JavaHamcrest",
            "licenses": [
                "BSD-3-Clause"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-android-extensions-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "Kotlin Team"
                }
            ],
            "artifactVersion": "1.9.22",
            "description": "Kotlin Android Extensions Runtime",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Kotlin Android Extensions Runtime",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-bom",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.8.22",
            "description": "Kotlin is a statically typed programming language that compiles to JVM byte codes and JavaScript",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Kotlin Libraries bill-of-materials",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-parcelize-runtime",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "Kotlin Team"
                }
            ],
            "artifactVersion": "1.9.22",
            "description": "Runtime library for the Parcelize compiler plugin",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Parcelize Runtime",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-reflect",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "Kotlin Team"
                }
            ],
            "artifactVersion": "2.0.0",
            "description": "Kotlin Full Reflection Library",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Kotlin Reflect",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-stdlib",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "Kotlin Team"
                }
            ],
            "artifactVersion": "2.1.10",
            "description": "Kotlin Standard Library",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Kotlin Stdlib",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-stdlib-jdk7",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "Kotlin Team"
                }
            ],
            "artifactVersion": "1.8.22",
            "description": "Kotlin Standard Library JDK 7 extension",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Kotlin Stdlib Jdk7",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlin:kotlin-stdlib-jdk8",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "Kotlin Team"
                }
            ],
            "artifactVersion": "1.8.22",
            "description": "Kotlin Standard Library JDK 8 extension",
            "scm": {
                "connection": "scm:git:https://github.com/JetBrains/kotlin.git",
                "url": "https://github.com/JetBrains/kotlin",
                "developerConnection": "scm:git:https://github.com/JetBrains/kotlin.git"
            },
            "name": "Kotlin Stdlib Jdk8",
            "website": "https://kotlinlang.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:atomicfu-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "0.23.2",
            "description": "AtomicFU utilities",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.atomicfu"
            },
            "name": "atomicfu",
            "website": "https://github.com/Kotlin/kotlinx.atomicfu",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-collections-immutable-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "0.3.8",
            "description": "Kotlin Immutable Collections multiplatform library",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.collections.immutable"
            },
            "name": "kotlinx-collections-immutable",
            "website": "https://github.com/Kotlin/kotlinx.collections.immutable",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-coroutines-android",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Coroutines support libraries for Kotlin",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.coroutines"
            },
            "name": "kotlinx-coroutines-android",
            "website": "https://github.com/Kotlin/kotlinx.coroutines",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-coroutines-bom",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Coroutines support libraries for Kotlin",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.coroutines"
            },
            "name": "kotlinx-coroutines-bom",
            "website": "https://github.com/Kotlin/kotlinx.coroutines",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Coroutines support libraries for Kotlin",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.coroutines"
            },
            "name": "kotlinx-coroutines-core",
            "website": "https://github.com/Kotlin/kotlinx.coroutines",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-coroutines-test-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.10.1",
            "description": "Coroutines support libraries for Kotlin",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.coroutines"
            },
            "name": "kotlinx-coroutines-test",
            "website": "https://github.com/Kotlin/kotlinx.coroutines",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-datetime-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "0.6.1",
            "description": "Kotlin Datetime Library",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx-datetime"
            },
            "name": "kotlinx-datetime",
            "website": "https://github.com/Kotlin/kotlinx-datetime",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-serialization-bom",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.8.0",
            "description": "Kotlin multiplatform serialization runtime library",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.serialization"
            },
            "name": "kotlinx-serialization-bom",
            "website": "https://github.com/Kotlin/kotlinx.serialization",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-serialization-core-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.8.0",
            "description": "Kotlin multiplatform serialization runtime library",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.serialization"
            },
            "name": "kotlinx-serialization-core",
            "website": "https://github.com/Kotlin/kotlinx.serialization",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains.kotlinx:kotlinx-serialization-json-jvm",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "1.8.0",
            "description": "Kotlin multiplatform serialization runtime library",
            "scm": {
                "url": "https://github.com/Kotlin/kotlinx.serialization"
            },
            "name": "kotlinx-serialization-json",
            "website": "https://github.com/Kotlin/kotlinx.serialization",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jetbrains:annotations",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "https://www.jetbrains.com",
                    "name": "JetBrains Team"
                }
            ],
            "artifactVersion": "23.0.0",
            "description": "A set of annotations used for code inspection support and code documentation.",
            "scm": {
                "connection": "scm:git:git://github.com/JetBrains/java-annotations.git",
                "url": "https://github.com/JetBrains/java-annotations",
                "developerConnection": "scm:git:ssh://github.com:JetBrains/java-annotations.git"
            },
            "name": "JetBrains Java Annotations",
            "website": "https://github.com/JetBrains/java-annotations",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.jspecify:jspecify",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Kevin Bourrillion"
                }
            ],
            "artifactVersion": "1.0.0",
            "description": "An artifact of well-named and well-specified annotations to power static analysis checks",
            "scm": {
                "connection": "scm:git:git@github.com:jspecify/jspecify.git",
                "url": "https://github.com/jspecify/jspecify/",
                "developerConnection": "scm:git:git@github.com:jspecify/jspecify.git"
            },
            "name": "JSpecify annotations",
            "website": "http://jspecify.org/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.junit.jupiter:junit-jupiter",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                },
                {
                    "name": "Christian Stein"
                },
                {
                    "name": "Juliette de Rancourt"
                }
            ],
            "artifactVersion": "5.8.2",
            "description": "Module \"junit-jupiter\" of JUnit 5.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit5.git",
                "url": "https://github.com/junit-team/junit5",
                "developerConnection": "scm:git:git://github.com/junit-team/junit5.git"
            },
            "name": "JUnit Jupiter (Aggregator)",
            "website": "https://junit.org/junit5/",
            "licenses": [
                "EPL-2.0"
            ]
        },
        {
            "uniqueId": "org.junit.jupiter:junit-jupiter-api",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                },
                {
                    "name": "Christian Stein"
                },
                {
                    "name": "Juliette de Rancourt"
                }
            ],
            "artifactVersion": "5.8.2",
            "description": "Module \"junit-jupiter-api\" of JUnit 5.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit5.git",
                "url": "https://github.com/junit-team/junit5",
                "developerConnection": "scm:git:git://github.com/junit-team/junit5.git"
            },
            "name": "JUnit Jupiter API",
            "website": "https://junit.org/junit5/",
            "licenses": [
                "EPL-2.0"
            ]
        },
        {
            "uniqueId": "org.junit.jupiter:junit-jupiter-engine",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                },
                {
                    "name": "Christian Stein"
                },
                {
                    "name": "Juliette de Rancourt"
                }
            ],
            "artifactVersion": "5.8.2",
            "description": "Module \"junit-jupiter-engine\" of JUnit 5.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit5.git",
                "url": "https://github.com/junit-team/junit5",
                "developerConnection": "scm:git:git://github.com/junit-team/junit5.git"
            },
            "name": "JUnit Jupiter Engine",
            "website": "https://junit.org/junit5/",
            "licenses": [
                "EPL-2.0"
            ]
        },
        {
            "uniqueId": "org.junit.jupiter:junit-jupiter-params",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                },
                {
                    "name": "Christian Stein"
                },
                {
                    "name": "Juliette de Rancourt"
                }
            ],
            "artifactVersion": "5.8.2",
            "description": "Module \"junit-jupiter-params\" of JUnit 5.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit5.git",
                "url": "https://github.com/junit-team/junit5",
                "developerConnection": "scm:git:git://github.com/junit-team/junit5.git"
            },
            "name": "JUnit Jupiter Params",
            "website": "https://junit.org/junit5/",
            "licenses": [
                "EPL-2.0"
            ]
        },
        {
            "uniqueId": "org.junit.platform:junit-platform-commons",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                },
                {
                    "name": "Christian Stein"
                },
                {
                    "name": "Juliette de Rancourt"
                }
            ],
            "artifactVersion": "1.8.2",
            "description": "Module \"junit-platform-commons\" of JUnit 5.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit5.git",
                "url": "https://github.com/junit-team/junit5",
                "developerConnection": "scm:git:git://github.com/junit-team/junit5.git"
            },
            "name": "JUnit Platform Commons",
            "website": "https://junit.org/junit5/",
            "licenses": [
                "EPL-2.0"
            ]
        },
        {
            "uniqueId": "org.junit.platform:junit-platform-engine",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                },
                {
                    "name": "Christian Stein"
                },
                {
                    "name": "Juliette de Rancourt"
                }
            ],
            "artifactVersion": "1.8.2",
            "description": "Module \"junit-platform-engine\" of JUnit 5.",
            "scm": {
                "connection": "scm:git:git://github.com/junit-team/junit5.git",
                "url": "https://github.com/junit-team/junit5",
                "developerConnection": "scm:git:git://github.com/junit-team/junit5.git"
            },
            "name": "JUnit Platform Engine API",
            "website": "https://junit.org/junit5/",
            "licenses": [
                "EPL-2.0"
            ]
        },
        {
            "uniqueId": "org.objenesis:objenesis",
            "funding": [
                
            ],
            "developers": [
                
            ],
            "artifactVersion": "3.3",
            "description": "A library for instantiating Java objects",
            "scm": {
                "connection": "scm:git:https://github.com/easymock/objenesis.git",
                "url": "https://github.com/easymock/objenesis",
                "developerConnection": "scm:git:git@github.com:easymock/objenesis.git"
            },
            "name": "Objenesis",
            "website": "http://objenesis.org",
            "licenses": [
                "Apache-2.0"
            ],
            "organization": {
                "name": "Joe Walnes, Henri Tremblay, Leonardo Mesquita"
            }
        },
        {
            "uniqueId": "org.opentest4j:opentest4j",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Stefan Bechtold"
                },
                {
                    "name": "Johannes Link"
                },
                {
                    "name": "Marc Philipp"
                },
                {
                    "name": "Matthias Merdes"
                },
                {
                    "name": "Sam Brannen"
                }
            ],
            "artifactVersion": "1.2.0",
            "description": "Open Test Alliance for the JVM",
            "scm": {
                "connection": "scm:git:git://github.com/ota4j-team/opentest4j.git",
                "url": "https://github.com/ota4j-team/opentest4j",
                "developerConnection": "scm:git:git://github.com/ota4j-team/opentest4j.git"
            },
            "name": "org.opentest4j:opentest4j",
            "website": "https://github.com/ota4j-team/opentest4j",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.ow2.asm:asm",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Eric Bruneton"
                },
                {
                    "name": "Eugene Kuleshov"
                },
                {
                    "name": "Remi Forax"
                }
            ],
            "artifactVersion": "9.7.1",
            "description": "ASM, a very small and fast Java bytecode manipulation framework",
            "scm": {
                "connection": "scm:git:https://gitlab.ow2.org/asm/asm/",
                "url": "https://gitlab.ow2.org/asm/asm/",
                "developerConnection": "scm:git:https://gitlab.ow2.org/asm/asm/"
            },
            "name": "asm",
            "website": "http://asm.ow2.io/",
            "licenses": [
                "BSD-3-Clause"
            ],
            "organization": {
                "url": "http://www.ow2.org/",
                "name": "OW2"
            }
        },
        {
            "uniqueId": "org.ow2.asm:asm-analysis",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Eric Bruneton"
                },
                {
                    "name": "Eugene Kuleshov"
                },
                {
                    "name": "Remi Forax"
                }
            ],
            "artifactVersion": "9.7.1",
            "description": "Static code analysis API of ASM, a very small and fast Java bytecode manipulation framework",
            "scm": {
                "connection": "scm:git:https://gitlab.ow2.org/asm/asm/",
                "url": "https://gitlab.ow2.org/asm/asm/",
                "developerConnection": "scm:git:https://gitlab.ow2.org/asm/asm/"
            },
            "name": "asm-analysis",
            "website": "http://asm.ow2.io/",
            "licenses": [
                "BSD-3-Clause"
            ],
            "organization": {
                "url": "http://www.ow2.org/",
                "name": "OW2"
            }
        },
        {
            "uniqueId": "org.ow2.asm:asm-commons",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Eric Bruneton"
                },
                {
                    "name": "Eugene Kuleshov"
                },
                {
                    "name": "Remi Forax"
                }
            ],
            "artifactVersion": "9.7.1",
            "description": "Usefull class adapters based on ASM, a very small and fast Java bytecode manipulation framework",
            "scm": {
                "connection": "scm:git:https://gitlab.ow2.org/asm/asm/",
                "url": "https://gitlab.ow2.org/asm/asm/",
                "developerConnection": "scm:git:https://gitlab.ow2.org/asm/asm/"
            },
            "name": "asm-commons",
            "website": "http://asm.ow2.io/",
            "licenses": [
                "BSD-3-Clause"
            ],
            "organization": {
                "url": "http://www.ow2.org/",
                "name": "OW2"
            }
        },
        {
            "uniqueId": "org.ow2.asm:asm-tree",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Eric Bruneton"
                },
                {
                    "name": "Eugene Kuleshov"
                },
                {
                    "name": "Remi Forax"
                }
            ],
            "artifactVersion": "9.7.1",
            "description": "Tree API of ASM, a very small and fast Java bytecode manipulation framework",
            "scm": {
                "connection": "scm:git:https://gitlab.ow2.org/asm/asm/",
                "url": "https://gitlab.ow2.org/asm/asm/",
                "developerConnection": "scm:git:https://gitlab.ow2.org/asm/asm/"
            },
            "name": "asm-tree",
            "website": "http://asm.ow2.io/",
            "licenses": [
                "BSD-3-Clause"
            ],
            "organization": {
                "url": "http://www.ow2.org/",
                "name": "OW2"
            }
        },
        {
            "uniqueId": "org.ow2.asm:asm-util",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Eric Bruneton"
                },
                {
                    "name": "Eugene Kuleshov"
                },
                {
                    "name": "Remi Forax"
                }
            ],
            "artifactVersion": "9.7.1",
            "description": "Utilities for ASM, a very small and fast Java bytecode manipulation framework",
            "scm": {
                "connection": "scm:git:https://gitlab.ow2.org/asm/asm/",
                "url": "https://gitlab.ow2.org/asm/asm/",
                "developerConnection": "scm:git:https://gitlab.ow2.org/asm/asm/"
            },
            "name": "asm-util",
            "website": "http://asm.ow2.io/",
            "licenses": [
                "BSD-3-Clause"
            ],
            "organization": {
                "url": "http://www.ow2.org/",
                "name": "OW2"
            }
        },
        {
            "uniqueId": "org.robolectric:annotations",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "annotations",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:junit",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "junit",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:nativeruntime",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "nativeruntime",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:nativeruntime-dist-compat",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "The Android Open Source Projects"
                }
            ],
            "artifactVersion": "1.0.16",
            "description": "Robolectric Nativeruntime Distribution Compat",
            "scm": {
                "connection": "https://android.googlesource.com/platform/manifest.git",
                "url": "https://android.googlesource.com/platform/manifest.git"
            },
            "name": "Robolectric Nativeruntime Distribution Compat",
            "website": "https://source.android.com/",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "org.robolectric:pluginapi",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "pluginapi",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:plugins-maven-dependency-resolver",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "maven-dependency-resolver",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:resources",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "resources",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:robolectric",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "robolectric",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:sandbox",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "sandbox",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:shadowapi",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "shadowapi",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:shadows-framework",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "framework",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:utils",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "utils",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.robolectric:utils-reflector",
            "funding": [
                
            ],
            "developers": [
                {
                    "organisationUrl": "http://google.com",
                    "name": "Brett Chabot"
                },
                {
                    "organisationUrl": "http://google.com",
                    "name": "Michael Hoisie"
                },
                {
                    "name": "Christian Williams"
                }
            ],
            "artifactVersion": "4.14",
            "description": "An alternative Android testing framework.",
            "scm": {
                "connection": "scm:git:git://github.com/robolectric/robolectric.git",
                "url": "git@github.com:robolectric/robolectric.git",
                "developerConnection": "scm:git:https://github.com/robolectric/robolectric.git"
            },
            "name": "reflector",
            "website": "http://robolectric.org",
            "licenses": [
                "MIT"
            ]
        },
        {
            "uniqueId": "org.yaml:snakeyaml",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Andrey Somov"
                },
                {
                    "name": "Alexander Maslov"
                }
            ],
            "artifactVersion": "2.3",
            "description": "YAML 1.1 parser and emitter for Java",
            "scm": {
                "connection": "scm:git:http://bitbucket.org/snakeyaml/snakeyaml",
                "url": "https://bitbucket.org/snakeyaml/snakeyaml/src",
                "developerConnection": "scm:git:ssh://git@bitbucket.org/snakeyaml/snakeyaml"
            },
            "name": "SnakeYAML",
            "website": "https://bitbucket.org/snakeyaml/snakeyaml",
            "licenses": [
                "Apache-2.0"
            ]
        },
        {
            "uniqueId": "sakura.css",
            "funding": [
                
            ],
            "developers": [
                {
                    "name": "Mitesh Shah"
                }
            ],
            "artifactVersion": "1.5.0",
            "description": "a minimal css framework/theme",
            "name": "Sakura.css",
            "licenses": [
                "MIT"
            ]
        }
    ],
    "licenses": {
        "5be2dcb917a8d00d01258ff45d1f55b2": {
            "hash": "5be2dcb917a8d00d01258ff45d1f55b2",
            "url": "https://raw.githubusercontent.com/unicode-org/icu/main/LICENSE",
            "name": "Unicode-3.0"
        },
        "73252b46f36df25ef51a7994de439aea": {
            "hash": "73252b46f36df25ef51a7994de439aea",
            "url": "https://www.bouncycastle.org/licence.html",
            "name": "Bouncy Castle Licence"
        },
        "9be0c4d7964ad9a68deb2e9706266b8c": {
            "hash": "9be0c4d7964ad9a68deb2e9706266b8c",
            "url": "https://github.com/javaee/javax.annotation/blob/master/LICENSE",
            "name": "CDDL + GPLv2 with classpath exception"
        },
        "Apache-2.0": {
            "content": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n\n     (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n\n     (b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n\n     (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n\n     (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\n\n     You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work.\n\nTo apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!)  The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives.\n\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.",
            "hash": "Apache-2.0",
            "internalHash": "Apache-2.0",
            "url": "https://spdx.org/licenses/Apache-2.0.html",
            "spdxId": "Apache-2.0",
            "name": "Apache License 2.0"
        },
        "BSD-3-Clause": {
            "content": "Copyright (c) <<var;name=copyright;original= <year> <owner>;match=.+>>. All rights reserved. \n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. \n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. \n\n3. Neither the name of <<var;name=organizationClause3;original=the copyright holder;match=.+>> nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY <<var;name=copyrightHolderAsIs;original=THE COPYRIGHT HOLDERS AND CONTRIBUTORS;match=.+>> \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <<var;name=copyrightHolderLiability;original=THE COPYRIGHT HOLDER OR CONTRIBUTORS;match=.+>> BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ",
            "hash": "BSD-3-Clause",
            "internalHash": "BSD-3-Clause",
            "url": "https://spdx.org/licenses/BSD-3-Clause.html",
            "spdxId": "BSD-3-Clause",
            "name": "BSD 3-Clause \"New\" or \"Revised\" License"
        },
        "EPL-1.0": {
            "content": "Eclipse Public License - v 1.0\n\nTHE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE (\"AGREEMENT\"). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.\n\n1. DEFINITIONS\n\n\"Contribution\" means:\n     a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and\n     b) in the case of each subsequent Contributor:\n          i) changes to the Program, and\n          ii) additions to the Program;\n\nwhere such changes and/or additions to the Program originate from and are distributed by that particular Contributor. A Contribution 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf. Contributions do not include additions to the Program which: (i) are separate modules of software distributed in conjunction with the Program under their own license agreement, and (ii) are not derivative works of the Program.\n\"Contributor\" means any person or entity that distributes the Program.\n\n\"Licensed Patents\" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone or when combined with the Program.\n\n\"Program\" means the Contributions distributed in accordance with this Agreement.\n\n\"Recipient\" means anyone who receives the Program under this Agreement, including all Contributors.\n\n2. GRANT OF RIGHTS\n\n     a) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor, if any, and such derivative works, in source code and object code form.\n \n     b) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source code and object code form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.\n\n     c) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise. As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to distribute the Program, it is Recipient's responsibility to acquire that license before distributing the Program.\n\n     d) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright license set forth in this Agreement.\n\n3. REQUIREMENTS\nA Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:\n\n     a) it complies with the terms and conditions of this Agreement; and\n \n     b) its license agreement:\n          i) effectively disclaims on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;\n          ii) effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and consequential damages, such as lost profits;\n          iii) states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and\n          iv) states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner on or through a medium customarily used for software exchange.\n\nWhen the Program is made available in source code form:\n\n     a) it must be made available under this Agreement; and\n\n     b) a copy of this Agreement must be included with each copy of the Program.\nContributors may not remove or alter any copyright notices contained within the Program.\n\nEach Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients to identify the originator of the Contribution.\n\n4. COMMERCIAL DISTRIBUTION\nCommercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in a commercial product offering, such Contributor (\"Commercial Contributor\") hereby agrees to defend and indemnify every other Contributor (\"Indemnified Contributor\") against any losses, damages and costs (collectively \"Losses\") arising from claims, lawsuits and other legal actions brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or Losses relating to any actual or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim at its own expense.\n\nFor example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay any damages as a result, the Commercial Contributor must pay those damages.\n\n5. NO WARRANTY\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and assumes all risks associated with its exercise of rights under this Agreement , including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.\n\n6. DISCLAIMER OF LIABILITY\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n7. GENERAL\n\nIf any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.\n\nIf Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's rights granted under Section 2(b) shall terminate as of the date such litigation is filed.\n\nAll Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However, Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.\n\nEveryone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is published, Contributor may elect to distribute the Program (including its Contributions) under the new version. Except as expressly stated in Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement, whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved.\n\nThis Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose. Each party waives its rights to a jury trial in any resulting litigation.",
            "hash": "EPL-1.0",
            "internalHash": "EPL-1.0",
            "url": "https://spdx.org/licenses/EPL-1.0.html",
            "spdxId": "EPL-1.0",
            "name": "Eclipse Public License 1.0"
        },
        "EPL-2.0": {
            "content": "Eclipse Public License - v 2.0\nTHE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE (\u201cAGREEMENT\u201d). ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.\n\n1. DEFINITIONS\n\u201cContribution\u201d means:\n\na) in the case of the initial Contributor, the initial content Distributed under this Agreement, and\nb) in the case of each subsequent Contributor:\ni) changes to the Program, and\nii) additions to the Program;\nwhere such changes and/or additions to the Program originate from and are Distributed by that particular Contributor. A Contribution \u201coriginates\u201d from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf. Contributions do not include changes or additions to the Program that are not Modified Works.\n\u201cContributor\u201d means any person or entity that Distributes the Program.\n\n\u201cLicensed Patents\u201d mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone or when combined with the Program.\n\n\u201cProgram\u201d means the Contributions Distributed in accordance with this Agreement.\n\n\u201cRecipient\u201d means anyone who receives the Program under this Agreement or any Secondary License (as applicable), including Contributors.\n\n\u201cDerivative Works\u201d shall mean any work, whether in Source Code or other form, that is based on (or derived from) the Program and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship.\n\n\u201cModified Works\u201d shall mean any work in Source Code or other form that results from an addition to, deletion from, or modification of the contents of the Program, including, for purposes of clarity any new file in Source Code form that contains any contents of the Program. Modified Works shall not include works that contain only declarations, interfaces, types, classes, structures, or files of the Program solely in each case in order to link to, bind by name, or subclass the Program or Modified Works thereof.\n\n\u201cDistribute\u201d means the acts of a) distributing or b) making available in any manner that enables the transfer of a copy.\n\n\u201cSource Code\u201d means the form of a Program preferred for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\n\u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, or any later versions of that license, including any exceptions or additional permissions as identified by the initial Contributor.\n\n2. GRANT OF RIGHTS\na) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, Distribute and sublicense the Contribution of such Contributor, if any, and such Derivative Works.\nb) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in Source Code or other form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.\nc) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise. As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to Distribute the Program, it is Recipient's responsibility to acquire that license before distributing the Program.\nd) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright license set forth in this Agreement.\ne) Notwithstanding the terms of any Secondary License, no Contributor makes additional grants to any Recipient (other than those set forth in this Agreement) as a result of such Recipient's receipt of the Program under the terms of a Secondary License (if permitted under the terms of Section 3).\n3. REQUIREMENTS\n3.1 If a Contributor Distributes the Program in any form, then:\n\na) the Program must also be made available as Source Code, in accordance with section 3.2, and the Contributor must accompany the Program with a statement that the Source Code for the Program is available under this Agreement, and informs Recipients how to obtain it in a reasonable manner on or through a medium customarily used for software exchange; and\nb) the Contributor may Distribute the Program under a license different than this Agreement, provided that such license:\ni) effectively disclaims on behalf of all other Contributors all warranties and conditions, express and implied, including warranties or conditions of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;\nii) effectively excludes on behalf of all other Contributors all liability for damages, including direct, indirect, special, incidental and consequential damages, such as lost profits;\niii) does not attempt to limit or alter the recipients' rights in the Source Code under section 3.2; and\niv) requires any subsequent distribution of the Program by any party to be under a license that satisfies the requirements of this section 3.\n3.2 When the Program is Distributed as Source Code:\n\na) it must be made available under this Agreement, or if the Program (i) is combined with other material in a separate file or files made available under a Secondary License, and (ii) the initial Contributor attached to the Source Code the notice described in Exhibit A of this Agreement, then the Program may be made available under the terms of such Secondary Licenses, and\nb) a copy of this Agreement must be included with each copy of the Program.\n3.3 Contributors may not remove or alter any copyright, patent, trademark, attribution notices, disclaimers of warranty, or limitations of liability (\u2018notices\u2019) contained within the Program from any copy of the Program which they Distribute, provided that Contributors may add their own appropriate notices.\n\n4. COMMERCIAL DISTRIBUTION\nCommercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in a commercial product offering, such Contributor (\u201cCommercial Contributor\u201d) hereby agrees to defend and indemnify every other Contributor (\u201cIndemnified Contributor\u201d) against any losses, damages and costs (collectively \u201cLosses\u201d) arising from claims, lawsuits and other legal actions brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or Losses relating to any actual or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim at its own expense.\n\nFor example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay any damages as a result, the Commercial Contributor must pay those damages.\n\n5. NO WARRANTY\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and assumes all risks associated with its exercise of rights under this Agreement, including but not limited to the risks and costs of program errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.\n\n6. DISCLAIMER OF LIABILITY\nEXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT PERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n7. GENERAL\nIf any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.\n\nIf Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's rights granted under Section 2(b) shall terminate as of the date such litigation is filed.\n\nAll Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However, Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.\n\nEveryone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be Distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is published, Contributor may elect to Distribute the Program (including its Contributions) under the new version.\n\nExcept as expressly stated in Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement, whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved. Nothing in this Agreement is intended to be enforceable by any entity that is not a Contributor or Recipient. No third-party beneficiary rights are created under this Agreement.\n\nExhibit A \u2013 Form of Secondary Licenses Notice\n\u201cThis Source Code may also be made available under the following Secondary Licenses when the conditions for such availability set forth in the Eclipse Public License, v. 2.0 are satisfied: {name license(s), version(s), and exceptions or additional permissions here}.\u201d\n\nSimply including a copy of this Agreement, including this Exhibit A is not sufficient to license the Source Code under Secondary Licenses.\n\nIf it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice.\n\nYou may add additional accurate notices of copyright ownership.",
            "hash": "EPL-2.0",
            "internalHash": "EPL-2.0",
            "url": "epl_2_0",
            "spdxId": "EPL-2.0",
            "name": "Eclipse Public License 2.0"
        },
        "MIT": {
            "content": "MIT License\n\nCopyright (c) <year> <copyright holders>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "hash": "MIT",
            "internalHash": "MIT",
            "url": "https://spdx.org/licenses/MIT.html",
            "spdxId": "MIT",
            "name": "MIT License"
        }
    }
}
</file>

<file path="app/src/main/res/values/colors.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>
</file>

<file path="app/src/main/res/values/dimens.xml">
<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
</resources>
</file>

<file path="app/src/main/res/values/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#064C5C</color>
</resources>
</file>

<file path="app/src/main/res/values/themes.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Theme.MyDeck" parent="android:Theme.Material.Light.NoActionBar" />
</resources>
</file>

<file path="app/src/main/res/xml/backup_rules.xml">
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>
</file>

<file path="app/src/main/res/xml/data_extraction_rules.xml">
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>
</file>

<file path="app/src/main/res/xml/filepaths.xml">
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <files-path name="logs" path="logs/"/>
</paths>
</file>

<file path="app/src/main/res/xml/network_security_config.xml">
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>
</file>

<file path="app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.mydeck.app">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>

    <application
        android:name=".MyDeckApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:networkSecurityConfig="@xml/network_security_config"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.MyDeck"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.MyDeck">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/plain" />
            </intent-filter>
        </activity>
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths" />
        </provider>
        <provider
            android:name="androidx.startup.InitializationProvider"
            android:authorities="${applicationId}.androidx-startup"
            android:exported="false"
            tools:node="merge">
            <!-- disable default -->
            <meta-data
                android:name="androidx.work.WorkManagerInitializer"
                android:value="@string/androidx_startup"
                tools:node="remove" />
            <!-- enable custom -->
            <meta-data
                android:name="com.mydeck.app.worker.CustomWorkManagerInitializer"
                android:value="androidx.startup" />
        </provider>
    </application>
</manifest>
</file>

<file path="app/src/test/java/com/mydeck/app/domain/UserRepositoryImplTest.kt">
package com.mydeck.app.domain

import com.mydeck.app.domain.model.AuthenticationDetails
import com.mydeck.app.domain.model.User
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.io.rest.ReadeckApi
import com.mydeck.app.io.rest.model.AuthenticationRequestDto
import com.mydeck.app.io.rest.model.AuthenticationResponseDto
import com.mydeck.app.io.rest.model.StatusMessageDto
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import kotlinx.serialization.json.Json
import okhttp3.ResponseBody.Companion.toResponseBody
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Before
import org.junit.Test
import retrofit2.Response
import java.io.IOException

@OptIn(ExperimentalCoroutinesApi::class)
class UserRepositoryImplTest {

    private lateinit var settingsDataStore: SettingsDataStore
    private lateinit var readeckApi: ReadeckApi
    private lateinit var json: Json
    private lateinit var userRepository: UserRepositoryImpl

    // MutableStateFlows for testing
    private lateinit var urlFlow: MutableStateFlow<String?>
    private lateinit var usernameFlow: MutableStateFlow<String?>
    private lateinit var passwordFlow: MutableStateFlow<String?>
    private lateinit var tokenFlow: MutableStateFlow<String?>

    @Before
    fun setup() {
        Dispatchers.setMain(Dispatchers.Unconfined) // Use Unconfined for immediate execution
        settingsDataStore = mockk(relaxed = true) // relaxed = true to avoid specifying every method
        readeckApi = mockk()
        json = Json { ignoreUnknownKeys = true }

        // Initialize MutableStateFlows
        urlFlow = MutableStateFlow(null)
        usernameFlow = MutableStateFlow(null)
        passwordFlow = MutableStateFlow(null)
        tokenFlow = MutableStateFlow(null)

        // Mock SettingsDataStore to return the MutableStateFlows
        every { settingsDataStore.urlFlow } returns urlFlow
        every { settingsDataStore.usernameFlow } returns usernameFlow
        every { settingsDataStore.passwordFlow } returns passwordFlow
        every { settingsDataStore.tokenFlow } returns tokenFlow

        userRepository = UserRepositoryImpl(settingsDataStore, readeckApi, json)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `observeAuthenticationDetails returns AuthenticationDetails when all data is available`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val token = "testtoken"

        // Emit values to the MutableStateFlows
        urlFlow.value = url
        usernameFlow.value = username
        passwordFlow.value = password
        tokenFlow.value = token

        // Act
        val result = userRepository.observeAuthenticationDetails().first()

        // Assert
        assertEquals(AuthenticationDetails(url, username, password, token), result)
    }

    @Test
    fun `observeAuthenticationDetails returns null when any data is missing`() = runTest {
        // Arrange
        urlFlow.value = "https://example.com"
        usernameFlow.value = "testuser"
        passwordFlow.value = null // Missing password
        tokenFlow.value = "testtoken"

        // Act
        val result = userRepository.observeAuthenticationDetails().first()

        // Assert
        assertNull(result)
    }

    @Test
    fun `login with username and password returns Success on successful response`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val token = "testtoken"
        val authenticationResponseDto = AuthenticationResponseDto("id", token)

        coEvery { readeckApi.authenticate(AuthenticationRequestDto(username, password, "readeck-app")) } returns Response.success(authenticationResponseDto)

        // Act
        val result = userRepository.login(url, username, password)

        // Assert
        assertEquals(UserRepository.LoginResult.Success, result)
        coVerify { settingsDataStore.saveCredentials(url, username, password, token) }
    }

    @Test
    fun `login with username and password returns Error on unsuccessful response with error body`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val errorMessage = "Invalid credentials"
        val errorCode = 401
        val errorBody = StatusMessageDto(errorCode, errorMessage)
        val errorResponse = Response.error<AuthenticationResponseDto>(errorCode, json.encodeToString(StatusMessageDto.serializer(), errorBody).toResponseBody(null))

        coEvery { readeckApi.authenticate(AuthenticationRequestDto(username, password, "readeck-app")) } returns errorResponse

        // Act
        val result = userRepository.login(url, username, password)

        // Assert
        assertEquals(UserRepository.LoginResult.Error(errorMessage, errorCode), result)
        coVerify { settingsDataStore.clearCredentials() }
    }

    @Test
    fun `login with username and password returns Error on unsuccessful response with empty error body`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val errorCode = 401
        val errorResponse = Response.error<AuthenticationResponseDto>(errorCode, "".toResponseBody(null))

        coEvery { readeckApi.authenticate(AuthenticationRequestDto(username, password, "readeck-app")) } returns errorResponse

        // Act
        val result = userRepository.login(url, username, password)

        // Assert
        assertEquals(UserRepository.LoginResult.Error("Empty error body", errorCode), result)
        coVerify { settingsDataStore.clearCredentials() }
    }

    @Test
    fun `login with username and password returns Error on unsuccessful response with malformed error body`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val errorCode = 401
        val errorResponse = Response.error<AuthenticationResponseDto>(errorCode, "<html><body><h1>Error</h1></body></html>".toResponseBody(null))

        coEvery { readeckApi.authenticate(AuthenticationRequestDto(username, password, "readeck-app")) } returns errorResponse

        // Act
        val result = userRepository.login(url, username, password)

        // Assert
        assert(result is UserRepository.LoginResult.Error)
        assert((result as UserRepository.LoginResult.Error).errorMessage.startsWith("Failed to parse error"))
        coVerify { settingsDataStore.clearCredentials() }
    }

    @Test
    fun `login with username and password returns Error on IOException`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val errorMessage = "Network error"
        coEvery { readeckApi.authenticate(AuthenticationRequestDto(username, password, "readeck-app")) } throws IOException(errorMessage)

        // Act
        val result = userRepository.login(url, username, password)

        // Assert
        assert(result is UserRepository.LoginResult.Error)
        assert((result as UserRepository.LoginResult.Error).errorMessage.startsWith("Network error"))
        coVerify { settingsDataStore.clearCredentials() }
    }

    @Test
    fun `login with username and password returns Error on generic Exception`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val errorMessage = "Generic error"
        coEvery { readeckApi.authenticate(AuthenticationRequestDto(username, password, "readeck-app")) } throws Exception(errorMessage)

        // Act
        val result = userRepository.login(url, username, password)

        // Assert
        assert(result is UserRepository.LoginResult.Error)
        assert((result as UserRepository.LoginResult.Error).errorMessage.startsWith("An unexpected error occurred"))
        coVerify { settingsDataStore.clearCredentials() }
    }

    @Test
    fun `observeIsLoggedIn returns true when AuthenticationDetails is not null`() = runTest {
        // Arrange
        val url = "https://example.com"
        val username = "testuser"
        val password = "testpassword"
        val token = "testtoken"

        // Emit values to the MutableStateFlows
        urlFlow.value = url
        usernameFlow.value = username
        passwordFlow.value = password
        tokenFlow.value = token

        // Act
        val result = userRepository.observeIsLoggedIn().first()

        // Assert
        assertEquals(true, result)
    }

    @Test
    fun `observeIsLoggedIn returns false when AuthenticationDetails is null`() = runTest {
        // Arrange
        urlFlow.value = "https://example.com"
        usernameFlow.value = "testuser"
        passwordFlow.value = null
        tokenFlow.value = "testtoken"

        // Act
        val result = userRepository.observeIsLoggedIn().first()

        // Assert
        assertEquals(false, result)
    }

    @Test
    fun `observeUser returns User when AuthenticationDetails is not null`() = runTest {
        // Arrange
        val username = "testuser"
        val url = "https://example.com"
        val password = "testpassword"
        val token = "testtoken"

        // Emit values to the MutableStateFlows
        urlFlow.value = url
        usernameFlow.value = username
        passwordFlow.value = password
        tokenFlow.value = token

        // Act
        val result = userRepository.observeUser().first()

        // Assert
        assertEquals(User(username), result)
    }

    @Test
    fun `observeUser returns null when AuthenticationDetails is null`() = runTest {
        // Arrange
        urlFlow.value = "https://example.com"
        usernameFlow.value = "testuser"
        passwordFlow.value = null
        tokenFlow.value = "testtoken"

        // Act
        val result = userRepository.observeUser().first()

        // Assert
        assertNull(result)
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/io/db/MyDeckDatabaseMigrationTest.kt">
package com.mydeck.app.io.db

import android.content.ContentValues
import android.database.DatabaseUtils
import androidx.room.migration.AutoMigrationSpec
import androidx.room.testing.MigrationTestHelper
import androidx.sqlite.db.framework.FrameworkSQLiteOpenHelperFactory
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotEquals
import org.junit.Assert.assertTrue
import org.junit.Test
import org.junit.runner.RunWith
import java.io.IOException

@RunWith(AndroidJUnit4::class)
class MyDeckDatabaseMigrationTest {
    private val TEST_DB = "migration-test"

    @Test
    @Throws(IOException::class)
    fun migrate1To2() {
        val helper = MigrationTestHelper(
            InstrumentationRegistry.getInstrumentation(),
            MyDeckDatabase::class.java,
            emptyList<AutoMigrationSpec>(), // workaround for https://issuetracker.google.com/issues/298459978
            FrameworkSQLiteOpenHelperFactory()
        )
        val db = helper.createDatabase(TEST_DB, 1).apply {
            execSQL(
                """
                INSERT INTO bookmarks (
                    id,
                    href,
                    created,
                    updated,
                    state,
                    loaded,
                    url,
                    title,
                    siteName,
                    site,
                    authors,
                    lang,
                    textDirection,
                    documentTpe,
                    type,
                    hasArticle,
                    description,
                    isDeleted,
                    isMarked,
                    isArchived,
                    labels,
                    readProgress,
                    wordCount,
                    readingTime,
                    article_src,
                    icon_src,
                    icon_width,
                    icon_height,
                    image_src,
                    image_width,
                    image_height,
                    log_src,
                    props_src,
                    thumbnail_src,
                    thumbnail_width,
                    thumbnail_height,
                    articleContent
                ) VALUES (
                    'id1',
                    'test-href',
                    1672531200000,
                    1672531200000,
                    0,
                    1,
                    'test-url',
                    'test-title',
                    'test-siteName',
                    'test-site',
                    'test-authors',
                    'test-lang',
                    'test-textDirection',
                    'test-documentTpe',
                    'article',
                    1,
                    'test-description',
                    0,
                    0,
                    0,
                    'test-labels',
                    50,
                    100,
                    5,
                    'test-article_src',
                    'test-icon_src',
                    50,
                    50,
                    'test-image_src',
                    200,
                    100,
                    'test-log_src',
                    'test-props_src',
                    'test-thumbnail_src',
                    100,
                    100,
                    'test-articleContent'
                )
                """
            )
            execSQL(
            """
                INSERT INTO bookmarks (
                    id,
                    href,
                    created,
                    updated,
                    state,
                    loaded,
                    url,
                    title,
                    siteName,
                    site,
                    authors,
                    lang,
                    textDirection,
                    documentTpe,
                    type,
                    hasArticle,
                    description,
                    isDeleted,
                    isMarked,
                    isArchived,
                    labels,
                    readProgress,
                    wordCount,
                    readingTime,
                    article_src,
                    icon_src,
                    icon_width,
                    icon_height,
                    image_src,
                    image_width,
                    image_height,
                    log_src,
                    props_src,
                    thumbnail_src,
                    thumbnail_width,
                    thumbnail_height,
                    articleContent
                ) VALUES (
                    'id2',
                    'test-href',
                    1672531200000,
                    1672531200000,
                    0,
                    1,
                    'test-url',
                    'test-title',
                    'test-siteName',
                    'test-site',
                    'test-authors',
                    'test-lang',
                    'test-textDirection',
                    'test-documentTpe',
                    'video',
                    1,
                    'test-description',
                    0,
                    0,
                    0,
                    'test-labels',
                    50,
                    100,
                    5,
                    'test-article_src',
                    'test-icon_src',
                    50,
                    50,
                    'test-image_src',
                    200,
                    100,
                    'test-log_src',
                    'test-props_src',
                    'test-thumbnail_src',
                    100,
                    100,
                    null
                )
                """
            )
            execSQL(
                """
                INSERT INTO bookmarks (
                    id,
                    href,
                    created,
                    updated,
                    state,
                    loaded,
                    url,
                    title,
                    siteName,
                    site,
                    authors,
                    lang,
                    textDirection,
                    documentTpe,
                    type,
                    hasArticle,
                    description,
                    isDeleted,
                    isMarked,
                    isArchived,
                    labels,
                    readProgress,
                    wordCount,
                    readingTime,
                    article_src,
                    icon_src,
                    icon_width,
                    icon_height,
                    image_src,
                    image_width,
                    image_height,
                    log_src,
                    props_src,
                    thumbnail_src,
                    thumbnail_width,
                    thumbnail_height,
                    articleContent
                ) VALUES (
                    'id3',
                    'test-href',
                    1672531200000,
                    1672531200000,
                    0,
                    1,
                    'test-url',
                    'test-title',
                    'test-siteName',
                    'test-site',
                    'test-authors',
                    'test-lang',
                    'test-textDirection',
                    'test-documentTpe',
                    'photo',
                    1,
                    'test-description',
                    0,
                    0,
                    0,
                    'test-labels',
                    50,
                    100,
                    5,
                    'test-article_src',
                    'test-icon_src',
                    50,
                    50,
                    'test-image_src',
                    200,
                    100,
                    'test-log_src',
                    'test-props_src',
                    'test-thumbnail_src',
                    100,
                    100,
                    null
                )
                """
            )
            close()
        }

        val dbV2 = helper.runMigrationsAndValidate(TEST_DB, 2, true, MyDeckDatabase.MIGRATION_1_2)

        val cursor = dbV2.query("SELECT content FROM article_content WHERE bookmarkId = 'id1'")
        try {
            assertTrue(cursor.moveToFirst())
            val content = cursor.getString(0)
            cursor.close()
            assertTrue(content == "test-articleContent")
        } finally {
            cursor.close()
        }

        var cursor2 = dbV2.query("PRAGMA table_info('bookmarks')")
        try {
            while (cursor2.moveToNext()) {
                var contentValues = ContentValues()
                DatabaseUtils.cursorRowToContentValues(cursor2, contentValues)
                assertNotEquals("articleContent", contentValues.get("name"))
                println("$contentValues")
            }
        } finally {
            cursor2.close()
        }
        dbV2.close()
        db.close()
    }

    @Test
    @Throws(IOException::class)
    fun migrate2To3() {
        val helper = MigrationTestHelper(
            InstrumentationRegistry.getInstrumentation(),
            MyDeckDatabase::class.java,
            emptyList<AutoMigrationSpec>(), // workaround for https://issuetracker.google.com/issues/298459978
            FrameworkSQLiteOpenHelperFactory()
        )
        val db = helper.createDatabase(TEST_DB, 2)

        val dbV3 = helper.runMigrationsAndValidate(TEST_DB, 3, true, MyDeckDatabase.MIGRATION_2_3)

        var cursor = dbV3.query("PRAGMA table_info('remote_bookmark_ids')")
        try {
            cursor.moveToFirst()
            var contentValues = ContentValues()
            DatabaseUtils.cursorRowToContentValues(cursor, contentValues)
            assertEquals("id", contentValues.get("name"))
            println("$contentValues")
        } finally {
            cursor.close()
        }
        dbV3.close()
        db.close()
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/io/rest/ReadeckApiTest.kt">
package com.mydeck.app.io.rest

import com.mydeck.app.io.rest.auth.AuthInterceptor
import com.mydeck.app.io.rest.auth.NotificationHelper
import com.mydeck.app.io.rest.auth.TokenManager
import com.mydeck.app.io.rest.model.AuthenticationRequestDto
import com.mydeck.app.io.rest.model.EditBookmarkDto
import com.mydeck.app.io.rest.model.EditBookmarkErrorDto
import com.mydeck.app.io.rest.model.StatusMessageDto
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.MockWebServer
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import retrofit2.Retrofit
import retrofit2.converter.kotlinx.serialization.asConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.create
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection

class ReadeckApiTest {
    private lateinit var mockWebServer: MockWebServer
    val tokenManager = mockk<TokenManager>()
    val notificationHelper = mockk<NotificationHelper>()
    val authInterceptor = AuthInterceptor(tokenManager, notificationHelper)
    val loggingInterceptor =
        HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }
    val okHttpClient = OkHttpClient.Builder()
        .addInterceptor(authInterceptor)
        .addInterceptor(loggingInterceptor)
        .build()
    lateinit var retrofit: Retrofit
    lateinit var readeckApi: ReadeckApi

    @Before
    fun setup() {
        mockWebServer = MockWebServer()
        mockWebServer.start()
        val mediaType = "application/json; charset=UTF8".toMediaType()
        retrofit = Retrofit.Builder()
            .baseUrl(mockWebServer.url("/"))
            .client(okHttpClient)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(Json.asConverterFactory(mediaType))
            .build()

        readeckApi = retrofit.create()

        every { tokenManager.getToken() } returns "mockToken"
    }

    @After
    fun tearDown() {
        mockWebServer.shutdown()
    }

    @Test
    fun testSuccessfulAuthentication() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_OK)
            .addHeader("Content-Type", "application/json")
            .setBody(loadJsonFromClasspath("api/auth.json"))
        )
        val response = readeckApi.authenticate(AuthenticationRequestDto("test", "test", "test"))
        assertEquals(true, response.isSuccessful)
        assertEquals(200, response.code())
        assertEquals("theId", response.body()?.id)
        assertEquals("theToken", response.body()?.token)
    }

    @Test
    fun testFailedAuthentication() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_FORBIDDEN)
            .addHeader("Content-Type", "application/json")
            .setBody(loadJsonFromClasspath("api/auth-failure.json"))
        )
        val response = readeckApi.authenticate(AuthenticationRequestDto("test", "test", "test"))
        assertEquals(false, response.isSuccessful)
        assertEquals(403, response.code())
    }

    @Test
    fun testSuccessfulEditBookmark() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_OK)
            .addHeader("Content-Type", "application/json")
            .setBody(loadJsonFromClasspath("api/update-success.json"))
        )

        val editBookmarkDto = EditBookmarkDto(
            addLabels = listOf("label1", "label2"),
            isArchived = true,
            isDeleted = false,
            isMarked = true,
            labels = listOf("label3"),
            readAnchor = "anchor1",
            readProgress = 50,
            removeLabels = listOf("label4"),
            title = "New Title"
        )

        val response = readeckApi.editBookmark("bookmarkId", editBookmarkDto)

        assertEquals(true, response.isSuccessful)
        assertEquals(200, response.code())
        assertTrue(response.body()?.isMarked!!)
    }

    @Test
    fun testFailedEditBookmark() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(422)
            .addHeader("Content-Type", "application/json")
            .setBody(loadJsonFromClasspath("api/update-invalid-data.json"))
        )

        val editBookmarkDto = EditBookmarkDto(
            addLabels = listOf("label1", "label2"),
            isArchived = true,
            isDeleted = false,
            isMarked = true,
            labels = listOf("label3"),
            readAnchor = "anchor1",
            readProgress = 50,
            removeLabels = listOf("label4"),
            title = "New Title"
        )

        val response = readeckApi.editBookmark("bookmarkId", editBookmarkDto)

        assertEquals(false, response.isSuccessful)
        assertEquals(422, response.code())

        val errorBody = response.errorBody()?.string()
        val editBookmarkErrorDto = Json.decodeFromString<EditBookmarkErrorDto>(errorBody!!)

        assertEquals(false, editBookmarkErrorDto.isValid)
        assertEquals("invalid type", editBookmarkErrorDto.fields?.get("is_marked")?.errors?.get(0))
    }

    @Test
    fun testGetBookmarks() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_OK)
            .addHeader("Content-Type", "application/json")
            .setBody(loadJsonFromClasspath("api/bookmarks.json"))
        )

        val response = readeckApi.getBookmarks(10, 0, null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created))

        assertTrue(response.isSuccessful)
        assertEquals(200, response.code())
        assertEquals(4, response.body()?.size)
    }

    @Test
    fun testSuccessfulDeleteBookmark() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
        )

        val response = readeckApi.deleteBookmark("bookmarkId")

        assertTrue(response.isSuccessful)
        assertEquals(HttpURLConnection.HTTP_NO_CONTENT, response.code())
        // No body to assert, just checking the status code
    }

    @Test
    fun testFailedDeleteBookmark() = runTest {
        mockWebServer.enqueue(MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_FORBIDDEN)
            .addHeader("Content-Type", "application/json")
            .setBody(loadJsonFromClasspath("api/auth-failure.json"))
        )

        val response = readeckApi.deleteBookmark("bookmarkId")

        assertFalse(response.isSuccessful)
        assertEquals(HttpURLConnection.HTTP_FORBIDDEN, response.code())

        val errorBody = response.errorBody()?.string()
        val statusMessage = Json.decodeFromString<StatusMessageDto>(errorBody!!)

        assertEquals(HttpURLConnection.HTTP_FORBIDDEN, statusMessage.status)
        assertEquals("Invalid user and/or password", statusMessage.message)
    }

    private fun loadJsonFromClasspath(resourcePath: String): String {
        val inputStream = this.javaClass.classLoader?.getResourceAsStream(resourcePath)
            ?: throw IllegalArgumentException("Resource not found: $resourcePath")

        val reader = BufferedReader(InputStreamReader(inputStream))
        val stringBuilder = StringBuilder()
        var line: String?
        while (reader.readLine().also { line = it } != null) {
            stringBuilder.append(line)
        }
        inputStream.close()
        return stringBuilder.toString()
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/test/logging/TimberTestTree.kt">
package com.mydeck.app.test.logging

import timber.log.Timber

object TestTimberTree : Timber.DebugTree() {
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        val logMessage = "[${priority.levelName()}] ${tag ?: "UNTAGGED"}: $message"

        when (priority) {
            LogPriority.ASSERT -> {
                System.err.println(logMessage)
                t?.printStackTrace(System.err) // Print stack trace to STDERR
            }
            LogPriority.ERROR -> {
                System.err.println(logMessage)
                t?.printStackTrace(System.err) // Print stack trace to STDERR
            }
            LogPriority.WARN -> System.err.println(logMessage)
            LogPriority.INFO -> println(logMessage)
            LogPriority.DEBUG -> println(logMessage)
            LogPriority.VERBOSE -> println(logMessage)
            else -> println(logMessage)
        }

        if (t != null && priority >= LogPriority.WARN) {
            t.printStackTrace()
        }
    }

    // Extension function to get log level name.
    private fun Int.levelName(): String {
        return when (this) {
            2 -> "VERBOSE"
            3 -> "DEBUG"
            4 -> "INFO"
            5 -> "WARN"
            6 -> "ERROR"
            7 -> "ASSERT"
            else -> "UNKNOWN"
        }
    }

    object LogPriority {
        const val VERBOSE = 2
        const val DEBUG = 3
        const val INFO = 4
        const val WARN = 5
        const val ERROR = 6
        const val ASSERT = 7
    }
}

// Helper function to replace the DebugTree
fun replaceDebugTree() {
    // Remove any existing TestTimberTree (in case of previous failures)

    val existingDebugTrees = Timber.forest().filterIsInstance<Timber.DebugTree>()
    existingDebugTrees.forEach { Timber.uproot(it) }
    Timber.plant(TestTimberTree)
}

// Helper function to restore the DebugTree (original impl)
fun restoreDebugTree() {
    Timber.uproot(TestTimberTree) // Remove TestTimberTree
    // Plant the original DebugTree.  This assumes that the DebugTree is already planted at app startup.
    // If it's not, you'll need to either plant a new DebugTree here or add code to remember and restore the original Trees.

    //Plant the production debug tree
    Timber.plant(Timber.DebugTree())
}
</file>

<file path="app/src/test/java/com/mydeck/app/ui/settings/AccountSettingsViewModelTest.kt">
package com.mydeck.app.ui.settings

import com.mydeck.app.R
import com.mydeck.app.domain.usecase.AuthenticateUseCase
import com.mydeck.app.domain.usecase.AuthenticationResult
import com.mydeck.app.io.prefs.SettingsDataStore
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.take
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

@OptIn(ExperimentalCoroutinesApi::class)
class AccountSettingsViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    private lateinit var settingsDataStore: SettingsDataStore
    private lateinit var authenticateUseCase: AuthenticateUseCase
    private lateinit var viewModel: AccountSettingsViewModel

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        settingsDataStore = mockk()
        authenticateUseCase = mockk()
        coEvery { settingsDataStore.urlFlow } returns MutableStateFlow("")
        coEvery { settingsDataStore.usernameFlow } returns MutableStateFlow("")
        coEvery { settingsDataStore.passwordFlow } returns MutableStateFlow("")
        viewModel = AccountSettingsViewModel(settingsDataStore, authenticateUseCase)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `initial uiState should reflect data store values`() = runTest {
        coEvery { settingsDataStore.urlFlow } returns MutableStateFlow("https://example.com")
        coEvery { settingsDataStore.usernameFlow } returns MutableStateFlow("testUser")
        coEvery { settingsDataStore.passwordFlow } returns MutableStateFlow("testPassword")
        viewModel = AccountSettingsViewModel(settingsDataStore, authenticateUseCase)

        val uiStateList = viewModel.uiState.take(2).toList()
        assertInitialUiState(uiStateList[0])
        val uiState = uiStateList[1]
        assertEquals("https://example.com", uiState.url)
        assertEquals("testUser", uiState.username)
        assertEquals("testPassword", uiState.password)
        assertFalse(uiState.allowUnencryptedConnection)
    }

    private fun assertInitialUiState(settingsUiState: AccountSettingsUiState) {
        assertEquals("", settingsUiState.url)
        assertEquals("", settingsUiState.username)
        assertEquals("", settingsUiState.password)
        assertNull(settingsUiState.urlError)
        assertNull(settingsUiState.usernameError)
        assertNull(settingsUiState.passwordError)
        assertNull(settingsUiState.authenticationResult)
        assertFalse(settingsUiState.loginEnabled)
        assertFalse(settingsUiState.allowUnencryptedConnection)
    }

    @Test
    fun `onUrlChanged should update url in uiState`() = runTest {
        viewModel.onUrlChanged("https://newurl.com")
        val uiState = viewModel.uiState.first()
        assertEquals("https://newurl.com", uiState.url)
    }

    @Test
    fun `onUsernameChanged should update username in uiState`() = runTest {
        viewModel.onUsernameChanged("newUsername")
        val uiState = viewModel.uiState.first()
        assertEquals("newUsername", uiState.username)
    }

    @Test
    fun `onPasswordChanged should update password in uiState`() = runTest {
        viewModel.onPasswordChanged("newPassword")
        val uiState = viewModel.uiState.first()
        assertEquals("newPassword", uiState.password)
    }

    @Test
    fun `onUrlChanged with valid URL should not set urlError`() = runTest {
        viewModel.onUrlChanged("https://validurl.com")
        val uiState = viewModel.uiState.first()
        assertNull(uiState.urlError)
    }

    @Test
    fun `onUrlChanged with invalid URL should set urlError`() = runTest {
        viewModel.onUrlChanged("invalid-url")
        val uiState = viewModel.uiState.first()
        assertEquals(R.string.account_settings_url_error, uiState.urlError)
    }

    @Test
    fun `onUsernameChanged with blank username should set usernameError`() = runTest {
        viewModel.onUsernameChanged("")
        val uiState = viewModel.uiState.first()
        assertEquals(R.string.account_settings_username_error, uiState.usernameError)
    }

    @Test
    fun `onPasswordChanged with blank password should set passwordError`() = runTest {
        viewModel.onPasswordChanged("")
        val uiState = viewModel.uiState.first()
        assertEquals(R.string.account_settings_password_error, uiState.passwordError)
    }

    @Test
    fun `login should call authenticateUseCase with correct parameters`() = runTest {
        coEvery { authenticateUseCase.execute(any(), any(), any()) } returns AuthenticationResult.Success
        viewModel.onUrlChanged("https://example.com/api")
        viewModel.onUsernameChanged("testUser")
        viewModel.onPasswordChanged("testPassword")
        viewModel.login()
        advanceUntilIdle()
        coVerify { authenticateUseCase.execute("https://example.com/api", "testUser", "testPassword") }
    }

    @Test
    fun `login should add api suffix to url and call authenticateUseCase with correct parameters`() = runTest {
        coEvery { authenticateUseCase.execute(any(), any(), any()) } returns AuthenticationResult.Success
        viewModel.onUrlChanged("https://example.com")
        viewModel.onUsernameChanged("testUser")
        viewModel.onPasswordChanged("testPassword")
        viewModel.login()
        advanceUntilIdle()
        coVerify { authenticateUseCase.execute("https://example.com/api", "testUser", "testPassword") }
    }

    @Test
    fun `login should update authenticationResult on success`() = runTest {
        coEvery { authenticateUseCase.execute(any(), any(), any()) } returns AuthenticationResult.Success
        viewModel.onUrlChanged("https://example.com")
        viewModel.onUsernameChanged("testUser")
        viewModel.onPasswordChanged("testPassword")
        viewModel.login()
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertEquals(AuthenticationResult.Success, uiState.authenticationResult)
    }

    @Test
    fun `login should update authenticationResult on authentication failure`() = runTest {
        val errorMessage = "Authentication failed"
        coEvery { authenticateUseCase.execute(any(), any(), any()) } returns AuthenticationResult.AuthenticationFailed(errorMessage)
        viewModel.onUrlChanged("https://example.com")
        viewModel.onUsernameChanged("testUser")
        viewModel.onPasswordChanged("testPassword")
        viewModel.login()
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertEquals(AuthenticationResult.AuthenticationFailed(errorMessage), uiState.authenticationResult)
    }

    @Test
    fun `login should update authenticationResult on network error`() = runTest {
        val errorMessage = "Network error"
        coEvery { authenticateUseCase.execute(any(), any(), any()) } returns AuthenticationResult.NetworkError(errorMessage)
        viewModel.onUrlChanged("https://example.com")
        viewModel.onUsernameChanged("testUser")
        viewModel.onPasswordChanged("testPassword")
        viewModel.login()
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertEquals(AuthenticationResult.NetworkError(errorMessage), uiState.authenticationResult)
    }

    @Test
    fun `login should update authenticationResult on generic error`() = runTest {
        val errorMessage = "Generic error"
        coEvery { authenticateUseCase.execute(any(), any(), any()) } returns AuthenticationResult.GenericError(errorMessage)
        viewModel.onUrlChanged("https://example.com")
        viewModel.onUsernameChanged("testUser")
        viewModel.onPasswordChanged("testPassword")
        viewModel.login()
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertEquals(AuthenticationResult.GenericError(errorMessage), uiState.authenticationResult)
    }

    @Test
    fun `onNavigationEventConsumed should reset navigation event`() = runTest {
        viewModel.onClickBack()
        viewModel.onNavigationEventConsumed()
        assertNull(viewModel.navigationEvent.first())
    }

    @Test
    fun `onClickBack should set NavigateBack navigation event`() = runTest {
        viewModel.onClickBack()
        assertEquals(AccountSettingsViewModel.NavigationEvent.NavigateBack, viewModel.navigationEvent.first())
    }

    @Test
    fun `loginEnabled should be false when url is invalid`() = runTest {
        viewModel.onUrlChanged("invalid-url")
        viewModel.onUsernameChanged("test")
        viewModel.onPasswordChanged("test")
        advanceUntilIdle()
        assertFalse(viewModel.uiState.first().loginEnabled)
    }

    @Test
    fun `loginEnabled should be false when username is blank`() = runTest {
        viewModel.onUrlChanged("https://validurl.com")
        viewModel.onUsernameChanged("")
        viewModel.onPasswordChanged("test")
        assertFalse(viewModel.uiState.first().loginEnabled)
    }

    @Test
    fun `loginEnabled should be false when password is blank`() = runTest {
        viewModel.onUrlChanged("https://validurl.com")
        viewModel.onUsernameChanged("test")
        viewModel.onPasswordChanged("")
        assertFalse(viewModel.uiState.first().loginEnabled)
    }

    @Test
    fun `loginEnabled should be true when url, username and password are valid`() = runTest {
        viewModel.onUrlChanged("https://validurl.com")
        viewModel.onUsernameChanged("test")
        viewModel.onPasswordChanged("test")
        assertTrue(viewModel.uiState.first().loginEnabled)
    }

    @Test
    fun `onAllowUnencryptedConnectionChanged should update allowUnencryptedConnection in uiState`() = runTest {
        viewModel.onAllowUnencryptedConnectionChanged(true)
        val uiState = viewModel.uiState.first()
        assertTrue(uiState.allowUnencryptedConnection)

        viewModel.onAllowUnencryptedConnectionChanged(false)
        val uiState2 = viewModel.uiState.first()
        assertFalse(uiState2.allowUnencryptedConnection)
    }

    @Test
    fun `onUrlChanged with http URL and allowUnencryptedConnection false should set urlError`() = runTest {
        viewModel.onAllowUnencryptedConnectionChanged(false)
        viewModel.onUrlChanged("http://validurl.com")
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertEquals(R.string.account_settings_url_error, uiState.urlError)
    }

    @Test
    fun `onUrlChanged with https URL and allowUnencryptedConnection false should not set urlError`() = runTest {
        viewModel.onAllowUnencryptedConnectionChanged(false)
        viewModel.onUrlChanged("https://validurl.com")
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertNull(uiState.urlError)
    }

    @Test
    fun `onUrlChanged with http URL and allowUnencryptedConnection true should not set urlError`() = runTest {
        viewModel.onAllowUnencryptedConnectionChanged(true)
        viewModel.onUrlChanged("http://validurl.com")
        advanceUntilIdle()
        val uiState = viewModel.uiState.first()
        assertNull(uiState.urlError)
    }

    @Test
    fun `loginEnabled should be true when url is http and allowUnencryptedConnection is true and username and password are valid`() = runTest {
        viewModel.onAllowUnencryptedConnectionChanged(true)
        viewModel.onUrlChanged("http://validurl.com")
        viewModel.onUsernameChanged("test")
        viewModel.onPasswordChanged("test")
        advanceUntilIdle()
        assertTrue(viewModel.uiState.first().loginEnabled)
    }

    @Test
    fun `loginEnabled should be false when url is http and allowUnencryptedConnection is false and username and password are valid`() = runTest {
        viewModel.onAllowUnencryptedConnectionChanged(false)
        viewModel.onUrlChanged("http://validurl.com")
        viewModel.onUsernameChanged("test")
        viewModel.onPasswordChanged("test")
        advanceUntilIdle()
        assertFalse(viewModel.uiState.first().loginEnabled)
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/ui/settings/SettingsScreenRobolectricTest.kt">

</file>

<file path="app/src/test/java/com/mydeck/app/ui/settings/SettingsScreenUnitTest.kt">
package com.mydeck.app.ui.settings

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertTextEquals
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import dagger.hilt.android.testing.HiltTestApplication
import dagger.hilt.android.testing.UninstallModules
import com.mydeck.app.io.rest.NetworkModule
import com.mydeck.app.ui.theme.MyDeckTheme
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import org.robolectric.annotation.Config

@RunWith(RobolectricTestRunner::class)
@HiltAndroidTest
@Config(application = HiltTestApplication::class)
@UninstallModules(NetworkModule::class)
class SettingsScreenUnitTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @get:Rule
    val hiltRule = HiltAndroidRule(this)

    @Before
    fun setup() {
        hiltRule.inject()
    }

    @Test
    fun settingsScreen_displaysTitle() {
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = {},
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        composeTestRule.onNodeWithTag(SettingsScreenTestTags.TOPBAR).assertIsDisplayed()
    }

    @Test
    fun settingsScreen_displaysAccountSetting() {
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = {},
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        val expectedTitle = "Account"
        composeTestRule.onNodeWithTag(SettingsScreenTestTags.SETTINGS_ITEM_TITLE)
        composeTestRule.onNodeWithText(expectedTitle).assertIsDisplayed()
    }

    @Test
    fun settingsScreen_displaysAccountSettingWithUsername() {
        val expectedUsername = "test"
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = expectedUsername),
                    onClickAccount = {},
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        with(
            composeTestRule.onNodeWithTag(
                "${SettingsScreenTestTags.SETTINGS_ITEM_SUBTITLE}.${SettingsScreenTestTags.SETTINGS_ITEM_ACCOUNT}",
                useUnmergedTree = true
            )
        ) {
            assertIsDisplayed()
            assertTextEquals(expectedUsername)
        }
    }

    @Test
    fun settingsScreen_clickAccountSetting_callsOnClickAccount() {
        var accountClicked = false
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = { accountClicked = true },
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        composeTestRule.onNodeWithTag(
            "${SettingsScreenTestTags.SETTINGS_ITEM}.${SettingsScreenTestTags.SETTINGS_ITEM_ACCOUNT}",
            useUnmergedTree = true
        ).performClick()
        assertTrue(accountClicked)
    }

    @Test
    fun settingsScreen_displaysBackButton() {
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = {},
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        composeTestRule.onNodeWithTag(SettingsScreenTestTags.BACK_BUTTON).assertIsDisplayed()
    }

    @Test
    fun settingsScreen_clickBackButton_callsOnClickBack() {
        var backClicked = false
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = {},
                    onClickBack = { backClicked = true },
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        composeTestRule.onNodeWithTag(SettingsScreenTestTags.BACK_BUTTON).assertIsDisplayed()
            .performClick()
        assertTrue(backClicked)
    }

    @Test
    fun settingsScreen_clickLogs_callsOnClickLogs() {
        var logsClicked = false
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = {},
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = { logsClicked = true },
                    onClickSync = {},
                    onClickUi = {}
                )
            }
        }

        composeTestRule.onNodeWithTag(
            "${SettingsScreenTestTags.SETTINGS_ITEM}.${SettingsScreenTestTags.SETTINGS_ITEM_LOGS}",
            useUnmergedTree = true
        ).performClick()
        assertTrue(logsClicked)
    }

    @Test
    fun settingsScreen_clickUi_callsOnClickUi() {
        var uiClicked = false
        composeTestRule.setContent {
            MyDeckTheme {
                SettingScreenView(
                    settingsUiState = SettingsUiState(username = "test"),
                    onClickAccount = {},
                    onClickBack = {},
                    onClickOpenSourceLibraries = {},
                    onClickLogs = {},
                    onClickSync = {},
                    onClickUi = { uiClicked = true}
                )
            }
        }

        composeTestRule.onNodeWithTag(
            "${SettingsScreenTestTags.SETTINGS_ITEM}.${SettingsScreenTestTags.SETTINGS_ITEM_UI}",
            useUnmergedTree = true
        ).performClick()
        assertTrue(uiClicked)
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/ui/settings/SettingsViewModelTest.kt">
package com.mydeck.app.ui.settings

import com.mydeck.app.domain.UserRepository
import com.mydeck.app.domain.model.AuthenticationDetails
import io.mockk.coEvery
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.take
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Before
import org.junit.Test

@OptIn(ExperimentalCoroutinesApi::class)
class SettingsViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    private lateinit var userRepository: UserRepository
    private lateinit var viewModel: SettingsViewModel

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        userRepository = mockk()
        coEvery { userRepository.observeAuthenticationDetails() } returns MutableStateFlow(
            AuthenticationDetails(
                url = "http://test",
                username = "testUser",
                password = "pass",
                token = "token"
            )
        )
        viewModel = SettingsViewModel(userRepository)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `init should load username from data store`() = runTest {
        val list = viewModel.uiState.take(2).toList()
        assertNull(list[0].username)
        assertEquals("testUser", list[1].username)
    }

    @Test
    fun `onClickAccount should navigate to account settings`() = runTest {
        viewModel.onClickAccount()
        testDispatcher.scheduler.advanceUntilIdle()

        assertEquals(SettingsViewModel.NavigationEvent.NavigateToAccountSettings, viewModel.navigationEvent.value)
    }

    @Test
    fun `onClickOpenSourceLibraries should navigate to open source libraries screen`() = runTest {
        viewModel.onClickOpenSourceLibraries()
        testDispatcher.scheduler.advanceUntilIdle()

        assertEquals(SettingsViewModel.NavigationEvent.NavigateToOpenSourceLibraries, viewModel.navigationEvent.value)
    }

    @Test
    fun `onClickBack should navigate back`() = runTest {
        viewModel.onClickBack()
        testDispatcher.scheduler.advanceUntilIdle()

        assertEquals(SettingsViewModel.NavigationEvent.NavigateBack, viewModel.navigationEvent.value)
    }

    @Test
    fun `onNavigationEventConsumed should reset navigation event`() = runTest {
        viewModel.onClickAccount()
        testDispatcher.scheduler.advanceUntilIdle()
        viewModel.onNavigationEventConsumed()
        testDispatcher.scheduler.advanceUntilIdle()

        assertEquals(null, viewModel.navigationEvent.value)
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/util/UtilsTest.kt">
package com.mydeck.app.util

import com.mydeck.app.domain.model.SharedText
import junit.framework.TestCase.assertEquals
import org.junit.Test

class UtilsTest {
    @Test
    fun testExtractUrlAndTitle() {
        val testSet = listOf<Pair<String, SharedText?>>(
            "test " to null,
            "https://example.com" to SharedText(url = "https://example.com"),
            "before title https://example.com" to SharedText(url = "https://example.com", "before title"),
            "https://example.com after title" to SharedText(url = "https://example.com", "after title"),
        )
        testSet.forEachIndexed { index, testSet ->
            assertEquals("Error in testSet $index", testSet.second, testSet.first.extractUrlAndTitle())
        }
    }

}
</file>

<file path="app/src/test/java/com/mydeck/app/ExampleUnitTest.kt">
package com.mydeck.app

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
</file>

<file path="app/src/test/resources/api/auth-failure.json">
{
  "status": 403,
  "message": "Invalid user and/or password"
}
</file>

<file path="app/src/test/resources/api/auth.json">
{
  "id": "theId",
  "token": "theToken"
}
</file>

<file path="app/src/test/resources/api/bookmarks.json">
[
  {
    "id": "GywTWpgMHr6Yqsv7Jviuwd",
    "href": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv7Jviuwd",
    "created": "2025-04-03T19:00:13.646333268Z",
    "updated": "2025-04-04T14:09:22.615018537Z",
    "state": 0,
    "loaded": true,
    "url": "https://example.com/blog/example",
    "title": "Example",
    "site_name": "example.com",
    "site": "example.com",
    "authors": [],
    "lang": "",
    "text_direction": "",
    "document_type": "article",
    "type": "article",
    "has_article": true,
    "description": "Learn how examples work",
    "is_deleted": false,
    "is_marked": false,
    "is_archived": false,
    "labels": [],
    "read_progress": 100,
    "resources": {
      "article": {
        "src": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv7Jviuwd/article"
      },
      "icon": {
        "src": "https://readeck.example.com/bm/Gy/GywTWpgMHr6Yqsv7Jviuwd/img/icon.png",
        "width": 48,
        "height": 48
      },
      "image": {
        "src": "https://readeck.example.com/bm/Gy/GywTWpgMHr6Yqsv7Jviuwd/img/image.png",
        "width": 800,
        "height": 400
      },
      "log": {
        "src": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv7Jviuwd/x/log"
      },
      "props": {
        "src": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv7Jviuwd/x/props.json"
      },
      "thumbnail": {
        "src": "https://readeck.example.com/bm/Gy/GywTWpgMHr6Yqsv7Jviuwd/img/thumbnail.png",
        "width": 380,
        "height": 190
      }
    },
    "word_count": 8881,
    "reading_time": 44
  },
  {
    "id": "fwAYQFVx2VNBKvR5jtQ8cr",
    "href": "https://readeck.example.com/api/bookmarks/fwAYQFVx2VNBKvR5jtQ8cr",
    "created": "2025-04-02T22:46:17.187719941Z",
    "updated": "2025-04-04T14:00:01.410961714Z",
    "state": 0,
    "loaded": true,
    "url": "http://example.org/example-read_progress",
    "title": "Example without read_progress",
    "site_name": "example.org",
    "site": "example.org",
    "authors": [
      "John Dow"
    ],
    "lang": "en",
    "text_direction": "",
    "document_type": "article",
    "type": "article",
    "has_article": true,
    "description": "Examples",
    "is_deleted": false,
    "is_marked": false,
    "is_archived": false,
    "labels": [],
    "resources": {
      "article": {
        "src": "https://readeck.example.com/api/bookmarks/fwAYQFVx2VNBKvR5jtQ8cr/article"
      },
      "icon": {
        "src": "https://readeck.example.com/bm/fw/fwAYQFVx2VNBKvR5jtQ8cr/img/icon.png",
        "width": 48,
        "height": 48
      },
      "log": {
        "src": "https://readeck.example.com/api/bookmarks/fwAYQFVx2VNBKvR5jtQ8cr/x/log"
      },
      "props": {
        "src": "https://readeck.example.com/api/bookmarks/fwAYQFVx2VNBKvR5jtQ8cr/x/props.json"
      }
    },
    "word_count": 247,
    "reading_time": 1
  },
  {
    "id": "fwAYQFVx2VNAKvR5jtQ8cr",
    "href": "https://readeck.example.com/api/bookmarks/fwAYQFVx2VNAKvR5jtQ8cr",
    "created": "2025-04-02T22:46:17.187719941Z",
    "updated": "2025-04-04T14:00:01.410961714Z",
    "state": 0,
    "loaded": true,
    "url": "http://example.org/example-read_progress",
    "title": "Example without read_progress",
    "site_name": "example.org",
    "site": "example.org",
    "authors": [
      "John Dow"
    ],
    "lang": "en",
    "text_direction": "",
    "document_type": "article",
    "type": "article",
    "has_article": true,
    "description": "Examples",
    "is_deleted": false,
    "is_marked": false,
    "is_archived": false,
    "labels": [],
    "resources": {
      "article": {
        "src": "https://readeck.example.com/api/bookmarks/fwAYQFVx2VNBKvR5jtQ8cr/article"
      },
      "icon": {
        "src": "https://readeck.example.com/bm/fw/fwAYQFVx2VNBKvR5jtQ8cr/img/icon.png",
        "width": 48,
        "height": 48
      }
    },
    "word_count": 247,
    "reading_time": 1
  },
  {
    "id": "GywTWpgMHr6Yqsv8Jviuwd",
    "href": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv8Jviuwd",
    "created": "2025-09-10T19:00:13.646333268Z",
    "updated": "2025-09-10T14:09:22.615018537Z",
    "state": 0,
    "loaded": true,
    "url": "https://example.com/blog/example_authors_null",
    "title": "Example Authors null",
    "site_name": "example.com",
    "site": "example.com",
    "authors": null,
    "lang": "",
    "text_direction": "",
    "document_type": "article",
    "type": "article",
    "has_article": true,
    "description": "Learn how examples work",
    "is_deleted": false,
    "is_marked": false,
    "is_archived": false,
    "labels": [],
    "read_progress": 100,
    "resources": {
      "article": {
        "src": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv8Jviuwd/article"
      },
      "icon": {
        "src": "https://readeck.example.com/bm/Gy/GywTWpgMHr6Yqsv8Jviuwd/img/icon.png",
        "width": 48,
        "height": 48
      },
      "image": {
        "src": "https://readeck.example.com/bm/Gy/GywTWpgMHr6Yqsv8Jviuwd/img/image.png",
        "width": 800,
        "height": 400
      },
      "log": {
        "src": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv8Jviuwd/x/log"
      },
      "props": {
        "src": "https://readeck.example.com/api/bookmarks/GywTWpgMHr6Yqsv8Jviuwd/x/props.json"
      },
      "thumbnail": {
        "src": "https://readeck.example.com/bm/Gy/GywTWpgMHr6Yqsv8Jviuwd/img/thumbnail.png",
        "width": 380,
        "height": 190
      }
    },
    "word_count": 8881,
    "reading_time": 44
  }
]
</file>

<file path="app/src/test/resources/api/update-invalid-data.json">
{
  "is_valid": false,
  "errors": null,
  "fields": {
    "_to": {
      "is_null": true,
      "is_bound": false,
      "value": null,
      "errors": null
    },
    "add_labels": {
      "is_null": false,
      "is_bound": true,
      "value": [
        "string"
      ],
      "errors": null
    },
    "is_archived": {
      "is_null": false,
      "is_bound": true,
      "value": false,
      "errors": null
    },
    "is_deleted": {
      "is_null": false,
      "is_bound": true,
      "value": false,
      "errors": null
    },
    "is_marked": {
      "is_null": false,
      "is_bound": true,
      "value": false,
      "errors": [
        "invalid type"
      ]
    },
    "labels": {
      "is_null": false,
      "is_bound": true,
      "value": [
        "string"
      ],
      "errors": null
    },
    "read_anchor": {
      "is_null": false,
      "is_bound": true,
      "value": "string",
      "errors": null
    },
    "read_progress": {
      "is_null": false,
      "is_bound": true,
      "value": 0,
      "errors": null
    },
    "remove_labels": {
      "is_null": false,
      "is_bound": true,
      "value": [
        "string"
      ],
      "errors": null
    },
    "title": {
      "is_null": false,
      "is_bound": true,
      "value": "string",
      "errors": null
    }
  }
}
</file>

<file path="app/src/test/resources/api/update-success.json">
{
  "href": "https://readeck.example.com/api/bookmarks/bookmarkId",
  "id": "bookmarkId",
  "is_marked": true,
  "updated": "2025-03-31T14:13:00.555637073Z"
}
</file>

<file path="app/.gitignore">
/build
</file>

<file path="config/libraries/sakura.json">
{
  "uniqueId": "sakura.css",
  "developers": [ { "name": "Mitesh Shah" }],
  "artifactVersion": "1.5.0",
  "description": "a minimal css framework/theme",
  "name": "Sakura.css",
  "licenses": [
    "MIT"
  ]
}
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
#Thu Feb 06 13:24:41 CET 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path=".repomixignore">
_notes/
.github
docs/
metadata/
./*.txt
./*.diff
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.8.0] - 2025-11-11

### Added

- Added a new sepia theme. Closes #133. Contributed by @Janszczyrek
- Added the ability to scale fonts in details screen to increase or decrease font size. Closes #90. Contributed by @Janszczyrek

### Fixed

- Fixed missing support for Android devices with min sdk 24 (Android 7.0). Closes #127

## [0.7.0] - 2025-10-05

### Fixed

- Fixed a parsing error where `author` field could be null in the server response. Closes #123
- Fixed error extracting urls from share intents. Additional text is now treated as title. Closes #120
- Fixed a parsing error where `log` and `props` fields could be null in the server response. Closes #110

## [0.6.0] - 2025-06-16

### Added

- Added badges to navigation drawer items showing the count of unread, archived, favorite, article, video, and picture bookmarks.
- Added pull-to-refresh in bookmark list screen. Contributed by @sockenklaus
- Added translation for Chinese by Poesty Li
- Added translation for Spanish by Guillermo
- Added trust anchors for system and user certificates in `network_security_config.xml`. This allows the app to trust self-signed certificates. Exercise caution when adding user certificates. Malicious certificates can compromise your security. Only add certificates from sources you fully trust. Closes #105. Contributed by @ffminus
- Added the option to allow unencrypted connections (HTTP) for the Readeck server URL. This option is disabled by default and requires explicit user consent via a checkbox in the account settings.  This allows users to connect to servers that do not have HTTPS enabled, but it is strongly discouraged for security reasons. Closes #98.

### Changed

- The floating action button now adds new bookmarks instead of refreshing the list. Contributed by @sockenklaus
- The "Add Bookmark" action has been removed from the top action bar. Contributed by @sockenklaus

## [0.5.0] - 2025-05-30

### Added

- Added the ability to select the theme in the settings. The theme selection is now also considered when displaying content in the bookmark details. Dynamic changing of the dark mode when using the system theme is also supported. Closes #77
- Added the ability to open original url in browser. Closes #74. Contributed by @sockenklaus
- Added the ability to share links to bookmarks from list view and datail view. Closes #45. Contributed by @sockenklaus

### Changed

- Show placeholder images on image load failure in main list view. Closes #81
- Allow cleartext traffic for tor onion services. Closes #92

## [0.4.0] - 2025-05-21

### Added

- Implemented background synchronization of bookmarks. The app now automatically synchronizes with the Readeck server in the background to detect and remove bookmarks that have been deleted on the server. This ensures that the local bookmark list remains consistent with the server.
- Added translation for Spanish by @xmgz
- Added icons to navigation drawer by @sockenklaus

### Fixed

- Fix #64: Add library definitions to version control.
- Fix #66: Show bookmark detail view for all bookmark, even if no article content is available.

## [0.3.2] - 2025-04-28

### Fixed

- Fix #54: Persist article content in separate database table. Also improves performance.

### Changed

- Disabled baseline profile to allow reproducible builds for F-Droid

## [0.3.1] - 2025-04-15

### Added

- Added metadata for F-Droid builds

### Fixed

- Fix #53: Show bookmarks of type `photo` in detail view

### Changed

- Readeck now displays notifications when authentication fails. These notifications allow users to quickly navigate to the account screen to verify their credentials and log in again. This feature assists users in addressing token-related issues that may arise when upgrading to Readeck 1.8.0, as outlined in the breaking changes documentation (https://readeck.org/en/blog/202503-readeck-18/#breaking-changes).

## [0.3.0] - 2025-04-11

### Added

- Implemented the ability to delete bookmarks in list and detail screen. Closes #44
- Implemented the ability to change the read state of bookmarks in list and detail screen. Closes #47
- Implemented the ability to change the archive state of bookmarks in list and detail screen. Closes #43
- Implemented the ability to change the favorite state of bookmarks in list and detail screen. Closes #39
- Implemented the ability to view application logs within the settings screen and share them for troubleshooting purposes.

### Fixed

- Fix #34: Fix parsing error. Make field `read_progress` optional.
- Fix #40: Bookmark synchronization issues caused by incorrect timezone handling.

### Changed

- Now only bookmarks that are successfully loaded (`state = 0` in readeck api) are displayed. Bookmarks that are still loading or have encountered an error will not be displayed. 

## [0.2.0] - 2025-03-25

### Added

- Implemented the ability to receive shared URLs from other apps, automatically opening the create bookmark dialog and pre-populating the URL field. Closes #25

### Fixed

- Fix #23: fix error in release workflow
- Fix #27: Enforce HTTPS and allow cleartext traffic only for ts.net including subdomains.
- Fix #29, #30: Make login workflow more robust 
- Fix #18: automatically append /api to base URL if missing in login workflow

## [0.1.0] - 2025-03-19

### Added

- Initial release of ReadeckApp.
- Implemented adding bookmarks.
- Implemented bookmark listing and detail screens.
- Implemented settings screen with account settings.
- Implemented authentication flow.
- Implemented data storage using Room database.
- Implemented dependency injection using Hilt.
- Implemented networking using Retrofit.
- Implemented MVVM architecture.

### Changed

- Initial implementation of the ReadeckApp.

### Deprecated

### Removed

### Fixed

### Security
</file>

<file path="export-libraries.sh">
#!/usr/bin/env bash
./gradlew app:exportLibraryDefinitions -PaboutLibraries.exportPath=src/main/res/raw/
</file>

<file path="gradlew">
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="LICENSE">
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
</file>

<file path="settings.gradle.kts">
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven {
            url = uri("https://jitpack.io")
        }
    }
}

rootProject.name = "MyDeck"
include(":app")
</file>

<file path="app/schemas/com.mydeck.app.io.db.MyDeckDatabase/4.json">
{
  "formatVersion": 1,
  "database": {
    "version": 4,
    "identityHash": "65ad3cfeecd06efa273405947eb543d3",
    "entities": [
      {
        "tableName": "bookmarks",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, `href` TEXT NOT NULL, `created` INTEGER NOT NULL, `updated` INTEGER NOT NULL, `state` INTEGER NOT NULL, `loaded` INTEGER NOT NULL, `url` TEXT NOT NULL, `title` TEXT NOT NULL, `siteName` TEXT NOT NULL, `site` TEXT NOT NULL, `authors` TEXT NOT NULL, `lang` TEXT NOT NULL, `textDirection` TEXT NOT NULL, `documentTpe` TEXT NOT NULL, `type` TEXT NOT NULL, `hasArticle` INTEGER NOT NULL, `description` TEXT NOT NULL, `isDeleted` INTEGER NOT NULL, `isMarked` INTEGER NOT NULL, `isArchived` INTEGER NOT NULL, `labels` TEXT NOT NULL, `readProgress` INTEGER NOT NULL, `wordCount` INTEGER, `readingTime` INTEGER, `published` INTEGER, `embed` TEXT, `embedHostname` TEXT, `article_src` TEXT NOT NULL, `icon_src` TEXT NOT NULL, `icon_width` INTEGER NOT NULL, `icon_height` INTEGER NOT NULL, `image_src` TEXT NOT NULL, `image_width` INTEGER NOT NULL, `image_height` INTEGER NOT NULL, `log_src` TEXT NOT NULL, `props_src` TEXT NOT NULL, `thumbnail_src` TEXT NOT NULL, `thumbnail_width` INTEGER NOT NULL, `thumbnail_height` INTEGER NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "href",
            "columnName": "href",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "created",
            "columnName": "created",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "updated",
            "columnName": "updated",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "state",
            "columnName": "state",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "loaded",
            "columnName": "loaded",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "url",
            "columnName": "url",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "title",
            "columnName": "title",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "siteName",
            "columnName": "siteName",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "site",
            "columnName": "site",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "authors",
            "columnName": "authors",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "lang",
            "columnName": "lang",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "textDirection",
            "columnName": "textDirection",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "documentTpe",
            "columnName": "documentTpe",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "type",
            "columnName": "type",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "hasArticle",
            "columnName": "hasArticle",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "description",
            "columnName": "description",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "isDeleted",
            "columnName": "isDeleted",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isMarked",
            "columnName": "isMarked",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "isArchived",
            "columnName": "isArchived",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "labels",
            "columnName": "labels",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "readProgress",
            "columnName": "readProgress",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "wordCount",
            "columnName": "wordCount",
            "affinity": "INTEGER"
          },
          {
            "fieldPath": "readingTime",
            "columnName": "readingTime",
            "affinity": "INTEGER"
          },
          {
            "fieldPath": "published",
            "columnName": "published",
            "affinity": "INTEGER"
          },
          {
            "fieldPath": "embed",
            "columnName": "embed",
            "affinity": "TEXT"
          },
          {
            "fieldPath": "embedHostname",
            "columnName": "embedHostname",
            "affinity": "TEXT"
          },
          {
            "fieldPath": "article.src",
            "columnName": "article_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.src",
            "columnName": "icon_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "icon.width",
            "columnName": "icon_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "icon.height",
            "columnName": "icon_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.src",
            "columnName": "image_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "image.width",
            "columnName": "image_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "image.height",
            "columnName": "image_height",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "log.src",
            "columnName": "log_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "props.src",
            "columnName": "props_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.src",
            "columnName": "thumbnail_src",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.width",
            "columnName": "thumbnail_width",
            "affinity": "INTEGER",
            "notNull": true
          },
          {
            "fieldPath": "thumbnail.height",
            "columnName": "thumbnail_height",
            "affinity": "INTEGER",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        },
        "indices": [
          {
            "name": "index_bookmarks_readProgress",
            "unique": false,
            "columnNames": [
              "readProgress"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_readProgress` ON `${TABLE_NAME}` (`readProgress`)"
          },
          {
            "name": "index_bookmarks_type",
            "unique": false,
            "columnNames": [
              "type"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_type` ON `${TABLE_NAME}` (`type`)"
          },
          {
            "name": "index_bookmarks_isArchived",
            "unique": false,
            "columnNames": [
              "isArchived"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isArchived` ON `${TABLE_NAME}` (`isArchived`)"
          },
          {
            "name": "index_bookmarks_isMarked",
            "unique": false,
            "columnNames": [
              "isMarked"
            ],
            "orders": [],
            "createSql": "CREATE INDEX IF NOT EXISTS `index_bookmarks_isMarked` ON `${TABLE_NAME}` (`isMarked`)"
          }
        ]
      },
      {
        "tableName": "article_content",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`bookmarkId` TEXT NOT NULL, `content` TEXT NOT NULL, PRIMARY KEY(`bookmarkId`), FOREIGN KEY(`bookmarkId`) REFERENCES `bookmarks`(`id`) ON UPDATE NO ACTION ON DELETE CASCADE )",
        "fields": [
          {
            "fieldPath": "bookmarkId",
            "columnName": "bookmarkId",
            "affinity": "TEXT",
            "notNull": true
          },
          {
            "fieldPath": "content",
            "columnName": "content",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "bookmarkId"
          ]
        },
        "foreignKeys": [
          {
            "table": "bookmarks",
            "onDelete": "CASCADE",
            "onUpdate": "NO ACTION",
            "columns": [
              "bookmarkId"
            ],
            "referencedColumns": [
              "id"
            ]
          }
        ]
      },
      {
        "tableName": "remote_bookmark_ids",
        "createSql": "CREATE TABLE IF NOT EXISTS `${TABLE_NAME}` (`id` TEXT NOT NULL, PRIMARY KEY(`id`))",
        "fields": [
          {
            "fieldPath": "id",
            "columnName": "id",
            "affinity": "TEXT",
            "notNull": true
          }
        ],
        "primaryKey": {
          "autoGenerate": false,
          "columnNames": [
            "id"
          ]
        }
      }
    ],
    "setupQueries": [
      "CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)",
      "INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, '65ad3cfeecd06efa273405947eb543d3')"
    ]
  }
}
</file>

<file path="app/src/main/assets/html_template_dark.html">
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <style>
        /* Sakura.css v1.5.0
         * ================
         * Minimal css theme.
         * Project: https://github.com/oxalorg/sakura/
         */
        /* Body */
        html {
          font-size: 62.5%;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        body {
          font-size: 1.8rem;
          line-height: 1.618;
          max-width: 38em;
          margin: auto;
          color: #c9c9c9;
          background-color: #222222;
          padding: 13px;
        }

        @media (max-width: 684px) {
          body {
            font-size: 1.53rem;
          }
        }
        @media (max-width: 382px) {
          body {
            font-size: 1.35rem;
          }
        }
        h1, h2, h3, h4, h5, h6 {
          line-height: 1.1;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
          font-weight: 700;
          margin-top: 3rem;
          margin-bottom: 1.5rem;
          overflow-wrap: break-word;
          word-wrap: break-word;
          -ms-word-break: break-all;
          word-break: break-word;
        }

        h1 {
          font-size: 2.35em;
        }

        h2 {
          font-size: 2em;
        }

        h3 {
          font-size: 1.75em;
        }

        h4 {
          font-size: 1.5em;
        }

        h5 {
          font-size: 1.25em;
        }

        h6 {
          font-size: 1em;
        }

        p {
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        small, sub, sup {
          font-size: 75%;
        }

        hr {
          border-color: #ffffff;
        }

        a {
          text-decoration: none;
          color: #ffffff;
        }
        a:visited {
          color: #e6e6e6;
        }
        a:hover {
          color: #c9c9c9;
          border-bottom: 2px solid #c9c9c9;
        }

        ul {
          padding-left: 1.4em;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        li {
          margin-bottom: 0.4em;
        }

        blockquote {
          margin-left: 0px;
          margin-right: 0px;
          padding-left: 1em;
          padding-top: 0.8em;
          padding-bottom: 0.8em;
          padding-right: 0.8em;
          border-left: 5px solid #ffffff;
          margin-bottom: 2.5rem;
          background-color: #4a4a4a;
        }

        blockquote p {
          margin-bottom: 0;
        }

        img, video {
          height: auto;
          max-width: 100%;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        iframe {
          max-width: 100%;
          width: 100%;
          aspect-ratio: 16 / 9;
          border: none;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        /* Pre and Code */
        pre {
          background-color: #4a4a4a;
          display: block;
          padding: 1em;
          overflow-x: auto;
          margin-top: 0px;
          margin-bottom: 2.5rem;
          font-size: 0.9em;
        }

        code, kbd, samp {
          font-size: 0.9em;
          padding: 0 0.5em;
          background-color: #4a4a4a;
          white-space: pre-wrap;
        }

        pre > code {
          padding: 0;
          background-color: transparent;
          white-space: pre;
          font-size: 1em;
        }

        /* Tables */
        table {
          text-align: justify;
          width: 100%;
          border-collapse: collapse;
          margin-bottom: 2rem;
        }

        td, th {
          padding: 0.5em;
          border-bottom: 1px solid #4a4a4a;
        }

        /* Buttons, forms and input */
        input, textarea {
          border: 1px solid #c9c9c9;
        }
        input:focus, textarea:focus {
          border: 1px solid #ffffff;
        }

        textarea {
          width: 100%;
        }

        .button, button, input[type=submit], input[type=reset], input[type=button], input[type=file]::file-selector-button {
          display: inline-block;
          padding: 5px 10px;
          text-align: center;
          text-decoration: none;
          white-space: nowrap;
          background-color: #ffffff;
          color: #222222;
          border-radius: 1px;
          border: 1px solid #ffffff;
          cursor: pointer;
          box-sizing: border-box;
        }
        .button[disabled], button[disabled], input[type=submit][disabled], input[type=reset][disabled], input[type=button][disabled], input[type=file]::file-selector-button[disabled] {
          cursor: default;
          opacity: 0.5;
        }
        .button:hover, button:hover, input[type=submit]:hover, input[type=reset]:hover, input[type=button]:hover, input[type=file]::file-selector-button:hover {
          background-color: #c9c9c9;
          color: #222222;
          outline: 0;
        }
        .button:focus-visible, button:focus-visible, input[type=submit]:focus-visible, input[type=reset]:focus-visible, input[type=button]:focus-visible, input[type=file]::file-selector-button:focus-visible {
          outline-style: solid;
          outline-width: 2px;
        }

        textarea, select, input {
          color: #c9c9c9;
          padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
          margin-bottom: 10px;
          background-color: #4a4a4a;
          border: 1px solid #4a4a4a;
          border-radius: 4px;
          box-shadow: none;
          box-sizing: border-box;
        }
        textarea:focus, select:focus, input:focus {
          border: 1px solid #ffffff;
          outline: 0;
        }

        input[type=checkbox]:focus {
          outline: 1px dotted #ffffff;
        }

        label, legend, fieldset {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 600;
        }

    </style>
</head>
<body>
    <div class="container">
        %s
    </div>
</body>
</html>
</file>

<file path="app/src/main/assets/html_template_light.html">
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <style>
        /* Sakura.css v1.5.0
         * ================
         * Minimal css theme.
         * Project: https://github.com/oxalorg/sakura/
         */
        /* Body */
        html {
          font-size: 62.5%;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        body {
          font-size: 1.8rem;
          line-height: 1.618;
          max-width: 38em;
          margin: auto;
          color: #4a4a4a;
          background-color: #f9f9f9;
          padding: 13px;
        }

        @media (max-width: 684px) {
          body {
            font-size: 1.53rem;
          }
        }
        @media (max-width: 382px) {
          body {
            font-size: 1.35rem;
          }
        }
        h1, h2, h3, h4, h5, h6 {
          line-height: 1.1;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
          font-weight: 700;
          margin-top: 3rem;
          margin-bottom: 1.5rem;
          overflow-wrap: break-word;
          word-wrap: break-word;
          -ms-word-break: break-all;
          word-break: break-word;
        }

        h1 {
          font-size: 2.35em;
        }

        h2 {
          font-size: 2em;
        }

        h3 {
          font-size: 1.75em;
        }

        h4 {
          font-size: 1.5em;
        }

        h5 {
          font-size: 1.25em;
        }

        h6 {
          font-size: 1em;
        }

        p {
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        small, sub, sup {
          font-size: 75%;
        }

        hr {
          border-color: #1d7484;
        }

        a {
          text-decoration: none;
          color: #1d7484;
        }
        a:visited {
          color: #144f5a;
        }
        a:hover {
          color: #982c61;
          border-bottom: 2px solid #4a4a4a;
        }

        ul {
          padding-left: 1.4em;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        li {
          margin-bottom: 0.4em;
        }

        blockquote {
          margin-left: 0px;
          margin-right: 0px;
          padding-left: 1em;
          padding-top: 0.8em;
          padding-bottom: 0.8em;
          padding-right: 0.8em;
          border-left: 5px solid #1d7484;
          margin-bottom: 2.5rem;
          background-color: #f1f1f1;
        }

        blockquote p {
          margin-bottom: 0;
        }

        img, video {
          height: auto;
          max-width: 100%;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        iframe {
          max-width: 100%;
          width: 100%;
          aspect-ratio: 16 / 9;
          border: none;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        /* Pre and Code */
        pre {
          background-color: #f1f1f1;
          display: block;
          padding: 1em;
          overflow-x: auto;
          margin-top: 0px;
          margin-bottom: 2.5rem;
          font-size: 0.9em;
        }

        code, kbd, samp {
          font-size: 0.9em;
          padding: 0 0.5em;
          background-color: #f1f1f1;
          white-space: pre-wrap;
        }

        pre > code {
          padding: 0;
          background-color: transparent;
          white-space: pre;
          font-size: 1em;
        }

        /* Tables */
        table {
          text-align: justify;
          width: 100%;
          border-collapse: collapse;
          margin-bottom: 2rem;
        }

        td, th {
          padding: 0.5em;
          border-bottom: 1px solid #f1f1f1;
        }

        /* Buttons, forms and input */
        input, textarea {
          border: 1px solid #4a4a4a;
        }
        input:focus, textarea:focus {
          border: 1px solid #1d7484;
        }

        textarea {
          width: 100%;
        }

        .button, button, input[type=submit], input[type=reset], input[type=button], input[type=file]::file-selector-button {
          display: inline-block;
          padding: 5px 10px;
          text-align: center;
          text-decoration: none;
          white-space: nowrap;
          background-color: #1d7484;
          color: #f9f9f9;
          border-radius: 1px;
          border: 1px solid #1d7484;
          cursor: pointer;
          box-sizing: border-box;
        }
        .button[disabled], button[disabled], input[type=submit][disabled], input[type=reset][disabled], input[type=button][disabled], input[type=file]::file-selector-button[disabled] {
          cursor: default;
          opacity: 0.5;
        }
        .button:hover, button:hover, input[type=submit]:hover, input[type=reset]:hover, input[type=button]:hover, input[type=file]::file-selector-button:hover {
          background-color: #982c61;
          color: #f9f9f9;
          outline: 0;
        }
        .button:focus-visible, button:focus-visible, input[type=submit]:focus-visible, input[type=reset]:focus-visible, input[type=button]:focus-visible, input[type=file]::file-selector-button:focus-visible {
          outline-style: solid;
          outline-width: 2px;
        }

        textarea, select, input {
          color: #4a4a4a;
          padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
          margin-bottom: 10px;
          background-color: #f1f1f1;
          border: 1px solid #f1f1f1;
          border-radius: 4px;
          box-shadow: none;
          box-sizing: border-box;
        }
        textarea:focus, select:focus, input:focus {
          border: 1px solid #1d7484;
          outline: 0;
        }

        input[type=checkbox]:focus {
          outline: 1px dotted #1d7484;
        }

        label, legend, fieldset {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 600;
        }

    </style>
</head>
<body>
    <div class="container">
        %s
    </div>
</body>
</html>
</file>

<file path="app/src/main/assets/html_template_sepia.html">
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <style>
        /* Sepia theme based on Sakura css
         * ================
         * Minimal css theme.
         * Project: https://github.com/oxalorg/sakura/
         */
        /* Body */
        html {
          font-size: 62.5%;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        body {
          font-size: 1.8rem;
          line-height: 1.618;
          max-width: 38em;
          margin: auto;
          color: #4a3b2b;
          background-color: #f4ecd8;
          padding: 13px;
        }

        @media (max-width: 684px) {
          body {
            font-size: 1.53rem;
          }
        }
        @media (max-width: 382px) {
          body {
            font-size: 1.35rem;
          }
        }
        h1, h2, h3, h4, h5, h6 {
          line-height: 1.1;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
          font-weight: 700;
          margin-top: 3rem;
          margin-bottom: 1.5rem;
          overflow-wrap: break-word;
          word-wrap: break-word;
          -ms-word-break: break-all;
          word-break: break-word;
        }

        h1 {
          font-size: 2.35em;
        }

        h2 {
          font-size: 2em;
        }

        h3 {
          font-size: 1.75em;
        }

        h4 {
          font-size: 1.5em;
        }

        h5 {
          font-size: 1.25em;
        }

        h6 {
          font-size: 1em;
        }

        p {
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        small, sub, sup {
          font-size: 75%;
        }

        hr {
          border-color: #1d7484;
        }

        a {
          text-decoration: none;
          color: #7a4b21;
        }
        a:visited {
          color: #144f5a;
        }
        a:hover {
          color: #a76d3d;
          border-bottom: 2px solid #a76d3d;
        }

        ul {
          padding-left: 1.4em;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        li {
          margin-bottom: 0.4em;
        }

        blockquote {
          margin-left: 0px;
          margin-right: 0px;
          padding-left: 1em;
          padding-top: 0.8em;
          padding-bottom: 0.8em;
          padding-right: 0.8em;
          border-left: 5px solid #a76d3d;
          margin-bottom: 2.5rem;
          background-color: #f9f3e1;
        }

        blockquote p {
          margin-bottom: 0;
        }

        img, video {
          height: auto;
          max-width: 100%;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        iframe {
          max-width: 100%;
          width: 100%;
          aspect-ratio: 16 / 9;
          border: none;
          margin-top: 0px;
          margin-bottom: 2.5rem;
        }

        /* Pre and Code */
        pre {
          background-color: #f0e4c6;
          display: block;
          padding: 1em;
          overflow-x: auto;
          margin-top: 0px;
          margin-bottom: 2.5rem;
          font-size: 0.9em;
        }

        code, kbd, samp {
          font-size: 0.9em;
          padding: 0 0.5em;
          background-color: #f0e4c6;
          white-space: pre-wrap;
        }

        pre > code {
          padding: 0;
          background-color: transparent;
          white-space: pre;
          font-size: 1em;
        }

        /* Tables */
        table {
          text-align: justify;
          width: 100%;
          border-collapse: collapse;
          margin-bottom: 2rem;
        }

        td, th {
          padding: 0.5em;
          border-bottom: 1px solid #f1f1f1;
        }

        /* Buttons, forms and input */
        input, textarea {
          border: 1px solid #4a4a4a;
        }
        input:focus, textarea:focus {
          border: 1px solid #1d7484;
        }

        textarea {
          width: 100%;
        }

        .button, button, input[type=submit], input[type=reset], input[type=button], input[type=file]::file-selector-button {
          display: inline-block;
          padding: 5px 10px;
          text-align: center;
          text-decoration: none;
          white-space: nowrap;
          background-color: #a76d3d;
          color: #f9f9f9;
          border-radius: 1px;
          border: 1px solid #a86936;
          cursor: pointer;
          box-sizing: border-box;
        }
        .button[disabled], button[disabled], input[type=submit][disabled], input[type=reset][disabled], input[type=button][disabled], input[type=file]::file-selector-button[disabled] {
          cursor: default;
          opacity: 0.5;
        }
        .button:hover, button:hover, input[type=submit]:hover, input[type=reset]:hover, input[type=button]:hover, input[type=file]::file-selector-button:hover {
          background-color: #a5734a;
          color: #f9f9f9;
          outline: 0;
        }
        .button:focus-visible, button:focus-visible, input[type=submit]:focus-visible, input[type=reset]:focus-visible, input[type=button]:focus-visible, input[type=file]::file-selector-button:focus-visible {
          outline-style: solid;
          outline-width: 2px;
        }

        textarea, select, input {
          color: #4a4a4a;
          padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
          margin-bottom: 10px;
          background-color: #f9f3e1;
          border: 1px solid #f9f3e1;
          border-radius: 4px;
          box-shadow: none;
          box-sizing: border-box;
        }
        textarea:focus, select:focus, input:focus {
          border: 1px solid #a76d3d;
          outline: 0;
        }

        input[type=checkbox]:focus {
          outline: 1px dotted #a76d3d;
        }

        label, legend, fieldset {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 600;
        }

    </style>
</head>
<body>
<div class="container">
    %s
</div>
</body>
</html>
</file>

<file path="app/src/main/java/com/mydeck/app/domain/sync/ConnectivityMonitor.kt">
package com.mydeck.app.domain.sync

import kotlinx.coroutines.flow.Flow

interface ConnectivityMonitor {
    fun isNetworkAvailable(): Boolean
    fun isOnWifi(): Boolean
    fun isBatterySaverOn(): Boolean
    fun observeConnectivity(): Flow<Boolean>
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/sync/ConnectivityMonitorImpl.kt">
package com.mydeck.app.domain.sync

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.os.PowerManager
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ConnectivityMonitorImpl @Inject constructor(
    @ApplicationContext private val context: Context
) : ConnectivityMonitor {

    private val connectivityManager =
        context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    private val powerManager =
        context.getSystemService(Context.POWER_SERVICE) as PowerManager

    override fun isNetworkAvailable(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }

    override fun isOnWifi(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)
    }

    override fun isBatterySaverOn(): Boolean {
        return powerManager.isPowerSaveMode
    }

    override fun observeConnectivity(): Flow<Boolean> = callbackFlow {
        val callback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                trySend(true)
            }

            override fun onLost(network: Network) {
                trySend(false)
            }
        }

        connectivityManager.registerDefaultNetworkCallback(callback)
        // Emit initial state
        trySend(isNetworkAvailable())

        awaitClose {
            connectivityManager.unregisterNetworkCallback(callback)
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/sync/ContentSyncPolicy.kt">
package com.mydeck.app.domain.sync

import kotlinx.datetime.LocalDate

enum class ContentSyncMode {
    AUTOMATIC,   // Content fetched during bookmark sync
    MANUAL,      // Content fetched only when user opens a bookmark
    DATE_RANGE   // Content fetched for a user-specified date range on demand
}

data class ContentSyncConstraints(
    val wifiOnly: Boolean,
    val allowOnBatterySaver: Boolean
)

data class DateRangeParams(
    val from: LocalDate,
    val to: LocalDate
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/sync/ContentSyncPolicyEvaluator.kt">
package com.mydeck.app.domain.sync

import com.mydeck.app.io.prefs.SettingsDataStore
import javax.inject.Inject

class ContentSyncPolicyEvaluator @Inject constructor(
    private val settingsDataStore: SettingsDataStore,
    private val connectivityMonitor: ConnectivityMonitor
) {
    data class Decision(
        val allowed: Boolean,
        val blockedReason: String? = null
    )

    suspend fun canFetchContent(): Decision {
        val constraints = settingsDataStore.getContentSyncConstraints()

        if (constraints.wifiOnly && !connectivityMonitor.isOnWifi()) {
            return Decision(false, "Wi-Fi required")
        }

        if (!constraints.allowOnBatterySaver && connectivityMonitor.isBatterySaverOn()) {
            return Decision(false, "Battery saver active")
        }

        if (!connectivityMonitor.isNetworkAvailable()) {
            return Decision(false, "No network")
        }

        return Decision(true)
    }

    suspend fun shouldAutoFetchContent(): Boolean {
        return settingsDataStore.getContentSyncMode() == ContentSyncMode.AUTOMATIC
            && canFetchContent().allowed
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/usecase/LoadArticleUseCase.kt">
package com.mydeck.app.domain.usecase

import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.model.Bookmark.ContentState
import com.mydeck.app.io.db.dao.BookmarkDao
import com.mydeck.app.io.db.model.BookmarkEntity
import com.mydeck.app.io.rest.ReadeckApi
import timber.log.Timber
import java.io.IOException
import javax.inject.Inject

class LoadArticleUseCase @Inject constructor(
    private val bookmarkRepository: BookmarkRepository,
    private val readeckApi: ReadeckApi,
    private val bookmarkDao: BookmarkDao
) {
    sealed class Result {
        data object Success : Result()
        data object AlreadyDownloaded : Result()
        data class TransientFailure(val reason: String) : Result()
        data class PermanentFailure(val reason: String) : Result()
    }

    suspend fun execute(bookmarkId: String): Result {
        val bookmark = bookmarkRepository.getBookmarkById(bookmarkId)

        // Guard: never re-fetch downloaded content
        if (bookmark.contentState == ContentState.DOWNLOADED) {
            return Result.AlreadyDownloaded
        }

        // Guard: don't attempt for permanent no-content
        if (bookmark.contentState == ContentState.PERMANENT_NO_CONTENT) {
            return Result.PermanentFailure(bookmark.contentFailureReason ?: "No content available")
        }

        if (!bookmark.hasArticle) {
            // Server says no article content  mark permanent
            bookmarkDao.updateContentState(
                bookmarkId, BookmarkEntity.ContentState.PERMANENT_NO_CONTENT.value,
                "No article content available (type=${bookmark.type})"
            )
            Timber.i("Bookmark has no article [type=${bookmark.type}]")
            return Result.PermanentFailure("No article content available")
        }

        return try {
            val response = readeckApi.getArticle(bookmarkId)
            if (response.isSuccessful && response.body() != null) {
                val content = response.body()!!
                val bookmarkToSave = bookmark.copy(
                    articleContent = content,
                    contentState = ContentState.DOWNLOADED,
                    contentFailureReason = null
                )
                bookmarkRepository.insertBookmarks(listOf(bookmarkToSave))
                Result.Success
            } else {
                val reason = "HTTP ${response.code()}"
                bookmarkDao.updateContentState(bookmarkId, BookmarkEntity.ContentState.DIRTY.value, reason)
                Timber.w("Content fetch failed for $bookmarkId: $reason")
                Result.TransientFailure(reason)
            }
        } catch (e: IOException) {
            val reason = "Network error: ${e.message}"
            bookmarkDao.updateContentState(bookmarkId, BookmarkEntity.ContentState.DIRTY.value, reason)
            Timber.w(e, "Content fetch network error for $bookmarkId")
            Result.TransientFailure(reason)
        } catch (e: Exception) {
            val reason = "Unexpected error: ${e.message}"
            bookmarkDao.updateContentState(bookmarkId, BookmarkEntity.ContentState.DIRTY.value, reason)
            Timber.e(e, "Content fetch unexpected error for $bookmarkId")
            Result.TransientFailure(reason)
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/Converters.kt">
package com.mydeck.app.io.db

import androidx.room.TypeConverter
import com.mydeck.app.io.db.model.BookmarkEntity
import kotlinx.datetime.Instant

class Converters {
    @TypeConverter
    fun fromTimestamp(value: Long?): Instant? {
        return value?.let { Instant.fromEpochMilliseconds(it) }
    }

    @TypeConverter
    fun instantToTimestamp(instant: Instant?): Long? {
        return instant?.toEpochMilliseconds()
    }

    @TypeConverter
    fun fromStringList(value: String?): List<String> {
        return value?.split(",")?.filter { it.isNotEmpty() } ?: emptyList()
    }

    @TypeConverter
    fun stringListToString(list: List<String>?): String {
        return list?.joinToString(",") ?: ""
    }

    @TypeConverter
    fun fromState(state: BookmarkEntity.State): Int {
        return when (state) {
            BookmarkEntity.State.LOADED -> BookmarkEntity.State.LOADED.value
            BookmarkEntity.State.ERROR -> BookmarkEntity.State.ERROR.value
            BookmarkEntity.State.LOADING -> BookmarkEntity.State.LOADING.value
        }
    }

    @TypeConverter
    fun toState(stateValue: Int): BookmarkEntity.State {
        return when (stateValue) {
            BookmarkEntity.State.LOADED.value -> BookmarkEntity.State.LOADED
            BookmarkEntity.State.ERROR.value -> BookmarkEntity.State.ERROR
            BookmarkEntity.State.LOADING.value -> BookmarkEntity.State.LOADING
            else -> BookmarkEntity.State.ERROR
        }
    }

    @TypeConverter
    fun fromType(state: BookmarkEntity.Type): String {
        return when (state) {
            BookmarkEntity.Type.ARTICLE -> BookmarkEntity.Type.ARTICLE.value
            BookmarkEntity.Type.PHOTO -> BookmarkEntity.Type.PHOTO.value
            BookmarkEntity.Type.VIDEO -> BookmarkEntity.Type.VIDEO.value
        }
    }

    @TypeConverter
    fun toType(stateValue: String): BookmarkEntity.Type {
        return when (stateValue) {
            BookmarkEntity.Type.ARTICLE.value -> BookmarkEntity.Type.ARTICLE
            BookmarkEntity.Type.PHOTO.value -> BookmarkEntity.Type.PHOTO
            BookmarkEntity.Type.VIDEO.value -> BookmarkEntity.Type.VIDEO
            else -> throw IllegalStateException("$stateValue can not be converted to BookmarkEntity.Type")
        }
    }

    @TypeConverter
    fun fromContentState(contentState: BookmarkEntity.ContentState): Int {
        return contentState.value
    }

    @TypeConverter
    fun toContentState(value: Int): BookmarkEntity.ContentState {
        return when (value) {
            BookmarkEntity.ContentState.NOT_ATTEMPTED.value -> BookmarkEntity.ContentState.NOT_ATTEMPTED
            BookmarkEntity.ContentState.DOWNLOADED.value -> BookmarkEntity.ContentState.DOWNLOADED
            BookmarkEntity.ContentState.DIRTY.value -> BookmarkEntity.ContentState.DIRTY
            BookmarkEntity.ContentState.PERMANENT_NO_CONTENT.value -> BookmarkEntity.ContentState.PERMANENT_NO_CONTENT
            else -> BookmarkEntity.ContentState.NOT_ATTEMPTED
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/auth/NotificationHelper.kt">
package com.mydeck.app.io.rest.auth

import android.content.Context
import androidx.core.app.NotificationManagerCompat

interface NotificationHelper {
    fun showUnauthorizedNotification()
}

class NotificationHelperImpl(
    private val context: Context,
    private val notificationManager: NotificationManagerCompat
) : NotificationHelper {

    @android.annotation.SuppressLint("MissingPermission")
    override fun showUnauthorizedNotification() {
        NotificationUtil.showUnauthorizedNotification(context, notificationManager)
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/about/AboutScreen.kt">
package com.mydeck.app.ui.about

import android.os.Build
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Link
import androidx.compose.material.icons.filled.List
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.mydeck.app.BuildConfig
import com.mydeck.app.R
import com.mydeck.app.ui.navigation.OpenSourceLibrariesRoute
import com.mydeck.app.util.openUrlInCustomTab
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@Composable
fun AboutScreen(navHostController: NavHostController) {
    val viewModel: AboutViewModel = hiltViewModel()
    val navigationEvent = viewModel.navigationEvent.collectAsState()

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                AboutViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
                AboutViewModel.NavigationEvent.NavigateToOpenSourceLibraries -> {
                    navHostController.navigate(OpenSourceLibrariesRoute)
                }
            }
            viewModel.onNavigationEventConsumed()
        }
    }

    val context = LocalContext.current
    AboutScreenContent(
        onBackClick = { viewModel.onClickBack() },
        onOpenSourceLibrariesClick = { viewModel.onClickOpenSourceLibraries() },
        onUrlClick = { url -> openUrlInCustomTab(context, url) }
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AboutScreenContent(
    onBackClick: () -> Unit,
    onOpenSourceLibrariesClick: () -> Unit,
    onUrlClick: (String) -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(stringResource(R.string.about_title)) },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .verticalScroll(rememberScrollState())
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // App Header
            Text(
                text = stringResource(R.string.app_name),
                style = MaterialTheme.typography.headlineMedium,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(R.string.about_version, BuildConfig.VERSION_NAME),
                style = MaterialTheme.typography.bodyLarge,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(24.dp))

            // Description
            Text(
                text = stringResource(R.string.about_description),
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(24.dp))

            // Credits Section
            HorizontalDivider()
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = stringResource(R.string.about_credits_title),
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(R.string.about_credits_app_author),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(R.string.about_credits_readeck),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            // FORK_INFO_START - Remove this section if merging back to original repo
            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(R.string.about_credits_fork),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )
            // FORK_INFO_END

            Spacer(modifier = Modifier.height(24.dp))

            // System Info Section
            HorizontalDivider()
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = stringResource(R.string.about_system_info_title),
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(
                    R.string.about_system_info_version,
                    BuildConfig.VERSION_NAME,
                    BuildConfig.VERSION_CODE
                ),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = stringResource(
                    R.string.about_system_info_build_time,
                    SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                        .format(Date(BuildConfig.BUILD_TIME.toLong()))
                ),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = stringResource(
                    R.string.about_system_info_android,
                    Build.VERSION.RELEASE,
                    Build.VERSION.SDK_INT
                ),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = stringResource(
                    R.string.about_system_info_device,
                    Build.MANUFACTURER,
                    Build.MODEL
                ),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(24.dp))

            // Project Links Section
            HorizontalDivider()
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = stringResource(R.string.about_project_title),
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            // FORK_INFO_START - Remove this section if merging back to original repo
            // Fork Repository
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onUrlClick("https://github.com/NateEaton/mydeck-android") }
                    .padding(vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
            ) {
                Icon(
                    Icons.Filled.Link,
                    contentDescription = null,
                    modifier = Modifier.padding(end = 16.dp)
                )
                Text(
                    text = stringResource(R.string.about_project_this_repo),
                    style = MaterialTheme.typography.bodyMedium
                )
            }
            // FORK_INFO_END

            // Original Repository
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onUrlClick("https://github.com/jensomato/ReadeckApp") }
                    .padding(vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
            ) {
                Icon(
                    Icons.Filled.Link,
                    contentDescription = null,
                    modifier = Modifier.padding(end = 16.dp)
                )
                Text(
                    text = stringResource(R.string.about_project_original_repo),
                    style = MaterialTheme.typography.bodyMedium
                )
            }

            // Readeck Server
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onUrlClick("https://codeberg.org/readeck/readeck") }
                    .padding(vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
            ) {
                Icon(
                    Icons.Filled.Link,
                    contentDescription = null,
                    modifier = Modifier.padding(end = 16.dp)
                )
                Text(
                    text = stringResource(R.string.about_project_readeck_repo),
                    style = MaterialTheme.typography.bodyMedium
                )
            }

            Spacer(modifier = Modifier.height(24.dp))

            // License Section
            HorizontalDivider()
            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = stringResource(R.string.about_license_title),
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(R.string.about_license_text),
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = stringResource(R.string.about_license_readeck),
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(24.dp))

            // Open Source Libraries Link
            HorizontalDivider()
            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { onOpenSourceLibrariesClick() }
                    .padding(vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically,
            ) {
                Icon(
                    Icons.Filled.List,
                    contentDescription = stringResource(R.string.settings_open_source_libraries),
                    modifier = Modifier.padding(end = 16.dp)
                )
                Column {
                    Text(
                        text = stringResource(R.string.settings_open_source_libraries),
                        style = MaterialTheme.typography.titleMedium
                    )
                    Text(
                        text = stringResource(R.string.settings_open_source_libraries_subtitle),
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/components/ImageComponents.kt">
package com.mydeck.app.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.BrokenImage
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun ErrorPlaceholderImage(modifier: Modifier, imageContentDescription: String) {
    // Use a subtle dark gray that blends with the UI
    val placeholderBackgroundColor = Color(0xFF2C2C2C)
    Box(
        modifier = modifier
            .fillMaxSize()
            .background(placeholderBackgroundColor),
        contentAlignment = Alignment.Center
    ) {
        Icon(
            imageVector = Icons.Filled.BrokenImage,
            contentDescription = imageContentDescription,
            modifier = Modifier.size(48.dp),
            tint = Color(0xFF505050) // Slightly lighter gray for the icon
        )
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/navigation/Routes.kt">
package com.mydeck.app.ui.navigation

import kotlinx.serialization.Serializable

@Serializable
data class BookmarkListRoute(val sharedText: String? = null)

@Serializable
data class BookmarkDetailRoute(
    val bookmarkId: String,
    val showOriginal: Boolean = false
)

@Serializable
object AccountSettingsRoute

@Serializable
object SettingsRoute

@Serializable
object OpenSourceLibrariesRoute

@Serializable
object LogViewRoute

@Serializable
object SyncSettingsRoute

@Serializable
object UiSettingsRoute

@Serializable
object AboutRoute
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/SyncSettingsScreen.kt">
package com.mydeck.app.ui.settings

import android.Manifest
import android.os.Build
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.rememberPermissionState
import com.mydeck.app.R
import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.domain.sync.ContentSyncMode
import com.mydeck.app.ui.theme.Typography
import kotlinx.datetime.Instant
import kotlinx.datetime.LocalDate
import kotlinx.datetime.TimeZone
import kotlinx.datetime.atStartOfDayIn
import kotlinx.datetime.toLocalDateTime

@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun SyncSettingsScreen(
    navHostController: NavHostController
) {
    val viewModel: SyncSettingsViewModel = hiltViewModel()
    val settingsUiState = viewModel.uiState.collectAsState().value
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    val notificationPermissionState = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        rememberPermissionState(Manifest.permission.POST_NOTIFICATIONS)
    } else {
        null
    }?.also {
        viewModel.setPermissionState(it)
    }

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                is SyncSettingsViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
            }
            viewModel.onNavigationEventConsumed()
        }
    }

    // Handle dialogs
    when (settingsUiState.showDialog) {
        SyncSettingsDialog.BookmarkSyncFrequencyDialog -> {
            AutoSyncTimeframeDialog(
                autoSyncTimeframeOptions = settingsUiState.bookmarkSyncFrequencyOptions,
                onDismissRequest = { viewModel.onDismissDialog() },
                onElementSelected = { viewModel.onBookmarkSyncFrequencySelected(it) }
            )
        }
        SyncSettingsDialog.BackgroundRationaleDialog -> {
            BackgroundSyncRationaleDialog(
                onConfirm = { viewModel.onRationaleDialogConfirm() },
                onDismiss = { viewModel.onDismissDialog() }
            )
        }
        SyncSettingsDialog.PermissionRequest -> {
            SideEffect {
                viewModel.onDismissDialog()
                notificationPermissionState?.launchPermissionRequest()
            }
        }
        SyncSettingsDialog.DateFromPicker -> {
            DatePickerDialogWrapper(
                initialDate = settingsUiState.dateRangeFrom,
                onDateSelected = { viewModel.onDateRangeFromSelected(it) },
                onDismiss = { viewModel.onDismissDialog() }
            )
        }
        SyncSettingsDialog.DateToPicker -> {
            DatePickerDialogWrapper(
                initialDate = settingsUiState.dateRangeTo,
                onDateSelected = { viewModel.onDateRangeToSelected(it) },
                onDismiss = { viewModel.onDismissDialog() }
            )
        }
        null -> { /* noop */ }
    }

    SyncSettingsView(
        snackbarHostState = snackbarHostState,
        settingsUiState = settingsUiState,
        onClickBack = { viewModel.onClickBack() },
        onClickBookmarkSyncFrequency = { viewModel.onClickBookmarkSyncFrequency() },
        onContentSyncModeSelected = { viewModel.onContentSyncModeSelected(it) },
        onClickDateFrom = { viewModel.onShowDialog(SyncSettingsDialog.DateFromPicker) },
        onClickDateTo = { viewModel.onShowDialog(SyncSettingsDialog.DateToPicker) },
        onClickDateRangeDownload = { viewModel.onClickDateRangeDownload() },
        onWifiOnlyChanged = { viewModel.onWifiOnlyChanged(it) },
        onAllowBatterySaverChanged = { viewModel.onAllowBatterySaverChanged(it) }
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SyncSettingsView(
    modifier: Modifier = Modifier,
    snackbarHostState: SnackbarHostState,
    settingsUiState: SyncSettingsUiState,
    onClickBack: () -> Unit,
    onClickBookmarkSyncFrequency: () -> Unit,
    onContentSyncModeSelected: (ContentSyncMode) -> Unit,
    onClickDateFrom: () -> Unit,
    onClickDateTo: () -> Unit,
    onClickDateRangeDownload: () -> Unit,
    onWifiOnlyChanged: (Boolean) -> Unit,
    onAllowBatterySaverChanged: (Boolean) -> Unit,
) {
    Scaffold(
        modifier = modifier,
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text(stringResource(R.string.sync_settings_topbar_title)) },
                navigationIcon = {
                    IconButton(
                        onClick = onClickBack,
                        modifier = Modifier.testTag(SyncSettingsScreenTestTags.BACK_BUTTON)
                    ) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .padding(horizontal = 16.dp)
                .fillMaxSize()
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // --- Section 1: Bookmark Sync ---
            BookmarkSyncSection(
                frequency = settingsUiState.bookmarkSyncFrequency,
                nextRun = settingsUiState.nextAutoSyncRun,
                onClickFrequency = onClickBookmarkSyncFrequency
            )

            Spacer(modifier = Modifier.height(8.dp))

            // --- Section 2: Content Sync ---
            ContentSyncSection(
                contentSyncMode = settingsUiState.contentSyncMode,
                dateRangeFrom = settingsUiState.dateRangeFrom,
                dateRangeTo = settingsUiState.dateRangeTo,
                isDateRangeDownloading = settingsUiState.isDateRangeDownloading,
                onContentSyncModeSelected = onContentSyncModeSelected,
                onClickDateFrom = onClickDateFrom,
                onClickDateTo = onClickDateTo,
                onClickDateRangeDownload = onClickDateRangeDownload
            )

            Spacer(modifier = Modifier.height(8.dp))

            // --- Section 3: Constraints ---
            ConstraintsSection(
                wifiOnly = settingsUiState.wifiOnly,
                allowBatterySaver = settingsUiState.allowBatterySaver,
                onWifiOnlyChanged = onWifiOnlyChanged,
                onAllowBatterySaverChanged = onAllowBatterySaverChanged
            )

            Spacer(modifier = Modifier.height(8.dp))

            // --- Section 4: Sync Status ---
            SyncStatusSection(syncStatus = settingsUiState.syncStatus)

            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}

// --- Section 1: Bookmark Sync ---
@Composable
private fun BookmarkSyncSection(
    frequency: AutoSyncTimeframe,
    nextRun: String?,
    onClickFrequency: () -> Unit
) {
    Text(
        text = stringResource(R.string.sync_bookmark_section_title),
        style = Typography.titleSmall
    )
    Text(
        text = stringResource(R.string.sync_bookmark_description),
        style = Typography.bodySmall,
        color = MaterialTheme.colorScheme.onSurfaceVariant
    )

    Row(
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClickFrequency)
            .padding(vertical = 8.dp)
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(text = stringResource(R.string.sync_bookmark_frequency_label))
            val nextRunMsg = nextRun?.let {
                stringResource(R.string.auto_sync_next_run, it)
            } ?: stringResource(R.string.auto_sync_next_run_null)
            Text(
                text = nextRunMsg,
                style = Typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
        Text(
            text = stringResource(frequency.toLabelResource()),
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.primary
        )
    }
}

// --- Section 2: Content Sync ---
@Composable
private fun ContentSyncSection(
    contentSyncMode: ContentSyncMode,
    dateRangeFrom: LocalDate?,
    dateRangeTo: LocalDate?,
    isDateRangeDownloading: Boolean,
    onContentSyncModeSelected: (ContentSyncMode) -> Unit,
    onClickDateFrom: () -> Unit,
    onClickDateTo: () -> Unit,
    onClickDateRangeDownload: () -> Unit
) {
    Text(
        text = stringResource(R.string.sync_content_section_title),
        style = Typography.titleSmall
    )

    // Automatic
    ContentSyncRadioOption(
        selected = contentSyncMode == ContentSyncMode.AUTOMATIC,
        title = stringResource(R.string.sync_content_automatic),
        description = stringResource(R.string.sync_content_automatic_desc),
        onClick = { onContentSyncModeSelected(ContentSyncMode.AUTOMATIC) }
    )

    // Manual
    ContentSyncRadioOption(
        selected = contentSyncMode == ContentSyncMode.MANUAL,
        title = stringResource(R.string.sync_content_manual),
        description = stringResource(R.string.sync_content_manual_desc),
        onClick = { onContentSyncModeSelected(ContentSyncMode.MANUAL) }
    )

    // Date Range
    ContentSyncRadioOption(
        selected = contentSyncMode == ContentSyncMode.DATE_RANGE,
        title = stringResource(R.string.sync_content_date_range),
        description = stringResource(R.string.sync_content_date_range_desc),
        onClick = { onContentSyncModeSelected(ContentSyncMode.DATE_RANGE) }
    )

    // Date range controls (shown when Date Range is selected)
    if (contentSyncMode == ContentSyncMode.DATE_RANGE) {
        Column(
            modifier = Modifier.padding(start = 40.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // From date
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = stringResource(R.string.sync_content_date_from),
                    style = Typography.bodyMedium,
                    modifier = Modifier.width(48.dp)
                )
                OutlinedButton(
                    onClick = onClickDateFrom,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(dateRangeFrom?.toString() ?: "Select date")
                }
            }

            // To date
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = stringResource(R.string.sync_content_date_to),
                    style = Typography.bodyMedium,
                    modifier = Modifier.width(48.dp)
                )
                OutlinedButton(
                    onClick = onClickDateTo,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(dateRangeTo?.toString() ?: "Select date")
                }
            }

            // Download button
            Button(
                onClick = onClickDateRangeDownload,
                enabled = dateRangeFrom != null && dateRangeTo != null && !isDateRangeDownloading,
                modifier = Modifier.fillMaxWidth()
            ) {
                if (isDateRangeDownloading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(16.dp),
                        strokeWidth = 2.dp,
                        color = MaterialTheme.colorScheme.onPrimary
                    )
                    Spacer(Modifier.width(8.dp))
                    Text(stringResource(R.string.sync_content_downloading))
                } else {
                    Text(stringResource(R.string.sync_content_download_button))
                }
            }
        }
    }
}

@Composable
private fun ContentSyncRadioOption(
    selected: Boolean,
    title: String,
    description: String,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .selectable(
                selected = selected,
                onClick = onClick,
                role = Role.RadioButton
            )
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.Top
    ) {
        RadioButton(
            selected = selected,
            onClick = null,
            modifier = Modifier.padding(top = 2.dp)
        )
        Column(modifier = Modifier.padding(start = 12.dp)) {
            Text(text = title, style = Typography.bodyMedium)
            Text(
                text = description,
                style = Typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

// --- Section 3: Constraints ---
@Composable
private fun ConstraintsSection(
    wifiOnly: Boolean,
    allowBatterySaver: Boolean,
    onWifiOnlyChanged: (Boolean) -> Unit,
    onAllowBatterySaverChanged: (Boolean) -> Unit
) {
    Text(
        text = stringResource(R.string.sync_constraints_section_title),
        style = Typography.titleSmall
    )

    Row(
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = stringResource(R.string.sync_wifi_only),
            modifier = Modifier.weight(1f)
        )
        Switch(
            checked = wifiOnly,
            onCheckedChange = onWifiOnlyChanged
        )
    }

    Row(
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = stringResource(R.string.sync_allow_battery_saver),
            modifier = Modifier.weight(1f)
        )
        Switch(
            checked = allowBatterySaver,
            onCheckedChange = onAllowBatterySaverChanged
        )
    }
}

// --- Section 4: Sync Status ---
@Composable
private fun SyncStatusSection(syncStatus: SyncStatus) {
    Text(
        text = stringResource(R.string.sync_status_section_title),
        style = Typography.titleSmall
    )

    Card(
        modifier = Modifier.fillMaxWidth(),
        border = BorderStroke(1.dp, MaterialTheme.colorScheme.outlineVariant),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            // Bookmark counts
            Text(
                text = "Bookmarks",
                style = Typography.labelMedium,
                color = MaterialTheme.colorScheme.primary
            )
            Text(
                text = stringResource(R.string.sync_status_total, syncStatus.totalBookmarks),
                style = Typography.bodySmall
            )
            Text(
                text = stringResource(R.string.sync_status_unread, syncStatus.unread),
                style = Typography.bodySmall
            )
            Text(
                text = stringResource(R.string.sync_status_archived, syncStatus.archived),
                style = Typography.bodySmall
            )
            Text(
                text = stringResource(R.string.sync_status_favorites, syncStatus.favorites),
                style = Typography.bodySmall
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Content counts
            Text(
                text = "Content",
                style = Typography.labelMedium,
                color = MaterialTheme.colorScheme.primary
            )
            Text(
                text = stringResource(R.string.sync_status_content_downloaded, syncStatus.contentDownloaded),
                style = Typography.bodySmall
            )
            Text(
                text = stringResource(R.string.sync_status_content_available, syncStatus.contentAvailable),
                style = Typography.bodySmall
            )
            Text(
                text = stringResource(R.string.sync_status_content_dirty, syncStatus.contentDirty),
                style = Typography.bodySmall
            )
            Text(
                text = stringResource(R.string.sync_status_no_content, syncStatus.permanentNoContent),
                style = Typography.bodySmall
            )

            // Last sync
            syncStatus.lastSyncTimestamp?.let { ts ->
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = stringResource(R.string.sync_status_last_sync, ts),
                    style = Typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

// --- Date Picker Dialog ---
@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun DatePickerDialogWrapper(
    initialDate: LocalDate?,
    onDateSelected: (LocalDate) -> Unit,
    onDismiss: () -> Unit
) {
    val initialMillis = initialDate?.atStartOfDayIn(TimeZone.UTC)?.toEpochMilliseconds()
    val datePickerState = rememberDatePickerState(initialSelectedDateMillis = initialMillis)

    DatePickerDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(onClick = {
                datePickerState.selectedDateMillis?.let { millis ->
                    val instant = Instant.fromEpochMilliseconds(millis)
                    val localDate = instant.toLocalDateTime(TimeZone.UTC).date
                    onDateSelected(localDate)
                }
                onDismiss()
            }) {
                Text(stringResource(R.string.ok))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(stringResource(R.string.cancel))
            }
        }
    ) {
        DatePicker(state = datePickerState)
    }
}

// --- Background Sync Rationale Dialog ---
@Composable
private fun BackgroundSyncRationaleDialog(
    onConfirm: () -> Unit,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(stringResource(R.string.background_sync_rationale_title)) },
        text = { Text(stringResource(R.string.background_sync_rationale_body)) },
        confirmButton = {
            Button(onClick = onConfirm) {
                Text(stringResource(R.string.background_sync_rationale_allow))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(stringResource(R.string.cancel))
            }
        }
    )
}

object SyncSettingsScreenTestTags {
    const val BACK_BUTTON = "AccountSettingsScreenTestTags.BackButton"
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/SyncSettingsViewModel.kt">
package com.mydeck.app.ui.settings

import android.content.Context
import android.os.Build
import androidx.annotation.StringRes
import androidx.compose.runtime.Immutable
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.Constraints
import androidx.work.Data
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.PermissionState
import com.google.accompanist.permissions.isGranted
import com.google.accompanist.permissions.shouldShowRationale
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import com.mydeck.app.R
import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.domain.sync.ContentSyncMode
import com.mydeck.app.domain.sync.DateRangeParams
import com.mydeck.app.domain.usecase.FullSyncUseCase
import com.mydeck.app.io.db.dao.BookmarkDao
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.worker.DateRangeContentSyncWorker
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.datetime.LocalDate
import timber.log.Timber
import java.text.DateFormat
import java.util.Date
import javax.inject.Inject

@OptIn(ExperimentalPermissionsApi::class)
@HiltViewModel
class SyncSettingsViewModel @Inject constructor(
    private val bookmarkDao: BookmarkDao,
    private val settingsDataStore: SettingsDataStore,
    private val fullSyncUseCase: FullSyncUseCase,
    private val workManager: WorkManager,
    @ApplicationContext private val context: Context,
) : ViewModel() {
    private var _permissionState: PermissionState? = null
    private val dateFormat = DateFormat.getDateTimeInstance(
        DateFormat.MEDIUM, DateFormat.MEDIUM
    )
    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()

    // Bookmark sync
    private val bookmarkSyncFrequency = MutableStateFlow(AutoSyncTimeframe.HOURS_01)

    // Content sync
    private val contentSyncMode = MutableStateFlow(ContentSyncMode.AUTOMATIC)
    private val dateRangeFrom = MutableStateFlow<LocalDate?>(null)
    private val dateRangeTo = MutableStateFlow<LocalDate?>(null)
    private val isDateRangeDownloading = MutableStateFlow(false)

    // Constraints
    private val wifiOnly = MutableStateFlow(false)
    private val allowBatterySaver = MutableStateFlow(true)

    // Dialog
    private val showDialog = MutableStateFlow<SyncSettingsDialog?>(null)

    // Last sync timestamp
    private val lastSyncTimestamp = MutableStateFlow<String?>(null)

    // Sync status from DB
    private val detailedSyncStatus = bookmarkDao.observeDetailedSyncStatus()
        .map { it ?: BookmarkDao.DetailedSyncStatusCounts(0, 0, 0, 0, 0, 0, 0, 0) }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5000),
            BookmarkDao.DetailedSyncStatusCounts(0, 0, 0, 0, 0, 0, 0, 0)
        )

    // Work info for next scheduled run
    private val workInfoNext = fullSyncUseCase.workInfoFlow.map { workInfoList ->
        workInfoList.firstOrNull()?.let {
            if (it.state == WorkInfo.State.ENQUEUED) it.nextScheduleTimeMillis else null
        }
    }

    // Date range download work status
    private val dateRangeWorkStatus = workManager
        .getWorkInfosForUniqueWorkFlow(DateRangeContentSyncWorker.UNIQUE_WORK_NAME)
        .map { workInfoList ->
            workInfoList.any { it.state == WorkInfo.State.RUNNING || it.state == WorkInfo.State.ENQUEUED }
        }

    init {
        viewModelScope.launch {
            // Load all settings
            bookmarkSyncFrequency.value = settingsDataStore.getAutoSyncTimeframe().let { timeframe ->
                // If MANUAL, default to HOURS_01 since bookmark sync is always on
                if (timeframe == AutoSyncTimeframe.MANUAL) AutoSyncTimeframe.HOURS_01 else timeframe
            }
            contentSyncMode.value = settingsDataStore.getContentSyncMode()
            val constraints = settingsDataStore.getContentSyncConstraints()
            wifiOnly.value = constraints.wifiOnly
            allowBatterySaver.value = constraints.allowOnBatterySaver
            settingsDataStore.getDateRangeParams()?.let {
                dateRangeFrom.value = it.from
                dateRangeTo.value = it.to
            }
            settingsDataStore.getLastSyncTimestamp()?.let {
                lastSyncTimestamp.value = dateFormat.format(Date(it.toEpochMilliseconds()))
            }

            // Perform settings migration for existing users
            performSettingsMigration()
        }

        // Observe date range work status
        viewModelScope.launch {
            dateRangeWorkStatus.collect { running ->
                isDateRangeDownloading.value = running
            }
        }
    }

    private suspend fun performSettingsMigration() {
        val migrationKey = "sync_settings_v3_migrated"
        val prefs = context.getSharedPreferences("sync_migration", Context.MODE_PRIVATE)
        if (prefs.getBoolean(migrationKey, false)) return

        // Migrate: if autoSyncEnabled was false, set content mode to MANUAL
        val wasAutoSyncEnabled = settingsDataStore.isAutoSyncEnabled()
        if (!wasAutoSyncEnabled) {
            settingsDataStore.saveContentSyncMode(ContentSyncMode.MANUAL)
            contentSyncMode.value = ContentSyncMode.MANUAL
        }

        // Ensure bookmark sync is always scheduled (was previously toggle-able)
        val timeframe = settingsDataStore.getAutoSyncTimeframe()
        if (timeframe != AutoSyncTimeframe.MANUAL) {
            fullSyncUseCase.scheduleFullSyncWorker(timeframe)
        } else {
            // Default to hourly if it was manual
            settingsDataStore.saveAutoSyncTimeframe(AutoSyncTimeframe.HOURS_01)
            fullSyncUseCase.scheduleFullSyncWorker(AutoSyncTimeframe.HOURS_01)
            bookmarkSyncFrequency.value = AutoSyncTimeframe.HOURS_01
        }

        // Mark migration done
        prefs.edit().putBoolean(migrationKey, true).apply()
        Timber.i("Sync settings v3 migration completed")
    }

    val uiState: StateFlow<SyncSettingsUiState> = combine(
        bookmarkSyncFrequency,
        contentSyncMode,
        showDialog,
        workInfoNext,
        wifiOnly,
    ) { freq, mode, dialog, next, wifi ->
        SyncSettingsPartial1(freq, mode, dialog, next, wifi)
    }.combine(
        combine(
            allowBatterySaver,
            dateRangeFrom,
            dateRangeTo,
            isDateRangeDownloading,
            detailedSyncStatus
        ) { battery, from, to, downloading, status ->
            SyncSettingsPartial2(battery, from, to, downloading, status)
        }
    ) { p1, p2 ->
        SyncSettingsUiState(
            bookmarkSyncFrequency = p1.freq,
            bookmarkSyncFrequencyOptions = getBookmarkSyncOptions(p1.freq),
            nextAutoSyncRun = p1.next?.let { dateFormat.format(Date(it)) },
            contentSyncMode = p1.mode,
            dateRangeFrom = p2.from,
            dateRangeTo = p2.to,
            isDateRangeDownloading = p2.downloading,
            wifiOnly = p1.wifi,
            allowBatterySaver = p2.battery,
            syncStatus = SyncStatus(
                totalBookmarks = p2.status.total,
                unread = p2.status.unread,
                archived = p2.status.archived,
                favorites = p2.status.favorites,
                contentDownloaded = p2.status.contentDownloaded,
                contentAvailable = p2.status.contentAvailable,
                contentDirty = p2.status.contentDirty,
                permanentNoContent = p2.status.permanentNoContent,
                lastSyncTimestamp = null // set below
            ),
            showDialog = p1.dialog
        )
    }.combine(lastSyncTimestamp) { state, ts ->
        state.copy(syncStatus = state.syncStatus.copy(lastSyncTimestamp = ts))
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = SyncSettingsUiState()
    )

    // --- Bookmark Sync ---

    fun onClickBookmarkSyncFrequency() {
        showDialog.value = SyncSettingsDialog.BookmarkSyncFrequencyDialog
    }

    fun onBookmarkSyncFrequencySelected(selected: AutoSyncTimeframe) {
        // Don't allow MANUAL - bookmark sync is always on
        val effective = if (selected == AutoSyncTimeframe.MANUAL) AutoSyncTimeframe.HOURS_01 else selected
        fullSyncUseCase.scheduleFullSyncWorker(effective)
        viewModelScope.launch {
            settingsDataStore.saveAutoSyncTimeframe(effective)
            bookmarkSyncFrequency.value = effective
        }
    }

    // --- Content Sync ---

    fun onContentSyncModeSelected(mode: ContentSyncMode) {
        viewModelScope.launch {
            settingsDataStore.saveContentSyncMode(mode)
            contentSyncMode.value = mode

            // If switching to AUTOMATIC, may need notification permission
            if (mode == ContentSyncMode.AUTOMATIC) {
                requestBackgroundPermissionIfNeeded()
            }
        }
    }

    fun onDateRangeFromSelected(date: LocalDate) {
        dateRangeFrom.value = date
        saveDateRangeIfBothSet()
    }

    fun onDateRangeToSelected(date: LocalDate) {
        dateRangeTo.value = date
        saveDateRangeIfBothSet()
    }

    private fun saveDateRangeIfBothSet() {
        val from = dateRangeFrom.value ?: return
        val to = dateRangeTo.value ?: return
        viewModelScope.launch {
            settingsDataStore.saveDateRangeParams(DateRangeParams(from, to))
        }
    }

    fun onClickDateRangeDownload() {
        val from = dateRangeFrom.value ?: return
        val to = dateRangeTo.value ?: return

        // Request permission if needed
        requestBackgroundPermissionIfNeeded()

        // Convert LocalDate to epoch millis for the worker
        val fromEpoch = from.toEpochDays().toLong() * 86400L * 1000L
        val toEpoch = (to.toEpochDays().toLong() + 1) * 86400L * 1000L // End of day

        val inputData = Data.Builder()
            .putLong(DateRangeContentSyncWorker.PARAM_FROM_EPOCH, fromEpoch)
            .putLong(DateRangeContentSyncWorker.PARAM_TO_EPOCH, toEpoch)
            .build()

        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val request = OneTimeWorkRequestBuilder<DateRangeContentSyncWorker>()
            .setInputData(inputData)
            .setConstraints(constraints)
            .build()

        workManager.enqueueUniqueWork(
            DateRangeContentSyncWorker.UNIQUE_WORK_NAME,
            ExistingWorkPolicy.REPLACE,
            request
        )

        Timber.i("Enqueued DateRangeContentSyncWorker [from=$from, to=$to]")
    }

    // --- Constraints ---

    fun onWifiOnlyChanged(enabled: Boolean) {
        viewModelScope.launch {
            settingsDataStore.saveWifiOnly(enabled)
            wifiOnly.value = enabled
        }
    }

    fun onAllowBatterySaverChanged(enabled: Boolean) {
        viewModelScope.launch {
            settingsDataStore.saveAllowBatterySaver(enabled)
            allowBatterySaver.value = enabled
        }
    }

    // --- Permission ---

    private fun requestBackgroundPermissionIfNeeded() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) return
        val perm = _permissionState ?: return
        if (perm.status.isGranted) return

        if (perm.status.shouldShowRationale) {
            showDialog.value = SyncSettingsDialog.BackgroundRationaleDialog
        } else {
            showDialog.value = SyncSettingsDialog.PermissionRequest
        }
    }

    fun onRationaleDialogConfirm() {
        showDialog.value = SyncSettingsDialog.PermissionRequest
    }

    // --- Dialog ---

    fun onShowDialog(dialog: SyncSettingsDialog) {
        showDialog.value = dialog
    }

    fun onDismissDialog() {
        showDialog.value = null
    }

    // --- Navigation ---

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null }
    }

    fun onClickBack() {
        _navigationEvent.update { NavigationEvent.NavigateBack }
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
    }

    // --- Helpers ---

    private fun getBookmarkSyncOptions(selected: AutoSyncTimeframe): List<AutoSyncTimeframeOption> {
        // Exclude MANUAL since bookmark sync is always on
        return AutoSyncTimeframe.entries.filter { it != AutoSyncTimeframe.MANUAL }.map {
            AutoSyncTimeframeOption(
                autoSyncTimeframe = it,
                label = it.toLabelResource(),
                selected = it == selected
            )
        }
    }

    @OptIn(ExperimentalPermissionsApi::class)
    fun setPermissionState(permissionState: PermissionState) {
        _permissionState = permissionState
    }

    // Internal data classes for combine
    private data class SyncSettingsPartial1(
        val freq: AutoSyncTimeframe,
        val mode: ContentSyncMode,
        val dialog: SyncSettingsDialog?,
        val next: Long?,
        val wifi: Boolean
    )

    private data class SyncSettingsPartial2(
        val battery: Boolean,
        val from: LocalDate?,
        val to: LocalDate?,
        val downloading: Boolean,
        val status: BookmarkDao.DetailedSyncStatusCounts
    )
}

@Immutable
data class SyncSettingsUiState(
    // Bookmark sync
    val bookmarkSyncFrequency: AutoSyncTimeframe = AutoSyncTimeframe.HOURS_01,
    val bookmarkSyncFrequencyOptions: List<AutoSyncTimeframeOption> = emptyList(),
    val nextAutoSyncRun: String? = null,

    // Content sync
    val contentSyncMode: ContentSyncMode = ContentSyncMode.AUTOMATIC,
    val dateRangeFrom: LocalDate? = null,
    val dateRangeTo: LocalDate? = null,
    val isDateRangeDownloading: Boolean = false,

    // Constraints
    val wifiOnly: Boolean = false,
    val allowBatterySaver: Boolean = true,

    // Sync status
    val syncStatus: SyncStatus = SyncStatus(),

    // Dialog state
    val showDialog: SyncSettingsDialog? = null
)

@Immutable
data class SyncStatus(
    val totalBookmarks: Int = 0,
    val unread: Int = 0,
    val archived: Int = 0,
    val favorites: Int = 0,
    val contentDownloaded: Int = 0,
    val contentAvailable: Int = 0,
    val contentDirty: Int = 0,
    val permanentNoContent: Int = 0,
    val lastSyncTimestamp: String? = null
)

enum class SyncSettingsDialog {
    BookmarkSyncFrequencyDialog,
    BackgroundRationaleDialog,
    PermissionRequest,
    DateFromPicker,
    DateToPicker
}

data class AutoSyncTimeframeOption(
    val autoSyncTimeframe: AutoSyncTimeframe,
    @StringRes
    val label: Int,
    val selected: Boolean
)

@StringRes
fun AutoSyncTimeframe.toLabelResource(): Int {
    return when (this) {
        AutoSyncTimeframe.MANUAL -> R.string.auto_sync_timeframe_manual
        AutoSyncTimeframe.HOURS_01 -> R.string.auto_sync_timeframe_01_hours
        AutoSyncTimeframe.HOURS_06 -> R.string.auto_sync_timeframe_06_hours
        AutoSyncTimeframe.HOURS_12 -> R.string.auto_sync_timeframe_12_hours
        AutoSyncTimeframe.DAYS_01 -> R.string.auto_sync_timeframe_01_days
        AutoSyncTimeframe.DAYS_07 -> R.string.auto_sync_timeframe_07_days
        AutoSyncTimeframe.DAYS_14 -> R.string.auto_sync_timeframe_14_days
        AutoSyncTimeframe.DAYS_30 -> R.string.auto_sync_timeframe_30_days
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/util/LoggerUtil.kt">
package com.mydeck.app.util


import com.mydeck.app.BuildConfig
import com.mydeck.app.LOGDIR
import fr.bipi.treessence.file.FileLoggerTree
import timber.log.Timber
import java.io.File

fun getLatestLogFile(): File? {
    val tree = Timber.forest().firstOrNull { it is FileLoggerTree } as FileLoggerTree?
    return tree?.files?.sortedBy { it.name }?.firstOrNull()
}

fun createLogDir(parentDir: File): File? {
    val logdir = File(parentDir, LOGDIR)
    return if (logdir.isDirectory) {
        Timber.tag("LOGDIR").i("logdir $logdir already exists")
        logdir
    } else {
        logdir.mkdirs().let {
            if (it) {
                Timber.tag("LOGDIR").i("logdir $logdir created")
                logdir
            } else {
                Timber.tag("LOGDIR").w("logdir $logdir not created")
                null
            }
        }
    }
}

fun logAppInfo() {
    Timber.tag("APP-INFO")
    Timber.i("versionName=${BuildConfig.VERSION_NAME}")
    Timber.tag("APP-INFO")
    Timber.i("versionCode=${BuildConfig.VERSION_CODE}")
    Timber.tag("APP-INFO")
    Timber.i("flavor=${BuildConfig.FLAVOR}")
}

fun clearLogFiles(): Boolean {
    val tree = Timber.forest().firstOrNull { it is FileLoggerTree } as FileLoggerTree?
    return tree?.files?.all { file ->
        try {
            file.writeText("")
            true
        } catch (e: Exception) {
            Timber.tag("LOGDIR").e(e, "Failed to clear log file: ${file.name}")
            false
        }
    } ?: false
}
</file>

<file path="app/src/main/java/com/mydeck/app/util/Utils.kt">
package com.mydeck.app.util

import android.content.Context
import android.content.Intent
import java.net.URL
import androidx.core.net.toUri
import androidx.browser.customtabs.CustomTabsIntent
import com.mydeck.app.domain.model.SharedText

fun String?.isValidUrl(): Boolean {
    return try {
        URL(this).toURI()
        true
    } catch (e: Exception) {
        false
    }
}

/**
 * Detects the first valid URL in a given string and returns it along with the rest of the string as the title.
 * This function handles cases where the URL might be embedded within a larger string.
 *
 * @return A SharedText object containing the URL and title, or null if no valid URL is found.
 */
fun String?.extractUrlAndTitle(): SharedText? {
    if (this.isNullOrBlank()) {
        return null
    }

    val lines = this.lines()
    var foundUrl: String? = null
    val titleBuilder = StringBuilder()
    var urlFound = false

    for (line in lines) {
        val trimmedLine = line.trim()
        val urlInLine = findFirstUrlInLine(trimmedLine)

        if (urlInLine != null) {
            if (!urlFound) {
                foundUrl = urlInLine
                urlFound = true
                // The title is everything before and after the URL on this line, plus subsequent lines
                val urlIndex = trimmedLine.indexOf(urlInLine)
                if (urlIndex > 0) {
                    titleBuilder.append(trimmedLine.substring(0, urlIndex).trim())
                }
                if (titleBuilder.isNotEmpty()) {
                    titleBuilder.append("\n")
                }
                val afterUrl = trimmedLine.substring(urlIndex + urlInLine.length).trim()
                if (afterUrl.isNotEmpty()) {
                    titleBuilder.append(afterUrl)
                    titleBuilder.append("\n")
                }
            } else {
                // If URL already found, append this entire line to the title
                if (titleBuilder.isNotEmpty()) {
                    titleBuilder.append("\n")
                }
                titleBuilder.append(line) // Append original line to preserve formatting if needed
            }
        } else {
            // If URL has not been found yet, this line is part of the potential title
            if (!urlFound) {
                if (titleBuilder.isNotEmpty()) {
                    titleBuilder.append("\n")
                }
                titleBuilder.append(line) // Append original line to preserve formatting if needed
            }
        }
    }

    return if (foundUrl != null && foundUrl.isValidUrl()) {
        SharedText(url = foundUrl, title = titleBuilder.toString().trim().ifBlank { null })
    } else {
        null
    }
}

/**
 * Finds the first valid URL within a given string.
 *
 * @return The first valid URL found, or null if none is present.
 */
private fun findFirstUrlInLine(line: String): String? {
    return URL_REGEX.find(line)?.value
}

private val URL_REGEX = """(https?://[^\s]+)""".toRegex()

const val MAX_TITLE_LENGTH = 500

fun openUrlInCustomTab(context: Context, url: String) {
    if(url.isValidUrl()) {
        try {
            val builder = CustomTabsIntent.Builder()
            builder.setStartAnimations(context, android.R.anim.fade_in, android.R.anim.fade_out)
            builder.setExitAnimations(context, android.R.anim.fade_in, android.R.anim.fade_out)

            val customTabsIntent = builder.build()
            customTabsIntent.launchUrl(context, url.toUri())
        } catch (e: Exception) {
            // Fallback: Open in standard browser if Custom Tabs fails or is not available
            val intent = Intent(Intent.ACTION_VIEW, url.toUri())
            context.startActivity(intent)
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/worker/DateRangeContentSyncWorker.kt">
package com.mydeck.app.worker

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.mydeck.app.domain.sync.ContentSyncPolicyEvaluator
import com.mydeck.app.domain.usecase.LoadArticleUseCase
import com.mydeck.app.io.db.dao.BookmarkDao
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import timber.log.Timber

@HiltWorker
class DateRangeContentSyncWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val bookmarkDao: BookmarkDao,
    private val loadArticleUseCase: LoadArticleUseCase,
    private val policyEvaluator: ContentSyncPolicyEvaluator
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        val fromEpoch = inputData.getLong(PARAM_FROM_EPOCH, 0)
        val toEpoch = inputData.getLong(PARAM_TO_EPOCH, 0)

        Timber.d("DateRangeContentSyncWorker starting [from=$fromEpoch, to=$toEpoch]")

        val eligibleIds = bookmarkDao.getBookmarkIdsForDateRangeContentFetch(
            fromEpoch = fromEpoch, toEpoch = toEpoch
        )

        Timber.i("Found ${eligibleIds.size} bookmarks eligible for date range content fetch")

        for (id in eligibleIds) {
            if (!policyEvaluator.canFetchContent().allowed) {
                Timber.i("Constraints no longer met, stopping date range sync")
                return Result.success()
            }
            try {
                loadArticleUseCase.execute(id)
            } catch (e: Exception) {
                Timber.w(e, "Failed to load article $id in date range sync")
            }
        }

        return Result.success()
    }

    companion object {
        const val UNIQUE_WORK_NAME = "date_range_content_sync"
        const val PARAM_FROM_EPOCH = "from_epoch"
        const val PARAM_TO_EPOCH = "to_epoch"
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/MainActivity.kt">
package com.mydeck.app

import android.annotation.SuppressLint
import android.content.Intent
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.toRoute
import dagger.hilt.android.AndroidEntryPoint
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.ui.detail.BookmarkDetailScreen
import com.mydeck.app.ui.list.BookmarkListScreen
import com.mydeck.app.ui.navigation.AccountSettingsRoute
import com.mydeck.app.ui.navigation.BookmarkDetailRoute
import com.mydeck.app.ui.navigation.BookmarkListRoute
import com.mydeck.app.ui.navigation.LogViewRoute
import com.mydeck.app.ui.navigation.OpenSourceLibrariesRoute
import com.mydeck.app.ui.navigation.SettingsRoute
import com.mydeck.app.ui.navigation.SyncSettingsRoute
import com.mydeck.app.ui.navigation.UiSettingsRoute
import com.mydeck.app.ui.navigation.AboutRoute
import com.mydeck.app.ui.about.AboutScreen
import com.mydeck.app.ui.settings.AccountSettingsScreen
import com.mydeck.app.ui.settings.LogViewScreen
import com.mydeck.app.ui.settings.OpenSourceLibrariesScreen
import com.mydeck.app.ui.settings.SettingsScreen
import com.mydeck.app.ui.settings.SyncSettingsScreen
import com.mydeck.app.ui.settings.UiSettingsScreen
import com.mydeck.app.ui.theme.MyDeckTheme
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    @Inject
    lateinit var settingsDataStore: SettingsDataStore

    private lateinit var intentState: MutableState<Intent?>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            val viewModel = hiltViewModel<MainViewModel>()
            val theme = viewModel.theme.collectAsState()
            val navController = rememberNavController()
            intentState = remember { mutableStateOf(intent) }
            val scope = rememberCoroutineScope()
            val context = LocalContext.current
            val noValidUrlMessage = stringResource(id = R.string.not_valid_url)

            LaunchedEffect(intentState.value) {
                intentState.value?.let { newIntent ->
                    if (newIntent.action == Intent.ACTION_SEND && newIntent.type == "text/plain") {
                        val sharedText = newIntent.getStringExtra(Intent.EXTRA_TEXT)
                        if (sharedText.isNullOrBlank()) {
                            scope.launch {
                                Toast.makeText(context, noValidUrlMessage, Toast.LENGTH_LONG).show()
                            }
                        } else {
                            navController.navigate(BookmarkListRoute(sharedText = sharedText))
                        }
                    }
                    if (newIntent.hasExtra("navigateToAccountSettings")) {
                        Timber.d("Navigating to AccountSettingsScreen")
                        newIntent.removeExtra("navigateToAccountSettings") // Prevent re-navigation
                        navController.navigate(AccountSettingsRoute)
                    }
                    // Consume the intent after processing
                    intentState.value = null
                }
            }

            val themeValue = when (theme.value) {
                Theme.SYSTEM -> if (isSystemInDarkTheme()) Theme.DARK else Theme.LIGHT
                else -> theme.value
            }

            MyDeckTheme(theme = themeValue) {
                MyDeckNavHost(navController, settingsDataStore)
            }
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        intentState.value = intent
    }
}

@SuppressLint("WrongStartDestinationType")
@Composable
fun MyDeckNavHost(navController: NavHostController, settingsDataStore: SettingsDataStore? = null) {
    // Determine start destination based on auth state
    val token = settingsDataStore?.tokenFlow?.collectAsState()?.value
    val startDestination: Any = if (token.isNullOrBlank()) {
        AccountSettingsRoute
    } else {
        BookmarkListRoute()
    }

    NavHost(navController = navController, startDestination = startDestination) {
        composable<BookmarkListRoute> { BookmarkListScreen(navController) }
        composable<SettingsRoute> { SettingsScreen(navController) }
        composable<AccountSettingsRoute> { AccountSettingsScreen(navController) }
        composable<BookmarkDetailRoute> { backStackEntry ->
            val route = backStackEntry.toRoute<BookmarkDetailRoute>()
            BookmarkDetailScreen(
                navController,
                route.bookmarkId,
                showOriginal = route.showOriginal
            )
        }
        composable<OpenSourceLibrariesRoute> {
            OpenSourceLibrariesScreen(navHostController = navController)
        }
        composable<LogViewRoute> {
            LogViewScreen(navController = navController)
        }
        composable<SyncSettingsRoute> {
            SyncSettingsScreen(navHostController = navController)
        }
        composable<UiSettingsRoute> {
            UiSettingsScreen(navHostController = navController)
        }
        composable<AboutRoute> {
            AboutScreen(navHostController = navController)
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/MyDeckApplication.kt">
package com.mydeck.app

import android.app.Application

import dagger.hilt.android.HiltAndroidApp
import com.mydeck.app.util.createLogDir
import fr.bipi.treessence.context.GlobalContext.startTimber
import timber.log.Timber


@HiltAndroidApp
class MyDeckApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        initTimberLog()
        Thread.setDefaultUncaughtExceptionHandler(
            CustomExceptionHandler(this)
        )
    }

    private fun initTimberLog() {
        val logDir = createLogDir(filesDir)
        startTimber {
            if (BuildConfig.DEBUG) {
                debugTree()
                logDir?.let {
                    fileTree {
                        level = 3 // Log.DEBUG
                        fileName = LOGFILE
                        dir = it.absolutePath
                        fileLimit = 2
                        appendToFile = true
                    }
                }
            } else {
                logDir?.let {
                    fileTree {
                        level = 4 // Log.INFO
                        fileName = LOGFILE
                        dir = it.absolutePath
                        fileLimit = 2
                        appendToFile = true
                    }
                }
            }
        }
    }
}

class CustomExceptionHandler(private val application: Application) :
    Thread.UncaughtExceptionHandler {
    private val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()

    override fun uncaughtException(thread: Thread, throwable: Throwable) {
        try {
            Timber.e(throwable, "CRASH: Uncaught exception")
        } catch (e: Exception) {
            // Handle any exceptions that occur during logging (e.g., file write errors)
            e.printStackTrace()
        } finally {
            // If there was a default handler, call it to let the system handle the crash
            defaultHandler?.uncaughtException(thread, throwable) ?: android.os.Process.killProcess(android.os.Process.myPid())
        }
    }
}

const val LOGFILE = "MyDeckAppLog"
const val LOGDIR = "logs"
</file>

<file path="app/src/test/java/com/mydeck/app/domain/usecase/LoadBookmarksUseCaseTest.kt">
package com.mydeck.app.domain.usecase

import androidx.work.WorkManager
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.mapper.toDomain
import com.mydeck.app.domain.sync.ContentSyncPolicyEvaluator
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.io.rest.ReadeckApi
import com.mydeck.app.io.rest.model.BookmarkDto
import com.mydeck.app.io.rest.model.ImageResource
import com.mydeck.app.io.rest.model.Resource
import com.mydeck.app.io.rest.model.Resources
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.runBlocking
import kotlinx.datetime.Clock
import okhttp3.Headers
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import retrofit2.Response
import kotlin.time.Duration.Companion.days

class LoadBookmarksUseCaseTest {

    private lateinit var bookmarkRepository: BookmarkRepository
    private lateinit var readeckApi: ReadeckApi
    private lateinit var settingsDataStore: SettingsDataStore
    private lateinit var policyEvaluator: ContentSyncPolicyEvaluator
    private lateinit var workManager: WorkManager
    private lateinit var loadBookmarksUseCase: LoadBookmarksUseCase

    @Before
    fun setUp() {
        bookmarkRepository = mockk(relaxed = true)
        readeckApi = mockk()
        settingsDataStore = mockk(relaxed = true)
        policyEvaluator = mockk(relaxed = true)
        workManager = mockk(relaxed = true)
        coEvery { policyEvaluator.shouldAutoFetchContent() } returns false
        loadBookmarksUseCase = LoadBookmarksUseCase(
            bookmarkRepository,
            readeckApi,
            settingsDataStore,
            policyEvaluator,
            workManager
        )
    }

    @Test
    fun `execute successful load`() = runBlocking {
        // Mock API response
        val bookmarkDtoList = listOf(bookmark2)
        val response: Response<List<BookmarkDto>> = Response.success(
            bookmarkDtoList,
            Headers.headersOf(
                ReadeckApi.Header.TOTAL_COUNT,
                "1",
                ReadeckApi.Header.TOTAL_PAGES,
                "1",
                ReadeckApi.Header.CURRENT_PAGE,
                "1"
            )
        )
        coEvery { readeckApi.getBookmarks(any(), any(), any(), any()) } returns response

        // Mock SettingsDataStore
        coEvery { settingsDataStore.getLastBookmarkTimestamp() } returns null

        // Execute the use case
        val result = loadBookmarksUseCase.execute(10, 0)

        println("result=$result")
        // Verify the result
        assertTrue(result is LoadBookmarksUseCase.UseCaseResult.Success<*>)
        // Add more specific assertions based on your logic
    }

    @Test
    fun `execute api error`() = runBlocking {
        // Mock API response to return an error
        val response: Response<List<BookmarkDto>> = Response.error(500, mockk(relaxed = true))
        coEvery { readeckApi.getBookmarks(any(), any(), any(), any()) } returns response

        // Execute the use case
        val result = loadBookmarksUseCase.execute(10, 0)

        // Verify the result
        assertTrue(result is LoadBookmarksUseCase.UseCaseResult.Error)
        // Add more specific assertions based on your logic
    }

    @Test
    fun `execute exception thrown`() = runBlocking {
        // Mock API to throw an exception
        coEvery {
            readeckApi.getBookmarks(
                any(),
                any(),
                any(),
                any(),
            )
        } throws RuntimeException("Test Exception")

        // Execute the use case
        val result = loadBookmarksUseCase.execute(10, 0)

        // Verify the result
        assertTrue(result is LoadBookmarksUseCase.UseCaseResult.Error)
        // Add more specific assertions based on your logic
    }

    @Test
    fun `execute saves last bookmark timestamp`() = runBlocking {
        // Mock API response
        val response: Response<List<BookmarkDto>> = Response.success(
            sampleBookmarks,
            Headers.headersOf(
                ReadeckApi.Header.TOTAL_COUNT,
                "1",
                ReadeckApi.Header.TOTAL_PAGES,
                "1",
                ReadeckApi.Header.CURRENT_PAGE,
                "1"
            )
        )
        coEvery { readeckApi.getBookmarks(any(), any(), any(), any()) } returns response

        // Mock SettingsDataStore
        coEvery { settingsDataStore.getLastBookmarkTimestamp() } returns null

        // Execute the use case
        loadBookmarksUseCase.execute(10, 0)

        // Verify that the timestamp is saved
        coVerify { settingsDataStore.saveLastBookmarkTimestamp(bookmark2.created) }
        coVerify { bookmarkRepository.insertBookmarks(sampleBookmarks.map { it.toDomain() }) }
    }

    val bookmark2 = BookmarkDto(
        id = "2",
        href = "https://example.com",
        created = Clock.System.now(),
        updated = Clock.System.now(),
        state = 1,
        loaded = true,
        url = "https://example.com/article",
        title = "Sample Article",
        siteName = "Example Site",
        site = "example.com",
        authors = listOf("John Doe", "Jane Smith"),
        lang = "en",
        textDirection = "ltr",
        documentTpe = "article",
        type = "article",
        hasArticle = true,
        description = "This is a sample article description.",
        isDeleted = false,
        isMarked = false,
        isArchived = false,
        labels = listOf("sample", "article"),
        readProgress = 0,
        resources = Resources(
            article = Resource(src = "https://example.com/article.pdf"),
            icon = ImageResource(src = "https://example.com/icon.png", width = 32, height = 32),
            image = ImageResource(src = "https://example.com/image.jpg", width = 600, height = 400),
            log = Resource(src = "https://example.com/log.txt"),
            props = Resource(src = "https://example.com/props.json"),
            thumbnail = ImageResource(
                src = "https://example.com/thumbnail.jpg",
                width = 200,
                height = 150
            )
        ),
        wordCount = 1000,
        readingTime = 5
    )
    val bookmark1 = BookmarkDto(
        id = "1",
        href = "https://example.com",
        created = Clock.System.now().minus(1.days),
        updated = Clock.System.now().minus(1.days),
        state = 1,
        loaded = true,
        url = "https://example.com/article",
        title = "Sample Article",
        siteName = "Example Site",
        site = "example.com",
        authors = listOf("John Doe", "Jane Smith"),
        lang = "en",
        textDirection = "ltr",
        documentTpe = "article",
        type = "article",
        hasArticle = true,
        description = "This is a sample article description.",
        isDeleted = false,
        isMarked = false,
        isArchived = false,
        labels = listOf("sample", "article"),
        readProgress = 0,
        resources = Resources(
            article = Resource(src = "https://example.com/article.pdf"),
            icon = ImageResource(src = "https://example.com/icon.png", width = 32, height = 32),
            image = ImageResource(src = "https://example.com/image.jpg", width = 600, height = 400),
            log = Resource(src = "https://example.com/log.txt"),
            props = Resource(src = "https://example.com/props.json"),
            thumbnail = ImageResource(
                src = "https://example.com/thumbnail.jpg",
                width = 200,
                height = 150
            )
        ),
        wordCount = 1000,
        readingTime = 5
    )
    val sampleBookmarks = listOf(bookmark2, bookmark1)
}
</file>

<file path="app/src/test/java/com/mydeck/app/io/db/BookmarkDaoTest.kt">
package com.mydeck.app.io.db

import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import com.mydeck.app.io.db.dao.BookmarkDao
import com.mydeck.app.io.db.model.ArticleContentEntity
import com.mydeck.app.io.db.model.BookmarkEntity
import com.mydeck.app.io.db.model.BookmarkWithArticleContent
import com.mydeck.app.io.db.model.ImageResourceEntity
import com.mydeck.app.io.db.model.RemoteBookmarkIdEntity
import com.mydeck.app.io.db.model.ResourceEntity
import com.mydeck.app.test.logging.replaceDebugTree
import com.mydeck.app.test.logging.restoreDebugTree
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.runTest
import kotlinx.datetime.Instant
import kotlinx.datetime.LocalDate
import kotlinx.datetime.TimeZone
import kotlinx.datetime.atStartOfDayIn
import kotlinx.datetime.plus
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.experimental.runners.Enclosed
import org.junit.runner.RunWith
import org.robolectric.ParameterizedRobolectricTestRunner
import org.robolectric.RobolectricTestRunner
import timber.log.Timber

@RunWith(Enclosed::class)
class BookmarkDaoTest {
    internal abstract class BaseTest {
        lateinit var bookmarkDao: BookmarkDao
        private lateinit var db: MyDeckDatabase
        val testDispatcher = StandardTestDispatcher()

        @Before
        fun setup() {
            replaceDebugTree()
            val context: Context = ApplicationProvider.getApplicationContext()
            db = Room.inMemoryDatabaseBuilder(context, MyDeckDatabase::class.java)
                .allowMainThreadQueries().build()
            bookmarkDao = db.getBookmarkDao()
            generateTestData()
        }

        @After
         fun tearDown() {
            db.close()
            restoreDebugTree()
        }

        private fun generateTestData() = runTest {
            val startDate = LocalDate(2025, 1, 1)
            val bookmarkEntities = (0 until 30).map { index ->
                val currentDate = startDate.plus(index.toLong(), kotlinx.datetime.DateTimeUnit.DAY)
                val type = when (index) {
                    in 0..9 -> BookmarkEntity.Type.ARTICLE
                    in 10..19 -> BookmarkEntity.Type.VIDEO
                    in 20..29 -> BookmarkEntity.Type.PHOTO
                    else -> {
                        BookmarkEntity.Type.ARTICLE
                    }
                }
                val state = when (index) {
                    9, 19, 29 -> BookmarkEntity.State.ERROR
                    8, 18, 28 -> BookmarkEntity.State.LOADING
                    else -> BookmarkEntity.State.LOADED
                }
                BookmarkEntity(
                    id = "test-$index",
                    href = "http://example.com/$index",
                    created = currentDate.atStartOfDayIn(TimeZone.UTC),
                    updated = currentDate.atStartOfDayIn(TimeZone.UTC),
                    state = state,
                    loaded = true,
                    url = "http://example.com/$index",
                    title = "Test Bookmark $index",
                    siteName = "Example",
                    site = "example.com",
                    authors = listOf("Author $index"),
                    lang = "en",
                    textDirection = "ltr",
                    documentTpe = type.value.lowercase(),
                    type = type,
                    hasArticle = true,
                    description = "Description for bookmark $index",
                    isDeleted = false,
                    isMarked = false,
                    isArchived = false,
                    labels = listOf("label1", "label2"),
                    readProgress = index * 3,
                    wordCount = 100 + index * 10,
                    readingTime = 5 + index,
                    published = null,
                    embed = null,
                    embedHostname = null,
                    article = ResourceEntity(""),
                    icon = ImageResourceEntity("", 50, 50),
                    image = ImageResourceEntity("", 200, 100),
                    log = ResourceEntity(""),
                    props = ResourceEntity(""),
                    thumbnail = ImageResourceEntity("", 100, 100),
                )
            }
            val bookmarkArticles = bookmarkEntities.map {
                BookmarkWithArticleContent(
                    bookmark = it,
                    articleContent = if (it.type == BookmarkEntity.Type.ARTICLE) {
                        ArticleContentEntity(bookmarkId = it.id, content = "content")
                    } else {
                        null
                    }
                )
            }
            bookmarkDao.insertBookmarksWithArticleContent(bookmarkArticles)
            val ids = bookmarkArticles.map { RemoteBookmarkIdEntity(it.bookmark.id) }
                .filterNot { it.id == "test-1" || it.id == "test-11" || it.id == "test-21" }
           bookmarkDao.insertRemoteBookmarkIds(ids + RemoteBookmarkIdEntity("not-a-bookmark"))
        }
    }

    @RunWith(ParameterizedRobolectricTestRunner::class)
    internal class GetBookmarkListItemsByFiltersTest(private val parameter: ParameterType) :
        BaseTest() {

        companion object {
            @JvmStatic
            @ParameterizedRobolectricTestRunner.Parameters(name = "{0}")
            fun data(): List<ParameterType> = listOf(
                ParameterType(BookmarkEntity.Type.ARTICLE),
                ParameterType(BookmarkEntity.Type.PHOTO),
                ParameterType(BookmarkEntity.Type.VIDEO),
            )
        }

        data class ParameterType(val type: BookmarkEntity.Type)

        @Test
        fun testFilterArticles() = runTest(testDispatcher) {
            val flow = bookmarkDao.getBookmarkListItemsByFilters(parameter.type)
            val list = flow.first()
            assertEquals(10, list.size)
            list.forEach {
                assertEquals(parameter.type, it.type)
            }
        }

    }

    @RunWith(ParameterizedRobolectricTestRunner::class)
    internal class GetBookmarksByFiltersTest(private val parameter: ParameterType) : BaseTest() {

        companion object {
            @JvmStatic
            @ParameterizedRobolectricTestRunner.Parameters(name = "{0}")
            fun data(): List<ParameterType> = listOf(
                ParameterType(BookmarkEntity.Type.ARTICLE),
                ParameterType(BookmarkEntity.Type.PHOTO),
                ParameterType(BookmarkEntity.Type.VIDEO),
            )
        }

        data class ParameterType(val type: BookmarkEntity.Type)

        @Test
        fun testFilterArticles() = runTest(testDispatcher) {
            val flow = bookmarkDao.getBookmarksByFilters(parameter.type)
            val list = flow.first()
            assertEquals(10, list.size)
            list.forEach {
                assertEquals(parameter.type, it.type)
            }
        }

    }

    @RunWith(RobolectricTestRunner::class)
    internal class GetLastUpdatedBookmarkTest : BaseTest() {
        @Test
        fun testGetLastUpdatedBookmark() = runTest(testDispatcher) {
            val lastUpdated = bookmarkDao.getLastUpdatedBookmark()
            assertNotNull(lastUpdated)
            assertEquals("test-29", lastUpdated?.id)
        }

    }

    @RunWith(RobolectricTestRunner::class)
    internal class GetAllBookmarksIsSortedByCreationDateTest : BaseTest() {
        @Test
        fun testGetAllBookmarksIsSortedByCreationDate() = runTest(testDispatcher) {
            val flow = bookmarkDao.getAllBookmarks()
            val list = flow.first()
            assertEquals(30, list.size)
            var prevDate: Instant? = null
            list.forEach { bookmark ->
                prevDate?.let {
                    assertTrue("wrong sort order", it >= bookmark.created)
                }
                prevDate = bookmark.created
            }
        }

    }

    @RunWith(RobolectricTestRunner::class)
    internal class GetFilterByStateTest : BaseTest() {
        @Test
        fun testGetLoaded() = runTest(testDispatcher) {
            val flow = bookmarkDao.getBookmarksByFilters(state = BookmarkEntity.State.LOADED)
            val list = flow.first()
            assertEquals(24, list.size)
            list.forEach { bookmark ->
                assertEquals(BookmarkEntity.State.LOADED, bookmark.state)
            }
        }

        @Test
        fun testGetLoading() = runTest(testDispatcher) {
            val flow = bookmarkDao.getBookmarksByFilters(state = BookmarkEntity.State.LOADING)
            val list = flow.first()
            assertEquals(3, list.size)
            list.forEach { bookmark ->
                assertEquals(BookmarkEntity.State.LOADING, bookmark.state)
            }
        }

        @Test
        fun testGetError() = runTest(testDispatcher) {
            val flow = bookmarkDao.getBookmarksByFilters(state = BookmarkEntity.State.ERROR)
            val list = flow.first()
            assertEquals(3, list.size)
            list.forEach { bookmark ->
                assertEquals(BookmarkEntity.State.ERROR, bookmark.state)
            }
        }
    }

    @RunWith(RobolectricTestRunner::class)
    internal class GetArticleTest : BaseTest() {
        @Test
        fun testGetLoaded() = runTest(testDispatcher) {
            val list = bookmarkDao.getAllBookmarksWithContent()
            Timber.d("list=$list")
        }
    }

    @RunWith(RobolectricTestRunner::class)
    internal class RemoteBookmarkIdTest : BaseTest() {
        @Test
        fun testGetRemoteBookmarkIds() = runTest(testDispatcher) {
            val list = bookmarkDao.getAllRemoteBookmarkIds()
            assertEquals(28, list.size)
            list.forEach {
                val bookmark = bookmarkDao.getBookmarkById(it)
                if (bookmark != null) {
                    assertEquals(it, bookmark.id)
                    Timber.d("id=$it")
                    Timber.d("bookmark=$bookmark")
                } else {
                    assertEquals(it, "not-a-bookmark")
                    Timber.d("not-a-bookmark")
                }
            }
        }

        @Test
        fun testRemoveBookmarks() = runTest(testDispatcher) {
            val removedIds = listOf<String>("test-1", "test-11", "test-21")
            removedIds.forEach {
                assertNotNull(bookmarkDao.getBookmarkById(it))
                Timber.d("id=$it is not null")
            }
            val count = bookmarkDao.removeDeletedBookmars()
            assertEquals(3, count)
            removedIds.forEach {
                assertNull(bookmarkDao.getBookmarkById(it))
                Timber.d("id=$it is null")
            }
        }
    }

    @RunWith(RobolectricTestRunner::class)
    internal class GetCountsTest : BaseTest() {
        @Test
        fun testObserveAllBookmarkCounts() = runTest(testDispatcher) {
            val counts = bookmarkDao.observeAllBookmarkCounts().first()
            assertEquals(24, counts?.unread)
            assertEquals(0, counts?.archived)
            assertEquals(0, counts?.favorite)
            assertEquals(8, counts?.article)
            assertEquals(8, counts?.video)
            assertEquals(8, counts?.picture)
            assertEquals(24, counts?.total)
        }
    }
}
</file>

<file path="app/src/test/java/com/mydeck/app/ui/list/BookmarkListViewModelTest.kt">
package com.mydeck.app.ui.list

import android.content.Context
import androidx.lifecycle.SavedStateHandle
import androidx.work.WorkInfo
import androidx.work.WorkManager
import com.mydeck.app.R
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.BookmarkCounts
import com.mydeck.app.domain.model.BookmarkListItem
import com.mydeck.app.domain.usecase.FullSyncUseCase
import com.mydeck.app.domain.usecase.UpdateBookmarkUseCase
import com.mydeck.app.io.prefs.SettingsDataStore
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.take
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runCurrent
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

@OptIn(ExperimentalCoroutinesApi::class)
class BookmarkListViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    private lateinit var bookmarkRepository: BookmarkRepository
    private lateinit var settingsDataStore: SettingsDataStore
    private lateinit var context: Context
    private lateinit var viewModel: BookmarkListViewModel
    private lateinit var savedStateHandle: SavedStateHandle
    private lateinit var updateBookmarkUseCase: UpdateBookmarkUseCase
    private lateinit var fullSyncUseCase: FullSyncUseCase
    private lateinit var workManager : WorkManager

    private lateinit var workInfoFlow: Flow<List<WorkInfo>>

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        bookmarkRepository = mockk()
        settingsDataStore = mockk()
        context = mockk()
        savedStateHandle = mockk()
        updateBookmarkUseCase = mockk()
        fullSyncUseCase = mockk()
        workManager = mockk()

        workInfoFlow = flowOf(emptyList())

        // Default Mocking Behavior
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns true // Assume sync is done
        coEvery { settingsDataStore.isSyncOnAppOpenEnabled() } returns false // Disable sync on app open by default
        every { fullSyncUseCase.performFullSync() } returns Unit
        every { bookmarkRepository.observeBookmarkListItems(any(), any(), any(), any(), any()) } returns flowOf(
            emptyList()
        ) // No bookmarks initially
        // Mock the default filter state (archived = false) for My List view
        every { bookmarkRepository.observeBookmarkListItems(null, null, false, null, any()) } returns flowOf(
            emptyList()
        )
        every { savedStateHandle.get<String>(any()) } returns null // no sharedUrl initially
        every { workManager.getWorkInfosForUniqueWorkFlow(any()) } returns workInfoFlow
        every { bookmarkRepository.observeAllBookmarkCounts() } returns flowOf(BookmarkCounts())
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `initial uiState is Empty`() {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle,
        )
        assertEquals(BookmarkListViewModel.UiState.Empty(R.string.list_view_empty_not_loaded_yet), viewModel.uiState.value)
    }

    @Test
    fun `loadBookmarks enqueues LoadBookmarksWorker`() = runTest {
        // TODO: Find a way to properly test WorkManager enqueuing
        //  This requires more setup with Robolectric and testing WorkManager
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        // Just verify that it doesn't throw an exception for now
        viewModel.onPullToRefresh()
    }

    @Test
    fun `onClickMyList sets archived filter to false`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.onClickMyList()
        assertEquals(
            BookmarkListViewModel.FilterState(archived = false),
            viewModel.filterState.first()
        )
    }

    @Test
    fun `onClickArchive sets archived filter`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.onClickArchive()
        assertEquals(
            BookmarkListViewModel.FilterState(archived = true),
            viewModel.filterState.first()
        )
    }

    @Test
    fun `onClickFavorite sets favorite filter`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.onClickFavorite()
        assertEquals(
            BookmarkListViewModel.FilterState(favorite = true),
            viewModel.filterState.first()
        )
    }

    @Test
    fun `onClickSettings sets NavigateToSettings navigation event`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.onClickSettings()
        assertEquals(
            BookmarkListViewModel.NavigationEvent.NavigateToSettings,
            viewModel.navigationEvent.first()
        )
    }

    @Test
    fun `onClickBookmark sets NavigateToBookmarkDetail navigation event`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        val bookmarkId = "someBookmarkId"
        viewModel.onClickBookmark(bookmarkId)
        assertEquals(
            BookmarkListViewModel.NavigationEvent.NavigateToBookmarkDetail(bookmarkId),
            viewModel.navigationEvent.first()
        )
    }

    @Test
    fun `onNavigationEventConsumed resets navigation event`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.onClickSettings() // Set a navigation event
        viewModel.onNavigationEventConsumed()
        assertEquals(null, viewModel.navigationEvent.first())
    }

    @Test
    fun `observeBookmarks collects bookmarks with correct filters`() = runTest {
        // Arrange
        val expectedBookmarks = listOf(
            BookmarkListItem(
                id = "1",
                url = "https://example.com",
                title = "Test Bookmark",
                siteName = "Example Site",
                type = Bookmark.Type.Article,
                isMarked = false,
                isArchived = false,
                labels = emptyList(),
                isRead = false,
                readProgress = 0,
                thumbnailSrc = "",
                iconSrc = "",
                imageSrc = "",
                readingTime = null,
                created = kotlinx.datetime.Clock.System.now().toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault()),
                wordCount = null,
                published = null
            )
        )
        val bookmarkFlow = MutableStateFlow(expectedBookmarks)
        coEvery {
            bookmarkRepository.observeBookmarkListItems(
                type = null,
                unread = null,
                archived = false,
                favorite = null,
                state = Bookmark.State.LOADED
            )
        } returns bookmarkFlow

        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )

        viewModel.onClickMyList()

        val uiStates = viewModel.uiState.take(2).toList()
        val empty = uiStates[0]
        val success = uiStates[1]
        // Assert initial state
        assert(empty is BookmarkListViewModel.UiState.Empty)
        // Assert success state
        assertEquals(
            BookmarkListViewModel.UiState.Success(expectedBookmarks, null),
            success
        )
    }

    @Test
    fun `openCreateBookmarkDialog sets CreateBookmarkUiState to Open`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.openCreateBookmarkDialog()
        assertTrue(viewModel.createBookmarkUiState.first() is BookmarkListViewModel.CreateBookmarkUiState.Open)
    }

    @Test
    fun `closeCreateBookmarkDialog sets CreateBookmarkUiState to Closed`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.openCreateBookmarkDialog()
        viewModel.closeCreateBookmarkDialog()
        assertTrue(viewModel.createBookmarkUiState.first() is BookmarkListViewModel.CreateBookmarkUiState.Closed)
    }

    @Test
    fun `updateCreateBookmarkTitle updates title and enables create button if URL is valid`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )
            viewModel.openCreateBookmarkDialog()

            val validUrl = "https://example.com"
            viewModel.updateCreateBookmarkUrl(validUrl)
            viewModel.updateCreateBookmarkTitle("Test Title")

            val state =
                viewModel.createBookmarkUiState.first() as BookmarkListViewModel.CreateBookmarkUiState.Open
            assertEquals("Test Title", state.title)
            assertEquals(validUrl, state.url)
            assertTrue(state.isCreateEnabled)
        }

    @Test
    fun `updateCreateBookmarkUrl updates url and enables create button if title is present`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )
            viewModel.openCreateBookmarkDialog()

            viewModel.updateCreateBookmarkTitle("Test Title")
            val validUrl = "https://example.com"
            viewModel.updateCreateBookmarkUrl(validUrl)

            val state =
                viewModel.createBookmarkUiState.first() as BookmarkListViewModel.CreateBookmarkUiState.Open
            assertEquals("Test Title", state.title)
            assertEquals(validUrl, state.url)
            assertTrue(state.isCreateEnabled)
        }

    @Test
    fun `updateCreateBookmarkUrl updates urlError if URL is invalid`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.openCreateBookmarkDialog()

        val invalidUrl = "invalid-url"
        viewModel.updateCreateBookmarkUrl(invalidUrl)

        val state =
            viewModel.createBookmarkUiState.first() as BookmarkListViewModel.CreateBookmarkUiState.Open
        assertEquals(R.string.account_settings_url_error, state.urlError)
        assertFalse(state.isCreateEnabled)
    }

    @Test
    fun `createBookmark calls repository and sets state to Success`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.openCreateBookmarkDialog()

        val title = "Test Title"
        val url = "https://example.com"
        coEvery { bookmarkRepository.createBookmark(title, url) } returns "bookmark123"

        viewModel.updateCreateBookmarkTitle(title)
        viewModel.updateCreateBookmarkUrl(url)
        viewModel.createBookmark()
        runCurrent()

        coVerify { bookmarkRepository.createBookmark(title, url) }
        println("state=${viewModel.createBookmarkUiState.value}")
        assertTrue(viewModel.createBookmarkUiState.value is BookmarkListViewModel.CreateBookmarkUiState.Success)
    }

    @Test
    fun `createBookmark sets state to Error if repository call fails`() = runTest {
        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )
        viewModel.openCreateBookmarkDialog()

        val title = "Test Title"
        val url = "https://example.com"
        val errorMessage = "Failed to create bookmark"
        coEvery { bookmarkRepository.createBookmark(title, url) } throws Exception(errorMessage)

        viewModel.updateCreateBookmarkTitle(title)
        viewModel.updateCreateBookmarkUrl(url)
        viewModel.createBookmark()

        val uiStates = viewModel.createBookmarkUiState.take(2).toList()
        assertTrue(uiStates[1] is BookmarkListViewModel.CreateBookmarkUiState.Error)
        assertEquals(
            errorMessage,
            (uiStates[1] as BookmarkListViewModel.CreateBookmarkUiState.Error).message
        )
    }

    @Test
    fun `init sets CreateBookmarkUiState to Open with sharedText if present and valid`() = runTest {
        val sharedUrl = "https://example.com"
        every { savedStateHandle.get<String>("sharedText") } returns sharedUrl

        coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
        viewModel = BookmarkListViewModel(
            updateBookmarkUseCase,
            fullSyncUseCase,
            workManager,
            bookmarkRepository,
            context,
            settingsDataStore,
            savedStateHandle
        )

        val state =
            viewModel.createBookmarkUiState.first() as BookmarkListViewModel.CreateBookmarkUiState.Open
        assertEquals(sharedUrl, state.url)
        assertEquals(null, state.urlError)
        assertTrue(state.isCreateEnabled)
    }

    @Test
    fun `init sets CreateBookmarkUiState to Open with sharedText and urlError if present and invalid`() =
        runTest {
            val sharedText = "invalid-url"
            every { savedStateHandle.get<String>("sharedText") } returns sharedText

            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val state =
                viewModel.createBookmarkUiState.first() as BookmarkListViewModel.CreateBookmarkUiState.Open
            assertEquals("", state.url)
            assertEquals(R.string.account_settings_url_error, state.urlError)
            assertFalse(state.isCreateEnabled)
        }

    @Test
    fun `onToggleFavoriteBookmark updates UiState with UpdateBookmarkState Success`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isFavorite = true

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            coEvery {
                updateBookmarkUseCase.updateIsFavorite(
                    bookmarkId,
                    isFavorite
                )
            } returns UpdateBookmarkUseCase.Result.Success

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleFavoriteBookmark(bookmarkId, isFavorite)
            advanceUntilIdle()

            val updateState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Success
                ),
                updateState
            )

            coVerify { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) }
        }

    @Test
    fun `onToggleFavoriteBookmark updates UiState with UpdateBookmarkState Error on GenericError`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isFavorite = true
            val errorMessage = "Generic Error"

            coEvery {
                updateBookmarkUseCase.updateIsFavorite(
                    bookmarkId,
                    isFavorite
                )
            } returns UpdateBookmarkUseCase.Result.GenericError(errorMessage)

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
            bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleFavoriteBookmark(bookmarkId, isFavorite)
            advanceUntilIdle()

            val errorState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Error(errorMessage)
                ),
                errorState
            )

            coVerify { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) }
        }

    @Test
    fun `onToggleFavoriteBookmark updates UiState with UpdateBookmarkState Error on NetworkError`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isFavorite = true
            val errorMessage = "Network Error"

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            coEvery {
                updateBookmarkUseCase.updateIsFavorite(
                    bookmarkId,
                    isFavorite
                )
            } returns UpdateBookmarkUseCase.Result.NetworkError(errorMessage)

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleFavoriteBookmark(bookmarkId, isFavorite)
            advanceUntilIdle()

            val errorState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Error(errorMessage)
                ),
                errorState
            )

            coVerify { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) }
        }

    @Test
    fun `onToggleArchiveBookmark updates UiState with UpdateBookmarkState Success`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isArchived = true

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            coEvery {
                updateBookmarkUseCase.updateIsArchived(
                    bookmarkId,
                    isArchived
                )
            } returns UpdateBookmarkUseCase.Result.Success

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleArchiveBookmark(bookmarkId, isArchived)
            advanceUntilIdle()

            val updateState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Success
                ),
                updateState
            )

            coVerify { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) }
        }

    @Test
    fun `onToggleArchivedBookmark updates UiState with UpdateBookmarkState Error on GenericError`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isArchived = true
            val errorMessage = "Generic Error"

            coEvery {
                updateBookmarkUseCase.updateIsArchived(
                    bookmarkId,
                    isArchived
                )
            } returns UpdateBookmarkUseCase.Result.GenericError(errorMessage)

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleArchiveBookmark(bookmarkId, isArchived)
            advanceUntilIdle()

            val errorState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Error(errorMessage)
                ),
                errorState
            )

            coVerify { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) }
        }

    @Test
    fun `onToggleArchivedBookmark updates UiState with UpdateBookmarkState Error on NetworkError`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isArchived = true
            val errorMessage = "Network Error"

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            coEvery {
                updateBookmarkUseCase.updateIsArchived(
                    bookmarkId,
                    isArchived
                )
            } returns UpdateBookmarkUseCase.Result.NetworkError(errorMessage)

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleArchiveBookmark(bookmarkId, isArchived)
            advanceUntilIdle()

            val errorState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Error(errorMessage)
                ),
                errorState
            )

            coVerify { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) }
        }


    @Test
    fun `onToggleMarkReadBookmark updates UiState with UpdateBookmarkState Success`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isRead = true

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            coEvery {
                updateBookmarkUseCase.updateIsRead(
                    bookmarkId,
                    isRead
                )
            } returns UpdateBookmarkUseCase.Result.Success

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleMarkReadBookmark(bookmarkId, isRead)
            advanceUntilIdle()

            val updateState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Success
                ),
                updateState
            )

            coVerify { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) }
        }

    @Test
    fun `onToggleMarkReadBookmark updates UiState with UpdateBookmarkState Error on GenericError`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isRead = true
            val errorMessage = "Generic Error"

            coEvery {
                updateBookmarkUseCase.updateIsRead(
                    bookmarkId,
                    isRead
                )
            } returns UpdateBookmarkUseCase.Result.GenericError(errorMessage)

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleMarkReadBookmark(bookmarkId, isRead)
            advanceUntilIdle()

            val errorState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Error(errorMessage)
                ),
                errorState
            )

            coVerify { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) }
        }

    @Test
    fun `onToggleMarkReadBookmark updates UiState with UpdateBookmarkState Error on NetworkError`() =
        runTest {
            coEvery { settingsDataStore.isInitialSyncPerformed() } returns false
            val bookmarkId = "123"
            val isRead = true
            val errorMessage = "Network Error"

            val bookmarkFlow = MutableStateFlow(bookmarks)
            coEvery {
                bookmarkRepository.observeBookmarkListItems(
                    type = null,
                    unread = null,
                    archived = false,
                    favorite = null,
                    state = Bookmark.State.LOADED
                )
            } returns bookmarkFlow

            coEvery {
                updateBookmarkUseCase.updateIsRead(
                    bookmarkId,
                    isRead
                )
            } returns UpdateBookmarkUseCase.Result.NetworkError(errorMessage)

            viewModel = BookmarkListViewModel(
                updateBookmarkUseCase,
                fullSyncUseCase,
                workManager,
                bookmarkRepository,
                context,
                settingsDataStore,
                savedStateHandle
            )

            val uiStates = viewModel.uiState.take(2).toList()
            val emptyState = uiStates[0]
            val successState = uiStates[1]
            // Assert initial state
            assert(emptyState is BookmarkListViewModel.UiState.Empty)
            // Assert success state
            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    null
                ),
                successState
            )

            viewModel.onToggleMarkReadBookmark(bookmarkId, isRead)
            advanceUntilIdle()

            val errorState = viewModel.uiState.value

            assertEquals(
                BookmarkListViewModel.UiState.Success(
                    bookmarks,
                    BookmarkListViewModel.UpdateBookmarkState.Error(errorMessage)
                ),
                errorState
            )

            coVerify { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) }
        }
    private val bookmarks = listOf(
        BookmarkListItem(
            id = "1",
            url = "https://example.com",
            title = "Test Bookmark",
            siteName = "Example Site",
            type = Bookmark.Type.Article,
            isMarked = false,
            isArchived = false,
            labels = emptyList(),
            isRead = false,
            readProgress = 0,
            thumbnailSrc = "",
            iconSrc = "",
            imageSrc = ""
        )
    )
}
</file>

<file path="gradle/libs.versions.toml">
[versions]
agp = "8.13.2"
desugarJdkLibs = "2.1.5"
kotlin = "2.0.0"
coreKtx = "1.15.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.5.0"
lifecycleRuntimeKtx = "2.8.7"
activityCompose = "1.10.1"
composeBom = "2025.04.01"
retrofit = "2.11.0"
daggerHilt = "2.55"
androidHilt = "1.2.0"
kotlinxSerializationJson = "1.8.0"
kotlinxDateTime = "0.6.1"
mockk = "1.13.16"
coroutinesTest = "1.10.1"
room = "2.7.1"
robolectric = "4.14"
ksp = "2.0.0-1.0.24"
timber = "5.0.1"
appcompat = "1.7.0"
constraintlayout = "2.2.1"
material = "1.12.0"
lifecycleLivedataKtx = "2.8.7"
lifecycleViewmodelKtx = "2.8.7"
navigationFragmentKtx = "2.8.9"
navigationUiKtx = "2.8.9"
coil = "3.1.0"
okhttp3 = "4.12.0"
datastore = "1.1.3"
androidxCrypto = "1.1.0-alpha06"
tink = "1.8.0"
workManager = "2.10.0"
paging = "3.3.6"
uiTestJunit4Android = "1.7.8"
aboutLibraries = "12.0.0-a04"
treessence = "1.1.2"
accompanist = "0.37.3"
browser = "1.8.0"

[libraries]
timber = { group = "com.jakewharton.timber", name = "timber", version.ref = "timber" }
kotlinx-coroutines-test = { group = "org.jetbrains.kotlinx", name = "kotlinx-coroutines-test", version.ref = "coroutinesTest" }
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-hilt-navigation = { group = "androidx.hilt", name = "hilt-navigation-compose", version.ref = "androidHilt" }
androidx-hilt-common = { group = "androidx.hilt", name = "hilt-common", version.ref = "androidHilt" }
androidx-hilt-work = { group = "androidx.hilt", name = "hilt-work", version.ref = "androidHilt" }
androidx-hilt-compiler = { group = "androidx.hilt", name = "hilt-compiler", version.ref = "androidHilt" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-ui-test-junit4-android = { group = "androidx.compose.ui", name = "ui-test-junit4-android", version.ref = "uiTestJunit4Android" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-material-icons = { group = "androidx.compose.material", name = "material-icons-extended" }
retrofit = { group = "com.squareup.retrofit2", name = "retrofit", version.ref = "retrofit" }
retrofit-converter-kotlinx-serialization = { group = "com.squareup.retrofit2", name = "converter-kotlinx-serialization", version.ref = "retrofit" }
retrofit-converter-scalars = { group = "com.squareup.retrofit2", name = "converter-scalars", version.ref = "retrofit" }

dagger-hilt-android = { group = "com.google.dagger", name = "hilt-android", version.ref = "daggerHilt" }
dagger-hilt-android-compiler = { group = "com.google.dagger", name = "hilt-android-compiler", version.ref = "daggerHilt" }
dagger-hilt-compiler = { group = "com.google.dagger", name = "hilt-compiler", version.ref = "daggerHilt" }
dagger-hilt-android-testing = { group = "com.google.dagger", name = "hilt-android-testing", version.ref = "daggerHilt" }
kotlin-serialization-json = { group = "org.jetbrains.kotlinx", name = "kotlinx-serialization-json", version.ref = "kotlinxSerializationJson" }
kotlinx-datetime = { group = "org.jetbrains.kotlinx", name = "kotlinx-datetime", version.ref = "kotlinxDateTime" }
mockk = { group ="io.mockk", name= "mockk", version.ref = "mockk" }
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "room" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "room" }
androidx-room-ktx = { group = "androidx.room", name = "room-ktx", version.ref = "room" }
androidx-room-testing = { group = "androidx.room", name = "room-testing", version.ref = "room" }
robolectric = { group = "org.robolectric", name = "robolectric", version.ref = "robolectric" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
androidx-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }
androidx-lifecycle-livedata-ktx = { group = "androidx.lifecycle", name = "lifecycle-livedata-ktx", version.ref = "lifecycleLivedataKtx" }
androidx-lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleViewmodelKtx" }
androidx-navigation-fragment-ktx = { group = "androidx.navigation", name = "navigation-fragment-ktx", version.ref = "navigationFragmentKtx" }
androidx-navigation-ui-ktx = { group = "androidx.navigation", name = "navigation-ui-ktx", version.ref = "navigationUiKtx" }
androidx-navigation-compose = { group = "androidx.navigation", name = "navigation-compose", version.ref = "navigationUiKtx" }
coil-compose = { group = "io.coil-kt.coil3", name = "coil-compose", version.ref = "coil" }
coil-network-okhttp = { group = "io.coil-kt.coil3", name = "coil-network-okhttp", version.ref = "coil" }
coil-svg = { group = "io.coil-kt.coil3", name = "coil-svg", version.ref = "coil" }
okhttp3-logging-interceptor = { group = "com.squareup.okhttp3", name = "logging-interceptor", version.ref = "okhttp3" }
okhttp3-mockserver = { group = "com.squareup.okhttp3", name = "mockwebserver", version.ref = "okhttp3" }
androidx-datastore-preferences = { group = "androidx.datastore", name = "datastore-preferences", version.ref = "datastore" }
androidx-datastore-preferences-core = { group = "androidx.datastore", name = "datastore-preferences-core", version.ref = "datastore" }
androidx-security-crypto = { group = "androidx.security", name = "security-crypto", version.ref = "androidxCrypto" }
google-crypto-tink = { group = "com.google.crypto.tink", name = "tink-android", version.ref = "tink" }
androidx-work-runtime-ktx = { group = "androidx.work", name = "work-runtime-ktx", version.ref = "workManager" }
androidx-paging-runtime-ktx = { group = "androidx.paging", name = "paging-runtime-ktx", version.ref = "paging" }
aboutlibraries-core = { module = "com.mikepenz:aboutlibraries-core", version.ref = "aboutLibraries" }
aboutlibraries-compose-m3 = { module = "com.mikepenz:aboutlibraries-compose-m3", version.ref = "aboutLibraries" }
treessence = { module = "com.github.bastienpaulfr:Treessence", version.ref = "treessence" }
accompanist-permissions = { group = "com.google.accompanist", name = "accompanist-permissions", version.ref = "accompanist" }
androidx-browser = { group = "androidx.browser", name = "browser", version.ref = "browser" }
desugar-jdk-libs = { group ="com.android.tools" ,name = "desugar_jdk_libs", version.ref = "desugarJdkLibs" }
[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }

kotlin-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin"}
dagger-hilt = { id = "com.google.dagger.hilt.android", version.ref = "daggerHilt" }
androidx-room = { id = "androidx.room", version.ref = "room" }
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }
aboutLibraries = { id = "com.mikepenz.aboutlibraries.plugin", version.ref = "aboutLibraries" }
</file>

<file path="build.gradle.kts">
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.kotlin.compose) apply false
    alias(libs.plugins.dagger.hilt) apply false

    alias(libs.plugins.kotlin.serialization) apply false
    alias(libs.plugins.androidx.room) apply false
    alias(libs.plugins.ksp) apply false
}
</file>

<file path="gradle.properties">
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
# Allow Gradle to automatically fetch the right JDK if missing.
org.gradle.java.installations.auto-download=true
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/LayoutMode.kt">
package com.mydeck.app.domain.model

enum class LayoutMode(val displayName: String) {
    GRID("Grid"),
    COMPACT("Compact"),
    MOSAIC("Mosaic")
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/BookmarkListItemEntity.kt">
package com.mydeck.app.io.db.model

import kotlinx.datetime.Instant

data class BookmarkListItemEntity(
    val id: String,
    val url: String,
    val title: String,
    val siteName: String,
    val isMarked: Boolean,
    val isArchived: Boolean,
    val readProgress: Int,
    val thumbnailSrc: String,
    val imageSrc: String,
    val iconSrc: String,
    val labels: List<String>,
    val type: BookmarkEntity.Type,
    val readingTime: Int?,
    val created: Instant,
    val wordCount: Int?,
    val published: Instant?
)
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/DatabaseModule.kt">
package com.mydeck.app.io.db

import android.content.Context
import androidx.room.Room
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import com.mydeck.app.io.db.dao.BookmarkDao
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): MyDeckDatabase {
        return Room.databaseBuilder(context, MyDeckDatabase::class.java, "readeck.db")
            .addMigrations(
                MyDeckDatabase.MIGRATION_1_2,
                MyDeckDatabase.MIGRATION_2_3,
                MyDeckDatabase.MIGRATION_3_4,
                MyDeckDatabase.MIGRATION_4_5
            )
            .build()
    }

    @Provides
    @Singleton
    fun provideBookmarkDao(readeckDatabase: MyDeckDatabase): BookmarkDao =
        readeckDatabase.getBookmarkDao()
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/MyDeckDatabase.kt">
package com.mydeck.app.io.db

import androidx.room.Database
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.mydeck.app.io.db.dao.BookmarkDao
import com.mydeck.app.io.db.model.ArticleContentEntity
import com.mydeck.app.io.db.model.BookmarkEntity
import com.mydeck.app.io.db.model.RemoteBookmarkIdEntity

@Database(
    entities = [BookmarkEntity::class, ArticleContentEntity::class, RemoteBookmarkIdEntity::class],
    version = 5,
    exportSchema = true
)
@TypeConverters(Converters::class)
abstract class MyDeckDatabase : RoomDatabase() {
    abstract fun getBookmarkDao(): BookmarkDao

    companion object {
        val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(database: SupportSQLiteDatabase) {
                // Create the article_content table
                database.execSQL(
                    """
                        CREATE TABLE IF NOT EXISTS `article_content` (
                            `bookmarkId` TEXT NOT NULL,
                            `content` TEXT NOT NULL,
                            PRIMARY KEY(`bookmarkId`),
                            FOREIGN KEY(`bookmarkId`) REFERENCES `bookmarks`(`id`) ON DELETE CASCADE
                        )
                    """
                )

                // Copy data from bookmarks.articleContent to article_content.content
                database.execSQL(
                    """
                        INSERT INTO article_content (bookmarkId, content)
                        SELECT id, articleContent FROM bookmarks WHERE articleContent IS NOT NULL
                    """
                )

                // Remove the articleContent column from the bookmarks table
                database.execSQL(
                    """
                        ALTER TABLE bookmarks DROP COLUMN articleContent
                    """
                )
            }
        }

        val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL(
                    """
                    CREATE TABLE IF NOT EXISTS `remote_bookmark_ids` ( `id` TEXT NOT NULL, PRIMARY KEY(`id`))
                """
                )
            }
        }

        val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("ALTER TABLE bookmarks ADD COLUMN embed TEXT")
                database.execSQL("ALTER TABLE bookmarks ADD COLUMN embedHostname TEXT")
            }
        }

        val MIGRATION_4_5 = object : Migration(4, 5) {
            override fun migrate(database: SupportSQLiteDatabase) {
                // Add content state tracking columns
                database.execSQL("ALTER TABLE bookmarks ADD COLUMN contentState INTEGER NOT NULL DEFAULT 0")
                database.execSQL("ALTER TABLE bookmarks ADD COLUMN contentFailureReason TEXT")

                // Backfill: mark bookmarks that already have downloaded content
                database.execSQL("""
                    UPDATE bookmarks SET contentState = 1
                    WHERE EXISTS (SELECT 1 FROM article_content WHERE article_content.bookmarkId = bookmarks.id)
                """)

                // Backfill: mark non-article types as permanent no content
                database.execSQL("""
                    UPDATE bookmarks SET contentState = 3, contentFailureReason = 'Non-article type'
                    WHERE type IN ('photo', 'video') AND contentState = 0
                """)

                // Backfill: mark articles with no server-side article as permanent no content
                database.execSQL("""
                    UPDATE bookmarks SET contentState = 3, contentFailureReason = 'No article available on server'
                    WHERE hasArticle = 0 AND type = 'article' AND contentState = 0
                """)
            }
        }
    }

}
</file>

<file path="app/src/main/java/com/mydeck/app/io/prefs/SettingsDataStore.kt">
package com.mydeck.app.io.prefs

import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.domain.sync.ContentSyncConstraints
import com.mydeck.app.domain.sync.ContentSyncMode
import com.mydeck.app.domain.sync.DateRangeParams
import kotlinx.coroutines.flow.StateFlow
import kotlinx.datetime.Instant

interface SettingsDataStore {
    val tokenFlow: StateFlow<String?>
    val usernameFlow: StateFlow<String?>
    val passwordFlow: StateFlow<String?>
    val urlFlow: StateFlow<String?>
    val themeFlow: StateFlow<String?>
    val zoomFactorFlow: StateFlow<Int>
    fun saveUsername(username: String)
    fun savePassword(password: String)
    fun saveToken(token: String)
    fun saveUrl(url: String)
    suspend fun saveLastBookmarkTimestamp(timestamp: Instant)
    suspend fun getLastBookmarkTimestamp(): Instant?
    suspend fun saveLastSyncTimestamp(timestamp: Instant)
    suspend fun getLastSyncTimestamp(): Instant?
    suspend fun saveLastFullSyncTimestamp(timestamp: Instant)
    suspend fun getLastFullSyncTimestamp(): Instant?
    suspend fun setInitialSyncPerformed(performed: Boolean)
    suspend fun isInitialSyncPerformed(): Boolean
    suspend fun clearCredentials()
    suspend fun saveCredentials(url: String, username: String, password: String, token: String)
    suspend fun setAutoSyncEnabled(isEnabled: Boolean)
    suspend fun isAutoSyncEnabled(): Boolean
    suspend fun saveAutoSyncTimeframe(autoSyncTimeframe: AutoSyncTimeframe)
    suspend fun getAutoSyncTimeframe(): AutoSyncTimeframe
    suspend fun saveTheme(theme: Theme)
    suspend fun getTheme(): Theme
    suspend fun  getZoomFactor(): Int
    suspend fun  saveZoomFactor(zoomFactor: Int)
    suspend fun setSyncOnAppOpenEnabled(isEnabled: Boolean)
    suspend fun isSyncOnAppOpenEnabled(): Boolean
    suspend fun setSyncNotificationsEnabled(isEnabled: Boolean)
    suspend fun isSyncNotificationsEnabled(): Boolean
    suspend fun saveLayoutMode(layoutMode: String)
    suspend fun getLayoutMode(): String?
    suspend fun saveSortOption(sortOption: String)
    suspend fun getSortOption(): String?

    // Content sync policy
    suspend fun getContentSyncMode(): ContentSyncMode
    suspend fun saveContentSyncMode(mode: ContentSyncMode)
    suspend fun getContentSyncConstraints(): ContentSyncConstraints
    suspend fun saveWifiOnly(enabled: Boolean)
    suspend fun saveAllowBatterySaver(enabled: Boolean)
    suspend fun getDateRangeParams(): DateRangeParams?
    suspend fun saveDateRangeParams(params: DateRangeParams)
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/prefs/SettingsDataStoreImpl.kt">
package com.mydeck.app.io.prefs

import android.content.Context
import android.content.SharedPreferences
import androidx.core.content.edit
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.intPreferencesKey
import androidx.datastore.preferences.core.stringPreferencesKey
import dagger.hilt.android.qualifiers.ApplicationContext
import com.mydeck.app.domain.model.AutoSyncTimeframe
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.domain.sync.ContentSyncConstraints
import com.mydeck.app.domain.sync.ContentSyncMode
import com.mydeck.app.domain.sync.DateRangeParams
import kotlinx.datetime.LocalDate
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.datetime.Instant
import timber.log.Timber
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SettingsDataStoreImpl @Inject constructor(@ApplicationContext private val context: Context) :
    SettingsDataStore {

    private val encryptedSharedPreferences = EncryptionHelper.getEncryptedSharedPreferences(context)

    private val KEY_USERNAME = stringPreferencesKey("username")
    private val KEY_TOKEN = stringPreferencesKey("token")
    private val KEY_URL = stringPreferencesKey("url")
    private val KEY_PASSWORD = stringPreferencesKey("password")
    private val KEY_LAST_BOOKMARK_TIMESTAMP = stringPreferencesKey("lastBookmarkTimestamp")
    private val KEY_LAST_SYNC_TIMESTAMP = stringPreferencesKey("lastSyncTimestamp")
    private val KEY_LAST_FULL_SYNC_TIMESTAMP = stringPreferencesKey("last_full_sync_timestamp")
    private val KEY_INITIAL_SYNC_PERFORMED = "initial_sync_performed"
    private val KEY_AUTOSYNC_ENABLED = booleanPreferencesKey("autosync_enabled")
    private val KEY_AUTOSYNC_TIMEFRAME = stringPreferencesKey("autosync_timeframe")
    private val KEY_THEME = stringPreferencesKey("theme")
    private val KEY_ZOOM_FACTOR = intPreferencesKey("zoom_factor")
    private val KEY_SYNC_ON_APP_OPEN = booleanPreferencesKey("sync_on_app_open")
    private val KEY_SYNC_NOTIFICATIONS_ENABLED = booleanPreferencesKey("sync_notifications_enabled")
    private val KEY_LAYOUT_MODE = stringPreferencesKey("layout_mode")
    private val KEY_SORT_OPTION = stringPreferencesKey("sort_option")
    private val KEY_CONTENT_SYNC_MODE = stringPreferencesKey("content_sync_mode")
    private val KEY_WIFI_ONLY = booleanPreferencesKey("content_sync_wifi_only")
    private val KEY_ALLOW_BATTERY_SAVER = booleanPreferencesKey("content_sync_allow_battery_saver")
    private val KEY_DATE_RANGE_FROM = stringPreferencesKey("date_range_from")
    private val KEY_DATE_RANGE_TO = stringPreferencesKey("date_range_to")

    override fun saveUsername(username: String) {
        Timber.d("saveUsername")
        encryptedSharedPreferences.edit {
            putString(KEY_USERNAME.name, username)
        }
    }

    override fun savePassword(password: String) {
        Timber.d("savePassword")
        encryptedSharedPreferences.edit {
            putString(KEY_PASSWORD.name, password)
        }
    }

    override fun saveToken(token: String) {
        Timber.d("saveToken")
        encryptedSharedPreferences.edit {
            putString(KEY_TOKEN.name, token)
        }
    }

    override fun saveUrl(url: String) {
        Timber.d("saveUrl")
        encryptedSharedPreferences.edit {
            putString(KEY_URL.name, url)
        }
    }

    override suspend fun saveLastBookmarkTimestamp(timestamp: Instant) {
        encryptedSharedPreferences.edit {
            putString(KEY_LAST_BOOKMARK_TIMESTAMP.name, timestamp.toString())
        }
    }

    override suspend fun getLastBookmarkTimestamp(): Instant? {
        return encryptedSharedPreferences.getString(KEY_LAST_BOOKMARK_TIMESTAMP.name, null)?.let {
            Instant.parse(it)
        }
    }

    override suspend fun saveLastSyncTimestamp(timestamp: Instant) {
        encryptedSharedPreferences.edit {
            putString(KEY_LAST_SYNC_TIMESTAMP.name, timestamp.toString())
        }
    }

    override suspend fun getLastSyncTimestamp(): Instant? {
        return encryptedSharedPreferences.getString(KEY_LAST_SYNC_TIMESTAMP.name, null)?.let {
            Instant.parse(it)
        }
    }

    override suspend fun saveLastFullSyncTimestamp(timestamp: Instant) {
        encryptedSharedPreferences.edit {
            putString(KEY_LAST_FULL_SYNC_TIMESTAMP.name, timestamp.toString())
        }
    }

    override suspend fun getLastFullSyncTimestamp(): Instant? {
        return encryptedSharedPreferences.getString(KEY_LAST_FULL_SYNC_TIMESTAMP.name, null)?.let {
            Instant.parse(it)
        }
    }

    override suspend fun setInitialSyncPerformed(performed: Boolean) {
        encryptedSharedPreferences.edit {
            putBoolean(KEY_INITIAL_SYNC_PERFORMED, performed)
        }
    }

    override suspend fun isInitialSyncPerformed(): Boolean {
        return encryptedSharedPreferences.getBoolean(KEY_INITIAL_SYNC_PERFORMED, false)
    }

    override suspend fun isAutoSyncEnabled(): Boolean {
        return encryptedSharedPreferences.getBoolean(KEY_AUTOSYNC_ENABLED.name, false)
    }

    override suspend fun setAutoSyncEnabled(isEnabled: Boolean) {
        encryptedSharedPreferences.edit {
            putBoolean(KEY_AUTOSYNC_ENABLED.name, isEnabled)
        }
    }

    override suspend fun getAutoSyncTimeframe(): AutoSyncTimeframe {
        return encryptedSharedPreferences.getString(KEY_AUTOSYNC_TIMEFRAME.name, AutoSyncTimeframe.MANUAL.name)?.let {
            AutoSyncTimeframe.valueOf(it)
        } ?: AutoSyncTimeframe.MANUAL
    }

    override suspend fun saveAutoSyncTimeframe(autoSyncTimeframe: AutoSyncTimeframe) {
        Timber.d("saveAutoSyncTimeframe")
        encryptedSharedPreferences.edit {
            putString(KEY_AUTOSYNC_TIMEFRAME.name, autoSyncTimeframe.name)
        }
    }

    override suspend fun getTheme(): Theme {
        return encryptedSharedPreferences.getString(KEY_THEME.name, Theme.SYSTEM.name)?.let {
            Theme.valueOf(it)
        } ?: Theme.SYSTEM
    }

    override suspend fun saveTheme(theme: Theme) {
        encryptedSharedPreferences.edit {
            putString(KEY_THEME.name, theme.name)
        }
    }

    override suspend fun getZoomFactor(): Int {
        return encryptedSharedPreferences.getInt(KEY_ZOOM_FACTOR.name, 100)
    }

    override suspend fun saveZoomFactor(zoomFactor: Int) {
        encryptedSharedPreferences.edit {
            putInt(KEY_ZOOM_FACTOR.name, zoomFactor.coerceIn(25, 400))
        }
    }

    override suspend fun setSyncOnAppOpenEnabled(isEnabled: Boolean) {
        encryptedSharedPreferences.edit {
            putBoolean(KEY_SYNC_ON_APP_OPEN.name, isEnabled)
        }
    }

    override suspend fun isSyncOnAppOpenEnabled(): Boolean {
        return encryptedSharedPreferences.getBoolean(KEY_SYNC_ON_APP_OPEN.name, true)
    }

    override suspend fun setSyncNotificationsEnabled(isEnabled: Boolean) {
        encryptedSharedPreferences.edit {
            putBoolean(KEY_SYNC_NOTIFICATIONS_ENABLED.name, isEnabled)
        }
    }

    override suspend fun isSyncNotificationsEnabled(): Boolean {
        return encryptedSharedPreferences.getBoolean(KEY_SYNC_NOTIFICATIONS_ENABLED.name, true)
    }

    override val tokenFlow = getStringFlow(KEY_TOKEN.name, null)
    override val usernameFlow = getStringFlow(KEY_USERNAME.name, null)
    override val urlFlow = getStringFlow(KEY_URL.name, null)
    override val passwordFlow = getStringFlow(KEY_PASSWORD.name, null)
    override val themeFlow = getStringFlow(KEY_THEME.name, Theme.SYSTEM.name)
    override val zoomFactorFlow = getIntFlow(KEY_ZOOM_FACTOR.name, 100)
    override suspend fun clearCredentials() {
        Timber.d("clearCredentials")
        encryptedSharedPreferences.edit(commit = true) {
            remove(KEY_USERNAME.name)
            remove(KEY_PASSWORD.name)
            remove(KEY_TOKEN.name)
            remove(KEY_URL.name)
        }
    }

    override suspend fun saveCredentials(
        url: String,
        username: String,
        password: String,
        token: String
    ) {
        Timber.d("saveCredentials")
        encryptedSharedPreferences.edit {
            putString(KEY_URL.name, url)
            putString(KEY_USERNAME.name, username)
            putString(KEY_PASSWORD.name, password)
            putString(KEY_TOKEN.name, token)
        }
    }

    private fun getStringFlow(key: String, defaultValue: String? = null): StateFlow<String?> =
        preferenceFlow(key) { encryptedSharedPreferences.getString(key, defaultValue) }

    private fun getIntFlow(key: String, defaultValue: Int = 100): StateFlow<Int> =
        preferenceFlow(key) { encryptedSharedPreferences.getInt(key, defaultValue) }

    private fun <T> preferenceFlow(key: String, getValue: () -> T): StateFlow<T> { // Create our flow using callbackflow
        // Emit initial value when we start collecting from this flow (if it exists) or use default one from params in function call above!  This is important so consumers know initial state!  Can skip this and just send updates if you do not need initial state emission on subscribe time!  That could be fine too depending on your use case - remember that!  Also you can send null as the "initial" value as well if you want!
        val state = MutableStateFlow(getValue())

        val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, changedKey ->
            if (changedKey == key) {  // Only send updates for this specific key
                Timber.d("pref changed key=$key")
                val value = getValue()
                state.value = value
            }
        }

        encryptedSharedPreferences.registerOnSharedPreferenceChangeListener(listener) // Register the listener
        return state.asStateFlow()
    }

    override suspend fun saveLayoutMode(layoutMode: String) {
        encryptedSharedPreferences.edit {
            putString(KEY_LAYOUT_MODE.name, layoutMode)
        }
    }

    override suspend fun getLayoutMode(): String? {
        return encryptedSharedPreferences.getString(KEY_LAYOUT_MODE.name, null)
    }

    override suspend fun saveSortOption(sortOption: String) {
        encryptedSharedPreferences.edit {
            putString(KEY_SORT_OPTION.name, sortOption)
        }
    }

    override suspend fun getSortOption(): String? {
        return encryptedSharedPreferences.getString(KEY_SORT_OPTION.name, null)
    }

    override suspend fun getContentSyncMode(): ContentSyncMode {
        return encryptedSharedPreferences.getString(KEY_CONTENT_SYNC_MODE.name, ContentSyncMode.AUTOMATIC.name)?.let {
            try { ContentSyncMode.valueOf(it) } catch (_: Exception) { ContentSyncMode.AUTOMATIC }
        } ?: ContentSyncMode.AUTOMATIC
    }

    override suspend fun saveContentSyncMode(mode: ContentSyncMode) {
        encryptedSharedPreferences.edit {
            putString(KEY_CONTENT_SYNC_MODE.name, mode.name)
        }
    }

    override suspend fun getContentSyncConstraints(): ContentSyncConstraints {
        return ContentSyncConstraints(
            wifiOnly = encryptedSharedPreferences.getBoolean(KEY_WIFI_ONLY.name, false),
            allowOnBatterySaver = encryptedSharedPreferences.getBoolean(KEY_ALLOW_BATTERY_SAVER.name, true)
        )
    }

    override suspend fun saveWifiOnly(enabled: Boolean) {
        encryptedSharedPreferences.edit {
            putBoolean(KEY_WIFI_ONLY.name, enabled)
        }
    }

    override suspend fun saveAllowBatterySaver(enabled: Boolean) {
        encryptedSharedPreferences.edit {
            putBoolean(KEY_ALLOW_BATTERY_SAVER.name, enabled)
        }
    }

    override suspend fun getDateRangeParams(): DateRangeParams? {
        val from = encryptedSharedPreferences.getString(KEY_DATE_RANGE_FROM.name, null)
        val to = encryptedSharedPreferences.getString(KEY_DATE_RANGE_TO.name, null)
        return if (from != null && to != null) {
            try {
                DateRangeParams(from = LocalDate.parse(from), to = LocalDate.parse(to))
            } catch (_: Exception) { null }
        } else null
    }

    override suspend fun saveDateRangeParams(params: DateRangeParams) {
        encryptedSharedPreferences.edit {
            putString(KEY_DATE_RANGE_FROM.name, params.from.toString())
            putString(KEY_DATE_RANGE_TO.name, params.to.toString())
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/rest/model/BookmarkDto.kt">
package com.mydeck.app.io.rest.model

import kotlinx.datetime.Instant
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class BookmarkDto(
    val id: String,
    val href: String,
    val created: Instant,
    val updated: Instant,
    val state: Int,
    val loaded: Boolean,
    val url: String,
    val title: String,
    @SerialName("site_name")
    val siteName: String,
    val site: String,
    val authors: List<String>?,
    val lang: String,
    @SerialName("text_direction")
    val textDirection: String,
    @SerialName("document_type")
    val documentTpe: String,
    val type: String,
    @SerialName("has_article")
    val hasArticle: Boolean,
    val description: String,
    @SerialName("is_deleted")
    val isDeleted: Boolean,
    @SerialName("is_marked")
    val isMarked: Boolean,
    @SerialName("is_archived")
    val isArchived: Boolean,
    val labels: List<String>,
    @SerialName("read_progress")
    val readProgress: Int? = null,
    val resources: Resources,
    @SerialName("word_count")
    val wordCount: Int? = null,
    @SerialName("reading_time")
    val readingTime: Int? = null,
    val published: Instant? = null,
    val embed: String? = null,
    @SerialName("embed_hostname")
    val embedHostname: String? = null
)

@Serializable
data class Resources(
    val article: Resource? = null,
    val icon: ImageResource? = null,
    val image: ImageResource? = null,
    val log: Resource? = null,
    val props: Resource? = null,
    val thumbnail: ImageResource? = null
)

@Serializable
data class Resource(
    val src: String
)

@Serializable
data class ImageResource(
    val src: String,
    val width: Int,
    val height: Int
)
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/AccountSettingsViewModel.kt">
package com.mydeck.app.ui.settings

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import com.mydeck.app.R
import com.mydeck.app.domain.usecase.AuthenticateUseCase
import com.mydeck.app.domain.usecase.AuthenticationResult
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.util.isValidUrl
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@HiltViewModel
class AccountSettingsViewModel @Inject constructor(
    private val settingsDataStore: SettingsDataStore,
    private val authenticateUseCase: AuthenticateUseCase
) : ViewModel() {
    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()
    private val _uiState =
        MutableStateFlow(AccountSettingsUiState("", "", "", false, null, null, null, null, false, false))
    val uiState = _uiState.asStateFlow()

    init {
        viewModelScope.launch {
            val url = settingsDataStore.urlFlow.value
            val username = settingsDataStore.usernameFlow.value
            val password = settingsDataStore.passwordFlow.value
            val token = settingsDataStore.tokenFlow.value
            val isLoggedIn = !token.isNullOrBlank()

            // Auto-populate URL with protocol if empty
            val populatedUrl = if (url.isNullOrBlank()) "https://" else url

            _uiState.value = AccountSettingsUiState(
                url = populatedUrl,
                username = username,
                password = password,
                loginEnabled = isValidUrlForCurrentSettings(populatedUrl) && !username.isNullOrBlank() && !password.isNullOrBlank(),
                urlError = null,
                usernameError = null,
                passwordError = null,
                authenticationResult = null,
                allowUnencryptedConnection = false,
                isLoggedIn = isLoggedIn
            )
        }
    }

    fun login() {
        viewModelScope.launch {
            _uiState.value.url!!.also { url ->
                if (!url.endsWith("/api")) {
                    _uiState.update { it.copy(url = "$url/api") }
                }
            }
            val result = authenticateUseCase.execute(
                _uiState.value.url!!,
                _uiState.value.username!!,
                _uiState.value.password!!
            )
            _uiState.update {
                it.copy(authenticationResult = result, isLoggedIn = result is AuthenticationResult.Success)
            }
            Timber.d("result=$result")
            // Navigate to BookmarkList on successful authentication
            if (result is AuthenticationResult.Success) {
                _navigationEvent.update { NavigationEvent.NavigateToBookmarkList }
            }
        }
    }

    fun onAllowUnencryptedConnectionChanged(allow: Boolean) {
        _uiState.update {
            it.copy(allowUnencryptedConnection = allow)
        }
        uiState.value.url?.apply {
            // Swap protocol prefix when toggling unencrypted connections
            val updatedUrl = when {
                allow && this.startsWith("https://") -> "http://${this.substringAfter("https://")}" // Swap https to http
                !allow && this.startsWith("http://") -> "https://${this.substringAfter("http://")}" // Swap http to https
                else -> this
            }
            validateUrl(updatedUrl)
        }
    }

    fun onUrlChanged(value: String) {
        validateUrl(value)
    }

    private fun validateUrl(value: String) {
        val isUrlValid = isValidUrlForCurrentSettings(value)
        val urlError = if (!isUrlValid && value.isNotEmpty()) {
            R.string.account_settings_url_error // Use resource ID
        } else {
            null
        }
        _uiState.update {
            it.copy(
                url = value,
                urlError = urlError,
                loginEnabled = isUrlValid && !it.username.isNullOrBlank() && !it.password.isNullOrBlank(),
                authenticationResult = null // Clear any previous result
            )
        }
    }

    fun onUsernameChanged(value: String) {
        val usernameError = if (value.isBlank()) {
            R.string.account_settings_username_error // Use resource ID
        } else {
            null
        }
        _uiState.update {
            it.copy(
                username = value,
                usernameError = usernameError,
                loginEnabled = isValidUrlForCurrentSettings(uiState.value.url) && !value.isBlank() && !it.password.isNullOrBlank(),
                authenticationResult = null // Clear any previous result
            )
        }
    }

    fun onPasswordChanged(value: String) {
        val passwordError = if (value.isBlank()) {
            R.string.account_settings_password_error // Use resource ID
        } else {
            null
        }
        _uiState.update {
            it.copy(
                password = value,
                passwordError = passwordError,
                loginEnabled = isValidUrlForCurrentSettings(uiState.value.url) && !it.username.isNullOrBlank() && !value.isBlank(),
                authenticationResult = null // Clear any previous result
            )
        }
    }

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null } // Reset the event
    }

    fun onClickBack() {
        _navigationEvent.update { NavigationEvent.NavigateBack }
    }

    fun signOut() {
        viewModelScope.launch {
            try {
                settingsDataStore.clearCredentials()
                // Reset the UI state
                _uiState.value = AccountSettingsUiState(
                    url = "https://",
                    username = "",
                    password = "",
                    loginEnabled = false,
                    urlError = null,
                    usernameError = null,
                    passwordError = null,
                    authenticationResult = null,
                    allowUnencryptedConnection = false,
                    isLoggedIn = false
                )
                Timber.d("Signed out successfully")
            } catch (e: Exception) {
                Timber.e(e, "Error signing out")
            }
        }
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
        data object NavigateToBookmarkList : NavigationEvent()
    }

    private fun isValidUrlForCurrentSettings(url: String?): Boolean {
        val allowUnencrypted = _uiState.value.allowUnencryptedConnection
        return if (allowUnencrypted) {
            url.isValidUrl() // Any URL is valid if unencrypted is allowed
        } else {
            url?.startsWith("https://") == true && url.isValidUrl() // Must be HTTPS if unencrypted is not allowed
        }
    }

}

data class AccountSettingsUiState(
    val url: String?,
    val username: String?,
    val password: String?,
    val loginEnabled: Boolean,
    val urlError: Int?,
    val usernameError: Int?,
    val passwordError: Int?,
    val authenticationResult: AuthenticationResult?,
    val allowUnencryptedConnection: Boolean = false,
    val isLoggedIn: Boolean = false
)
</file>

<file path="app/src/test/java/com/mydeck/app/domain/BookmarkRepositoryImplTest.kt">
package com.mydeck.app.domain

import androidx.work.WorkManager
import androidx.work.WorkRequest
import com.mydeck.app.io.db.dao.BookmarkDao
import com.mydeck.app.io.rest.ReadeckApi
import com.mydeck.app.io.rest.model.BookmarkDto
import com.mydeck.app.io.rest.model.CreateBookmarkDto
import com.mydeck.app.io.rest.model.EditBookmarkDto
import com.mydeck.app.io.rest.model.EditBookmarkErrorDto
import com.mydeck.app.io.rest.model.EditBookmarkResponseDto
import com.mydeck.app.io.rest.model.ImageResource
import com.mydeck.app.io.rest.model.Resource
import com.mydeck.app.io.rest.model.Resources
import com.mydeck.app.io.rest.model.StatusMessageDto
import com.mydeck.app.io.rest.model.SyncContentRequestDto
import com.mydeck.app.io.rest.model.SyncStatusDto
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import kotlinx.datetime.Clock
import kotlinx.serialization.json.Json
import okhttp3.Headers
import okhttp3.ResponseBody.Companion.toResponseBody
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import retrofit2.Response
import java.io.IOException
import kotlin.time.Duration.Companion.days

@OptIn(ExperimentalCoroutinesApi::class)
class BookmarkRepositoryImplTest {

    private lateinit var bookmarkDao: BookmarkDao
    private lateinit var readeckApi: ReadeckApi
    private lateinit var json: Json
    private lateinit var workManager: WorkManager
    private lateinit var testScope: TestScope
    private lateinit var bookmarkRepositoryImpl: BookmarkRepositoryImpl
    private val testDispatcher = StandardTestDispatcher()

    @Before
    fun setUp() {
        Dispatchers.setMain(testDispatcher)
        bookmarkDao = mockk(relaxed = true)
        readeckApi = mockk()
        json = Json { ignoreUnknownKeys = false }
        workManager = mockk(relaxed = true)
        testScope = TestScope(testDispatcher)
        bookmarkRepositoryImpl = BookmarkRepositoryImpl(
            bookmarkDao = bookmarkDao,
            readeckApi = readeckApi,
            json = json,
            workManager = workManager,
            applicationScope = testScope,
            dispatcher = testDispatcher
        )
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `updateBookmark successful`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val editBookmarkResponseDto = EditBookmarkResponseDto(
            href = "http://example.com",
            id = "123",
            isArchived = true,
            isDeleted = true,
            isMarked = true,
            labels = listOf("label1", "label2"),
            readAnchor = "anchor1",
            readProgress = 50,
            title = "New Title",
            updated = Clock.System.now()
        )
        val response: Response<EditBookmarkResponseDto> = Response.success(editBookmarkResponseDto)
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns response

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = isFavorite,
            isArchived = null,
            isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Success)
    }

    @Test
    fun `updateBookmark error 422`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorDto = EditBookmarkErrorDto(errors = listOf("Invalid input"))
        val errorResponse = Response.error<EditBookmarkResponseDto>(
            422,
            json.encodeToString(EditBookmarkErrorDto.serializer(), errorDto).toResponseBody()
        )
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertEquals("[Invalid input]", (result as BookmarkRepository.UpdateResult.Error).errorMessage)
        assertEquals(422, result.code)
    }

    @Test
    fun `updateBookmark error other than 422`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val statusMessageDto = StatusMessageDto(400, "Bad Request")
        val errorResponse = Response.error<EditBookmarkResponseDto>(
            400,
            json.encodeToString(StatusMessageDto.serializer(), statusMessageDto).toResponseBody()
        )
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertEquals("Bad Request", (result as BookmarkRepository.UpdateResult.Error).errorMessage)
        assertEquals(400, result.code)
    }

    @Test
    fun `updateBookmark network error`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } throws IOException("Network error")

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.NetworkError)
        assertEquals("Network error: Network error", (result as BookmarkRepository.UpdateResult.NetworkError).errorMessage)
        assertTrue(result.ex is IOException)
    }

    @Test
    fun `updateBookmark unexpected error`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } throws RuntimeException("Unexpected error")

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertEquals("An unexpected error occurred: Unexpected error", (result as BookmarkRepository.UpdateResult.Error).errorMessage)
        assertTrue(result.ex is RuntimeException)
    }

    @Test
    fun `updateBookmark error 422 serialization exception`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorResponse = Response.error<EditBookmarkResponseDto>(
            422,
            "{\"invalid_json\": true}".toResponseBody()
        )
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertTrue((result as BookmarkRepository.UpdateResult.Error).errorMessage.contains("Failed to parse error"))
        assertEquals(422, result.code)
    }

    @Test
    fun `updateBookmark other error serialization exception`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorResponse = Response.error<EditBookmarkResponseDto>(
            400,
            "{\"invalid_json\": true}".toResponseBody()
        )
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertTrue((result as BookmarkRepository.UpdateResult.Error).errorMessage.contains("Failed to parse error"))
        assertEquals(400, result.code)
    }

    @Test
    fun `updateBookmark error 422 empty body`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorResponse = Response.error<EditBookmarkResponseDto>(
            422,
            "".toResponseBody()
        )
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertEquals("Empty error body", (result as BookmarkRepository.UpdateResult.Error).errorMessage)
        assertEquals(422, result.code)
    }

    @Test
    fun `updateBookmark other error empty body`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorResponse = Response.error<EditBookmarkResponseDto>(
            400,
            "".toResponseBody()
        )
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(bookmarkId, isFavorite, isArchived = null, isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertEquals("Empty error body", (result as BookmarkRepository.UpdateResult.Error).errorMessage)
        assertEquals(400, result.code)
    }

    @Test
    fun `updateBookmark isFavorite sets correct field in EditBookmarkDto`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val response: Response<EditBookmarkResponseDto> = Response.success(editBookmarkResponseDto)
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = isFavorite)) } returns response

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = isFavorite,
            isArchived = null,
            isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Success)
        coVerify { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isMarked = true)) }
    }

    @Test
    fun `updateBookmark isArchived sets correct field in EditBookmarkDto`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val response: Response<EditBookmarkResponseDto> = Response.success(editBookmarkResponseDto)
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isArchived = true)) } returns response

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = null,
            isArchived = true,
            isRead = null)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Success)
        coVerify { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(isArchived = true)) }
    }

    @Test
    fun `updateBookmark isRead sets correct field in EditBookmarkDto`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val response: Response<EditBookmarkResponseDto> = Response.success(editBookmarkResponseDto)
        coEvery { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(readProgress = 100)) } returns response

        // Act
        val result = bookmarkRepositoryImpl.updateBookmark(
            bookmarkId = bookmarkId,
            isFavorite = null,
            isArchived = null,
            isRead = true)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Success)
        coVerify { readeckApi.editBookmark(bookmarkId, EditBookmarkDto(readProgress = 100)) }
    }

    @Test
    fun `deleteBookmark successful`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val response: Response<Unit> = Response.success(Unit)
        coEvery { readeckApi.deleteBookmark(bookmarkId) } returns response

        // Act
        val result = bookmarkRepositoryImpl.deleteBookmark(id = bookmarkId)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Success)
        coVerify { readeckApi.deleteBookmark(bookmarkId) }
    }

    @Test
    fun `deleteBookmark failure 404`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val statusMessageDto = StatusMessageDto(404, "Not Found")
        val errorResponse = Response.error<Unit>(
            404,
            json.encodeToString(StatusMessageDto.serializer(), statusMessageDto).toResponseBody()
        )
        coEvery { readeckApi.deleteBookmark(bookmarkId) } returns errorResponse

        // Act
        val result = bookmarkRepositoryImpl.deleteBookmark(id = bookmarkId)

        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Error)
        assertEquals("Not Found", (result as BookmarkRepository.UpdateResult.Error).errorMessage)
        assertEquals(404, result.code)
        coVerify { readeckApi.deleteBookmark(bookmarkId) }
    }

    @Test
    fun `performFullSync successful sync with multiple pages`() = runTest {
        // Arrange
        val pageSize = 50
        val totalCount = 120
        val totalPages = 3
        val bookmarkList1 = List(pageSize) { bookmarkDto.copy(id = "bookmark_$it") }
        val bookmarkList2 = List(pageSize) { bookmarkDto.copy(id = "bookmark_${it + pageSize}") }
        val bookmarkList3 = List(20) { bookmarkDto.copy(id = "bookmark_${it + 2 * pageSize}") }

        coEvery {
            readeckApi.getBookmarks(limit = pageSize, offset = 0, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created))
        } returns Response.success(bookmarkList1, Headers.headersOf(
            ReadeckApi.Header.TOTAL_COUNT, totalCount.toString(),
            ReadeckApi.Header.TOTAL_PAGES, totalPages.toString(),
            ReadeckApi.Header.CURRENT_PAGE, "1"
        ))

        coEvery {
            readeckApi.getBookmarks(limit = pageSize, offset = pageSize, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created))
        } returns Response.success(bookmarkList2, Headers.headersOf(
            ReadeckApi.Header.TOTAL_COUNT, totalCount.toString(),
            ReadeckApi.Header.TOTAL_PAGES, totalPages.toString(),
            ReadeckApi.Header.CURRENT_PAGE, "2"
        ))

        coEvery {
            readeckApi.getBookmarks(limit = pageSize, offset = 2 * pageSize, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created))
        } returns Response.success(bookmarkList3, Headers.headersOf(
            ReadeckApi.Header.TOTAL_COUNT, totalCount.toString(),
            ReadeckApi.Header.TOTAL_PAGES, totalPages.toString(),
            ReadeckApi.Header.CURRENT_PAGE, "3"
        ))

        coEvery { bookmarkDao.removeDeletedBookmars() } returns 10
        coEvery { bookmarkDao.insertRemoteBookmarkIds(any()) } returns Unit

        // Act
        val result = bookmarkRepositoryImpl.performFullSync()

        // Assert
        assertTrue(result is BookmarkRepository.SyncResult.Success)
        assertEquals(10, (result as BookmarkRepository.SyncResult.Success).countDeleted)

        coVerify { readeckApi.getBookmarks(limit = pageSize, offset = 0, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created)) }
        coVerify { readeckApi.getBookmarks(limit = pageSize, offset = pageSize, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created)) }
        coVerify { readeckApi.getBookmarks(limit = pageSize, offset = 2 * pageSize, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created)) }
        coVerify { bookmarkDao.insertRemoteBookmarkIds(any()) }
        coVerify { bookmarkDao.removeDeletedBookmars() }
        coVerify { bookmarkDao.clearRemoteBookmarkIds() }
    }

    @Test
    fun `performFullSync API error`() = runTest {
        // Arrange
        coEvery { readeckApi.getBookmarks(limit = any(), offset = any(), updatedSince = any(), ReadeckApi.SortOrder(ReadeckApi.Sort.Created)) } returns Response.error(500, "Error".toResponseBody())

        // Act
        val result = bookmarkRepositoryImpl.performFullSync()

        // Assert
        assertTrue(result is BookmarkRepository.SyncResult.Error)
        assertEquals("Full sync failed", (result as BookmarkRepository.SyncResult.Error).errorMessage)
        assertEquals(500, result.code)
    }

    @Test
    fun `performFullSync missing headers`() = runTest {
        // Arrange
        coEvery { readeckApi.getBookmarks(limit = any(), offset = any(), updatedSince = any(), ReadeckApi.SortOrder(ReadeckApi.Sort.Created)) } returns Response.success(emptyList())

        // Act
        val result = bookmarkRepositoryImpl.performFullSync()

        // Assert
        assertTrue(result is BookmarkRepository.SyncResult.Error)
        assertEquals("Missing headers in API response", (result as BookmarkRepository.SyncResult.Error).errorMessage)
    }

    @Test
    fun `performFullSync network error`() = runTest {
        // Arrange
        coEvery { readeckApi.getBookmarks(limit = any(), offset = any(), updatedSince = any(), ReadeckApi.SortOrder(ReadeckApi.Sort.Created)) } throws IOException("Network error")

        // Act
        val result = bookmarkRepositoryImpl.performFullSync()

        // Assert
        assertTrue(result is BookmarkRepository.SyncResult.NetworkError)
        assertEquals("Network error during full sync", (result as BookmarkRepository.SyncResult.NetworkError).errorMessage)
        assertTrue(result.ex is IOException)
    }


    @Test
    fun `performDeltaSync returns error because it is disabled`() = runTest {
        // Arrange
        val since = kotlinx.datetime.Instant.parse("2023-10-27T10:00:00Z")

        // Act
        val result = bookmarkRepositoryImpl.performDeltaSync(since)

        // Assert
        assertTrue(result is BookmarkRepository.SyncResult.Error)
        assertTrue((result as BookmarkRepository.SyncResult.Error).errorMessage.contains("Delta sync disabled"))
    }

    @Test
    fun `createBookmark successful`() = runTest {
        // Arrange
        val title = "Test Bookmark"
        val url = "https://example.com"
        val labels = listOf("test", "bookmark")
        val bookmarkId = "new-bookmark-id"
        
        val createBookmarkDto = CreateBookmarkDto(labels = labels, title = title, url = url)
        val headers = Headers.Builder()
            .add(ReadeckApi.Header.BOOKMARK_ID, bookmarkId)
            .build()
        coEvery { readeckApi.createBookmark(createBookmarkDto) } returns Response.success(StatusMessageDto(200, "Created"), headers)
        
        val bookmarkResponse = Response.success(bookmarkDto.copy(
            id = bookmarkId,
            state = 1, // LOADED
            hasArticle = true
        ))
        coEvery { readeckApi.getBookmarkById(bookmarkId) } returns bookmarkResponse
        
        // Act
        val result = bookmarkRepositoryImpl.createBookmark(title, url, labels)
        
        // Assert
        assertEquals(bookmarkId, result)
        coVerify { readeckApi.createBookmark(createBookmarkDto) }
        coVerify { readeckApi.getBookmarkById(bookmarkId) }
        coVerify { bookmarkDao.insertBookmarksWithArticleContent(any()) }
        coVerify { workManager.enqueue(any<WorkRequest>()) }
    }

    @Test
    fun `refreshBookmarkFromApi successful`() = runTest {
        // Arrange
        val bookmarkId = "test-bookmark-id"
        val updatedBookmark = bookmarkDto.copy(title = "Updated Title")
        val response = Response.success(updatedBookmark)
        
        coEvery { readeckApi.getBookmarkById(bookmarkId) } returns response
        
        // Act
        bookmarkRepositoryImpl.refreshBookmarkFromApi(bookmarkId)
        
        // Assert
        coVerify { readeckApi.getBookmarkById(bookmarkId) }
        coVerify { bookmarkDao.insertBookmarksWithArticleContent(any()) }
    }

    @Test
    fun `updateReadProgress successful`() = runTest {
        // Arrange
        val bookmarkId = "test-bookmark-id"
        val progress = 75
        val response = Response.success(editBookmarkResponseDto)
        
        coEvery { 
            readeckApi.editBookmark(
                id = bookmarkId,
                body = EditBookmarkDto(readProgress = progress)
            )
        } returns response
        
        // Act
        val result = bookmarkRepositoryImpl.updateReadProgress(bookmarkId, progress)
        
        // Assert
        assertTrue(result is BookmarkRepository.UpdateResult.Success)
        coVerify { 
            readeckApi.editBookmark(
                id = bookmarkId,
                body = EditBookmarkDto(readProgress = progress)
            )
        }
        coVerify { bookmarkDao.updateReadProgress(bookmarkId, progress) }
    }

    private val editBookmarkResponseDto = EditBookmarkResponseDto(
        href = "http://example.com",
        id = "123",
        isArchived = true,
        isDeleted = true,
        isMarked = true,
        labels = listOf("label1", "label2"),
        readAnchor = "anchor1",
        readProgress = 50,
        title = "New Title",
        updated = Clock.System.now()
    )

    val bookmarkDto = BookmarkDto(
        id = "1",
        href = "https://example.com",
        created = Clock.System.now().minus(1.days),
        updated = Clock.System.now().minus(1.days),
        state = 1,
        loaded = true,
        url = "https://example.com/article",
        title = "Sample Article",
        siteName = "Example Site",
        site = "example.com",
        authors = listOf("John Doe", "Jane Smith"),
        lang = "en",
        textDirection = "ltr",
        documentTpe = "article",
        type = "article",
        hasArticle = true,
        description = "This is a sample article description.",
        isDeleted = false,
        isMarked = false,
        isArchived = false,
        labels = listOf("sample", "article"),
        readProgress = 0,
        resources = Resources(
            article = Resource(src = "https://example.com/article.pdf"),
            icon = ImageResource(src = "https://example.com/icon.png", width = 32, height = 32),
            image = ImageResource(src = "https://example.com/image.jpg", width = 600, height = 400),
            log = Resource(src = "https://example.com/log.txt"),
            props = Resource(src = "https://example.com/props.json"),
            thumbnail = ImageResource(
                src = "https://example.com/thumbnail.jpg",
                width = 200,
                height = 150
            )
        ),
        wordCount = 1000,
        readingTime = 5
    )
}
</file>

<file path="app/src/test/java/com/mydeck/app/ui/detail/BookmarkDetailViewModelTest.kt">
package com.mydeck.app.ui.detail

import androidx.lifecycle.SavedStateHandle
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.domain.usecase.UpdateBookmarkUseCase
import com.mydeck.app.io.AssetLoader
import com.mydeck.app.io.prefs.SettingsDataStore
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.take
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.advanceUntilIdle
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import kotlinx.datetime.toInstant
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Before
import org.junit.Test
import java.text.DateFormat
import java.util.Date

@OptIn(ExperimentalCoroutinesApi::class)
class BookmarkDetailViewModelTest {

    private val testDispatcher = StandardTestDispatcher()
    private lateinit var bookmarkRepository: BookmarkRepository
    private lateinit var assetLoader: AssetLoader
    private lateinit var savedStateHandle: SavedStateHandle
    private lateinit var viewModel: BookmarkDetailViewModel
    private lateinit var updateBookmarkUseCase: UpdateBookmarkUseCase
    private lateinit var settingsDataStore: SettingsDataStore

    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        bookmarkRepository = mockk()
        assetLoader = mockk()
        savedStateHandle = mockk()
        updateBookmarkUseCase = mockk()
        settingsDataStore = mockk()
        every { bookmarkRepository.observeBookmark(any()) } returns MutableStateFlow(sampleBookmark)
        coEvery { bookmarkRepository.getBookmarkById(any()) } returns sampleBookmark
        coEvery { bookmarkRepository.refreshBookmarkFromApi(any()) } returns Unit
        every { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate
        every { savedStateHandle.get<String>("bookmarkId") } returns "123"
        every { settingsDataStore.themeFlow } returns MutableStateFlow(Theme.LIGHT.name)
        every { settingsDataStore.zoomFactorFlow } returns MutableStateFlow(100)
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }

    @Test
    fun `uiState emits success when bookmark and html template are loaded successfully`() = runTest {
        // Arrange
        val bookmark = Bookmark(
            id = "123",
            href = "https://example.com",
            created = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
            updated = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
            state = Bookmark.State.LOADED,
            loaded = true,
            url = "https://example.com",
            title = "Test Bookmark",
            siteName = "Example Site",
            site = "example.com",
            authors = listOf("Author 1", "Author 2"),
            lang = "en",
            textDirection = "ltr",
            documentTpe = "article",
            type = Bookmark.Type.Article,
            hasArticle = true,
            description = "Test Description",
            isDeleted = false,
            isMarked = false,
            isArchived = false,
            labels = emptyList(),
            readProgress = 0,
            wordCount = 0,
            readingTime = 0,
            published = null,
            embed = null,
            embedHostname = null,
            article = Bookmark.Resource(""),
            articleContent = "Test Article Content",
            icon = Bookmark.ImageResource("", 0, 0),
            image = Bookmark.ImageResource("", 0, 0),
            log = Bookmark.Resource(""),
            props = Bookmark.Resource(""),
            thumbnail = Bookmark.ImageResource("", 0, 0)
        )
        val htmlTemplate = "<html><body>%s</body></html>"
        val expectedHtmlContent = htmlTemplate.replace("%s", bookmark.articleContent!!)
        val expectedCreatedDate = DateFormat.getDateInstance(DateFormat.MEDIUM).format(
            Date(bookmark.created.toInstant(kotlinx.datetime.TimeZone.UTC).toEpochMilliseconds())
        )

        coEvery { bookmarkRepository.observeBookmark("123") } returns MutableStateFlow(bookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        val uiStates = viewModel.uiState.take(2).toList()
        val loading = uiStates[0]
        val success = uiStates[1]

        // Assert initial state
        assert(loading is BookmarkDetailViewModel.UiState.Loading)
        // Assert success state
        assert(success is BookmarkDetailViewModel.UiState.Success)
        success as BookmarkDetailViewModel.UiState.Success
        assertEquals("Test Bookmark", success.bookmark.title)
        assertEquals(expectedCreatedDate, success.bookmark.createdDate)
        assertEquals("123", success.bookmark.bookmarkId)
        assertEquals("Example Site", success.bookmark.siteName)
    }

    @Test
    fun `uiState emits error when html template loading fails`() = runTest {
        // Arrange
        val bookmark = Bookmark(
            id = "123",
            href = "https://example.com",
            created = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
            updated = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
            state = Bookmark.State.LOADED,
            loaded = true,
            url = "https://example.com",
            title = "Test Bookmark",
            siteName = "Example Site",
            site = "example.com",
            authors = listOf("Author 1", "Author 2"),
            lang = "en",
            textDirection = "ltr",
            documentTpe = "article",
            type = Bookmark.Type.Article,
            hasArticle = true,
            description = "Test Description",
            isDeleted = false,
            isMarked = false,
            isArchived = false,
            labels = emptyList(),
            readProgress = 0,
            wordCount = 0,
            readingTime = 0,
            published = null,
            embed = null,
            embedHostname = null,
            article = Bookmark.Resource(""),
            articleContent = "Test Article Content",
            icon = Bookmark.ImageResource("", 0, 0),
            image = Bookmark.ImageResource("", 0, 0),
            log = Bookmark.Resource(""),
            props = Bookmark.Resource(""),
            thumbnail = Bookmark.ImageResource("", 0, 0)
        )
        coEvery { bookmarkRepository.observeBookmark("123") } returns MutableStateFlow(bookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns null

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        val uiStates = viewModel.uiState.take(2).toList()
        val loading = uiStates[0]
        val error = uiStates[1]
        // Assert initial state
        assert(loading is BookmarkDetailViewModel.UiState.Loading)
        // Assert error state
        assert(error is BookmarkDetailViewModel.UiState.Error)
    }

    @Test
    fun `uiState emits loading initially`() = runTest {
        // Arrange
        val bookmarkFlow = MutableStateFlow(Bookmark(
            id = "123",
            href = "https://example.com",
            created = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
            updated = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
            state = Bookmark.State.LOADED,
            loaded = true,
            url = "https://example.com",
            title = "Test Bookmark",
            siteName = "Example Site",
            site = "example.com",
            authors = listOf("Author 1", "Author 2"),
            lang = "en",
            textDirection = "ltr",
            documentTpe = "article",
            type = Bookmark.Type.Article,
            hasArticle = true,
            description = "Test Description",
            isDeleted = false,
            isMarked = false,
            isArchived = false,
            labels = emptyList(),
            readProgress = 0,
            wordCount = 0,
            readingTime = 0,
            published = null,
            embed = null,
            embedHostname = null,
            article = Bookmark.Resource(""),
            articleContent = "Test Article Content",
            icon = Bookmark.ImageResource("", 0, 0),
            image = Bookmark.ImageResource("", 0, 0),
            log = Bookmark.Resource(""),
            props = Bookmark.Resource(""),
            thumbnail = Bookmark.ImageResource("", 0, 0)
        ))
        coEvery { bookmarkRepository.observeBookmark("123") } returns bookmarkFlow
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns "template"

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)

        // Assert
        assertEquals(BookmarkDetailViewModel.UiState.Loading, viewModel.uiState.value)
    }

    @Test
    fun `onNavigationEventConsumed should reset navigation event`() = runTest {
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onClickBack()
        viewModel.onNavigationEventConsumed()
        assertNull(viewModel.navigationEvent.first())
    }

    @Test
    fun `onClickBack should set NavigateBack navigation event`() = runTest {
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onClickBack()
        assertEquals(BookmarkDetailViewModel.NavigationEvent.NavigateBack, viewModel.navigationEvent.first())
    }

    @Test
    fun `onToggleFavoriteBookmark updates UiState with Success`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        coEvery { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) } returns UpdateBookmarkUseCase.Result.Success
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleFavorite(bookmarkId, isFavorite)
        advanceUntilIdle()

        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Success, (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) }
    }

    @Test
    fun `onToggleFavoriteBookmark updates UiState with GenericError`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorMessage = "Generic Error"
        coEvery { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) } returns UpdateBookmarkUseCase.Result.GenericError(errorMessage)
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleFavorite(bookmarkId, isFavorite)
        advanceUntilIdle()

        // Assert
        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Error(errorMessage), (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) }
    }

    @Test
    fun `onToggleFavoriteBookmark updates UiState with NetworkError`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isFavorite = true
        val errorMessage = "Network Error"
        coEvery { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) } returns UpdateBookmarkUseCase.Result.NetworkError(errorMessage)
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleFavorite(bookmarkId, isFavorite)
        advanceUntilIdle()

        // Assert
        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Error(errorMessage), (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsFavorite(bookmarkId, isFavorite) }
    }

    @Test
    fun `onToggleArchivedBookmark updates UiState with Success`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isArchived = true
        coEvery { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) } returns UpdateBookmarkUseCase.Result.Success
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleArchive(bookmarkId, isArchived)
        advanceUntilIdle()

        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Success, (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) }
    }

    @Test
    fun `onToggleArchivedBookmark updates UiState with GenericError`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isArchived = true
        val errorMessage = "Generic Error"
        coEvery { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) } returns UpdateBookmarkUseCase.Result.GenericError(errorMessage)
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleArchive(bookmarkId, isArchived)
        advanceUntilIdle()

        // Assert
        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Error(errorMessage), (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) }
    }

    @Test
    fun `onToggleArchivedBookmark updates UiState with NetworkError`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isArchived = true
        val errorMessage = "Network Error"
        coEvery { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) } returns UpdateBookmarkUseCase.Result.NetworkError(errorMessage)
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleArchive(bookmarkId, isArchived)
        advanceUntilIdle()

        // Assert
        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Error(errorMessage), (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsArchived(bookmarkId, isArchived) }
    }
    @Test
    fun `onToggleMarkReadBookmark updates UiState with Success`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isRead = true
        coEvery { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) } returns UpdateBookmarkUseCase.Result.Success
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleMarkRead(bookmarkId, isRead)
        advanceUntilIdle()

        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Success, (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) }
    }

    @Test
    fun `onToggleMarkReadBookmark updates UiState with GenericError`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isRead = true
        val errorMessage = "Generic Error"
        coEvery { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) } returns UpdateBookmarkUseCase.Result.GenericError(errorMessage)
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleMarkRead(bookmarkId, isRead)
        advanceUntilIdle()

        // Assert
        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Error(errorMessage), (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) }
    }

    @Test
    fun `onToggleMarkReadBookmark updates UiState with NetworkError`() = runTest {
        // Arrange
        val bookmarkId = "123"
        val isRead = true
        val errorMessage = "Network Error"
        coEvery { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) } returns UpdateBookmarkUseCase.Result.NetworkError(errorMessage)
        every { bookmarkRepository.observeBookmark(bookmarkId) } returns MutableStateFlow(sampleBookmark)
        coEvery { assetLoader.loadAsset("html_template_light.html") } returns htmlTemplate

        // Act
        viewModel = BookmarkDetailViewModel(updateBookmarkUseCase, bookmarkRepository, assetLoader, settingsDataStore, savedStateHandle)
        viewModel.onToggleMarkRead(bookmarkId, isRead)
        advanceUntilIdle()

        // Assert
        val uiStates = viewModel.uiState.take(2).toList()
        val loadingState = uiStates[0]
        val successState = uiStates[1]
        assert(loadingState is BookmarkDetailViewModel.UiState.Loading)
        assert(successState is BookmarkDetailViewModel.UiState.Success)
        assertEquals(BookmarkDetailViewModel.UpdateBookmarkState.Error(errorMessage), (successState as BookmarkDetailViewModel.UiState.Success).updateBookmarkState)
        coVerify { updateBookmarkUseCase.updateIsRead(bookmarkId, isRead) }
    }
    val sampleBookmark = Bookmark(
        id = "123",
        href = "https://example.com",
        created = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
        updated = kotlinx.datetime.LocalDateTime(2024, 1, 20, 12, 0, 0),
        state = Bookmark.State.LOADED,
        loaded = true,
        url = "https://example.com",
        title = "Test Bookmark",
        siteName = "Example Site",
        site = "example.com",
        authors = listOf("Author 1", "Author 2"),
        lang = "en",
        textDirection = "ltr",
        documentTpe = "article",
        type = Bookmark.Type.Article,
        hasArticle = true,
        description = "Test Description",
        isDeleted = false,
        isMarked = false,
        isArchived = false,
        labels = emptyList(),
        readProgress = 0,
        wordCount = 0,
        readingTime = 0,
        embed = null,
        embedHostname = null,
        article = Bookmark.Resource(""),
        articleContent = "Test Article Content",
        icon = Bookmark.ImageResource("", 0, 0),
        image = Bookmark.ImageResource("", 0, 0),
        log = Bookmark.Resource(""),
        props = Bookmark.Resource(""),
        thumbnail = Bookmark.ImageResource("", 0, 0)
    )
    val htmlTemplate = "<html><body>%s</body></html>"
}
</file>

<file path="app/build.gradle.kts">
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.dagger.hilt)
    alias(libs.plugins.kotlin.serialization)
    alias(libs.plugins.androidx.room)
    alias(libs.plugins.ksp)
    alias(libs.plugins.aboutLibraries)
}

android {
    namespace = "com.mydeck.app"
    compileSdk = 35

    dependenciesInfo {
        includeInApk = false
        includeInBundle = false
    }

    defaultConfig {
        multiDexEnabled = true
        applicationId = "com.mydeck.app"
        minSdk = 24
        targetSdk = 35
        versionCode = 800
        versionName = "0.8.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

        buildConfigField("long", "BUILD_TIME", "${System.currentTimeMillis()}L")
    }

    signingConfigs {
        create("release") {
            val appKeystoreFile = System.getenv("KEYSTORE")
            if (appKeystoreFile != null && file(appKeystoreFile).exists()) {
                storeFile = file(appKeystoreFile)
                storePassword = System.getenv("KEYSTORE_PASSWORD")
                keyAlias = System.getenv("KEY_ALIAS")
                keyPassword = System.getenv("KEY_PASSWORD")
            }
            enableV1Signing = true
            enableV2Signing = true
            enableV3Signing = true
            enableV4Signing = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            isDebuggable = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug {
            isMinifyEnabled = false
            isShrinkResources = false
            isDebuggable = true
        }
    }

    flavorDimensions += "version"
    productFlavors {
        create("githubSnapshot") {
            dimension = "version"
            applicationIdSuffix = ".snapshot"
            versionName = System.getenv("SNAPSHOT_VERSION_NAME") ?: "${defaultConfig.versionName}-snapshot"
            versionCode = System.getenv("SNAPSHOT_VERSION_CODE")?.toInt() ?: defaultConfig.versionCode
            if (signingConfigs.getByName("release").storeFile != null) {
                signingConfig = signingConfigs.getByName("release")
            }
        }
        create("githubRelease") {
            dimension = "version"
            versionName = System.getenv("RELEASE_VERSION_NAME") ?: defaultConfig.versionName
            versionCode = System.getenv("RELEASE_VERSION_CODE")?.toInt() ?: defaultConfig.versionCode
            if (signingConfigs.getByName("release").storeFile != null) {
                signingConfig = signingConfigs.getByName("release")
            }
        }
    }

    buildFeatures {
        buildConfig = true
        compose = true
        viewBinding = true
    }

    compileOptions {
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    room {
        schemaDirectory("$projectDir/schemas")
    }

    testOptions {
        unitTests {
            isIncludeAndroidResources = true
        }
    }

    sourceSets {
        getByName("debug").assets.srcDirs(files("$projectDir/schemas"))
    }

    lint {
        abortOnError = true
        baseline = file("lint-baseline.xml")
    }

    applicationVariants.all {
        val variant = this
        outputs.all {
            val output = this
            if (output is com.android.build.gradle.internal.api.ApkVariantOutputImpl) {
                val newName = "MyDeck-${variant.versionName}.apk"
                output.outputFileName = newName
            }
        }
    }
}

dependencies {
    coreLibraryDesugaring(libs.desugar.jdk.libs)
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.androidx.junit)
    implementation(libs.androidx.ui.test.junit4.android)
    implementation(libs.androidx.browser)
    
    // hilt
    ksp(libs.dagger.hilt.android.compiler)
    ksp(libs.androidx.hilt.compiler)
    implementation(libs.androidx.hilt.navigation)
    implementation(libs.dagger.hilt.android)
    testImplementation(libs.dagger.hilt.android.testing)
    kspTest(libs.androidx.hilt.compiler)

    implementation(libs.retrofit)
    implementation(libs.retrofit.converter.kotlinx.serialization)
    implementation(libs.retrofit.converter.scalars)
    implementation(libs.androidx.room.runtime)
    implementation(libs.androidx.room.ktx)
    implementation(libs.timber)
    implementation(libs.androidx.appcompat)
    implementation(libs.androidx.constraintlayout)
    implementation(libs.material)
    implementation(libs.androidx.material.icons)
    implementation(libs.androidx.lifecycle.livedata.ktx)
    implementation(libs.androidx.lifecycle.viewmodel.ktx)
    implementation(libs.androidx.navigation.fragment.ktx)
    implementation(libs.androidx.navigation.ui.ktx)
    implementation(libs.androidx.navigation.compose)
    
    testImplementation(libs.junit)
    testImplementation(libs.mockk)
    testImplementation(libs.kotlinx.coroutines.test)
    testImplementation(libs.androidx.room.testing)
    testImplementation(libs.robolectric)
    
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
    
    implementation(libs.kotlin.serialization.json)
    implementation(libs.kotlinx.datetime)
    ksp(libs.androidx.room.compiler)

    implementation(libs.coil.compose)
    implementation(libs.coil.network.okhttp)
    implementation(libs.coil.svg)
    implementation(libs.okhttp3.logging.interceptor)
    testImplementation(libs.okhttp3.mockserver)
    implementation(libs.androidx.datastore.preferences)
    implementation(libs.androidx.datastore.preferences.core)
    implementation(libs.androidx.security.crypto)
    implementation(libs.google.crypto.tink)
    implementation(libs.androidx.work.runtime.ktx)
    implementation(libs.androidx.hilt.work)

    implementation(libs.aboutlibraries.core)
    implementation(libs.aboutlibraries.compose.m3)
    implementation(libs.treessence)
    implementation(libs.accompanist.permissions)
}

aboutLibraries {
    registerAndroidTasks = false
    prettyPrint = true
    configPath = "config"
}

tasks.whenTaskAdded {
    if (name.contains("ArtProfile")) {
        enabled = false
    }
}
</file>

<file path="app/lint-baseline.xml">
<?xml version="1.0" encoding="UTF-8"?>
<issues format="6" by="lint 8.13.2" type="baseline" client="gradle" dependencies="false" name="AGP (8.13.2)" variant="all" version="8.13.2">

    <issue
        id="OldTargetApi"
        message="Not targeting the latest versions of Android; compatibility modes apply. Consider testing and updating this version. Consult the `android.os.Build.VERSION_CODES` javadoc for details."
        errorLine1="        targetSdk = 35"
        errorLine2="        ~~~~~~~~~~~~~~">
        <location
            file="build.gradle.kts"
            line="28"
            column="9"/>
    </issue>

    <issue
        id="EnsureInitializerMetadata"
        message="Every Initializer needs to be accompanied by a corresponding &lt;meta-data> entry in the AndroidManifest.xml file.">
        <location
            file="src/main/java/com/mydeck/app/AppModule.kt"/>
    </issue>

    <issue
        id="RedundantLabel"
        message="Redundant label can be removed"
        errorLine1="            android:label=&quot;@string/app_name&quot;"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/AndroidManifest.xml"
            line="23"
            column="13"/>
    </issue>

    <issue
        id="AndroidGradlePluginVersion"
        message="A newer version of Gradle than 8.13 is available: 8.14.4"
        errorLine1="distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip"
        errorLine2="                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/wrapper/gradle-wrapper.properties"
            line="4"
            column="17"/>
    </issue>

    <issue
        id="AndroidGradlePluginVersion"
        message="A newer version of com.android.application than 8.13.2 is available: 9.0.0"
        errorLine1="agp = &quot;8.13.2&quot;"
        errorLine2="      ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="2"
            column="7"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of `compileSdkVersion` than 35 is available: 36"
        errorLine1="    compileSdk = 35"
        errorLine2="    ~~~~~~~~~~~~~~~">
        <location
            file="build.gradle.kts"
            line="15"
            column="5"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.core:core-ktx than 1.15.0 is available: 1.17.0"
        errorLine1="coreKtx = &quot;1.15.0&quot;"
        errorLine2="          ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="5"
            column="11"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.test.ext:junit than 1.2.1 is available: 1.3.0"
        errorLine1="junitVersion = &quot;1.2.1&quot;"
        errorLine2="               ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="7"
            column="16"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.test.espresso:espresso-core than 3.5.0 is available: 3.7.0"
        errorLine1="espressoCore = &quot;3.5.0&quot;"
        errorLine2="               ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="8"
            column="16"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.lifecycle:lifecycle-runtime-ktx than 2.8.7 is available: 2.10.0"
        errorLine1="lifecycleRuntimeKtx = &quot;2.8.7&quot;"
        errorLine2="                      ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="9"
            column="23"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.activity:activity-compose than 1.10.1 is available: 1.12.3"
        errorLine1="activityCompose = &quot;1.10.1&quot;"
        errorLine2="                  ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="10"
            column="19"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.compose:compose-bom than 2025.04.01 is available: 2026.01.01"
        errorLine1="composeBom = &quot;2025.04.01&quot;"
        errorLine2="             ~~~~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="11"
            column="14"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.hilt:hilt-common than 1.2.0 is available: 1.3.0"
        errorLine1="androidHilt = &quot;1.2.0&quot;"
        errorLine2="              ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="14"
            column="15"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.hilt:hilt-compiler than 1.2.0 is available: 1.3.0"
        errorLine1="androidHilt = &quot;1.2.0&quot;"
        errorLine2="              ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="14"
            column="15"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.hilt:hilt-navigation-compose than 1.2.0 is available: 1.3.0"
        errorLine1="androidHilt = &quot;1.2.0&quot;"
        errorLine2="              ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="14"
            column="15"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.hilt:hilt-work than 1.2.0 is available: 1.3.0"
        errorLine1="androidHilt = &quot;1.2.0&quot;"
        errorLine2="              ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="14"
            column="15"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.room than 2.7.1 is available: 2.8.4"
        errorLine1="room = &quot;2.7.1&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="19"
            column="8"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.room:room-compiler than 2.7.1 is available: 2.8.4"
        errorLine1="room = &quot;2.7.1&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="19"
            column="8"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.room:room-ktx than 2.7.1 is available: 2.8.4"
        errorLine1="room = &quot;2.7.1&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="19"
            column="8"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.room:room-runtime than 2.7.1 is available: 2.8.4"
        errorLine1="room = &quot;2.7.1&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="19"
            column="8"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.room:room-testing than 2.7.1 is available: 2.8.4"
        errorLine1="room = &quot;2.7.1&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="19"
            column="8"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.appcompat:appcompat than 1.7.0 is available: 1.7.1"
        errorLine1="appcompat = &quot;1.7.0&quot;"
        errorLine2="            ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="23"
            column="13"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of com.google.android.material:material than 1.12.0 is available: 1.13.0"
        errorLine1="material = &quot;1.12.0&quot;"
        errorLine2="           ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="25"
            column="12"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.lifecycle:lifecycle-livedata-ktx than 2.8.7 is available: 2.10.0"
        errorLine1="lifecycleLivedataKtx = &quot;2.8.7&quot;"
        errorLine2="                       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="26"
            column="24"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.lifecycle:lifecycle-viewmodel-ktx than 2.8.7 is available: 2.10.0"
        errorLine1="lifecycleViewmodelKtx = &quot;2.8.7&quot;"
        errorLine2="                        ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="27"
            column="25"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.navigation:navigation-fragment-ktx than 2.8.9 is available: 2.9.7"
        errorLine1="navigationFragmentKtx = &quot;2.8.9&quot;"
        errorLine2="                        ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="28"
            column="25"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.navigation:navigation-compose than 2.8.9 is available: 2.9.7"
        errorLine1="navigationUiKtx = &quot;2.8.9&quot;"
        errorLine2="                  ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="29"
            column="19"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.navigation:navigation-ui-ktx than 2.8.9 is available: 2.9.7"
        errorLine1="navigationUiKtx = &quot;2.8.9&quot;"
        errorLine2="                  ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="29"
            column="19"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.datastore:datastore-preferences than 1.1.3 is available: 1.2.0"
        errorLine1="datastore = &quot;1.1.3&quot;"
        errorLine2="            ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="32"
            column="13"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.datastore:datastore-preferences-core than 1.1.3 is available: 1.2.0"
        errorLine1="datastore = &quot;1.1.3&quot;"
        errorLine2="            ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="32"
            column="13"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.security:security-crypto than 1.1.0-alpha06 is available: 1.1.0"
        errorLine1="androidxCrypto = &quot;1.1.0-alpha06&quot;"
        errorLine2="                 ~~~~~~~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="33"
            column="18"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.work:work-runtime-ktx than 2.10.0 is available: 2.11.1"
        errorLine1="workManager = &quot;2.10.0&quot;"
        errorLine2="              ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="35"
            column="15"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.paging:paging-runtime-ktx than 3.3.6 is available: 3.4.0"
        errorLine1="paging = &quot;3.3.6&quot;"
        errorLine2="         ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="36"
            column="10"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.compose.ui:ui-test-junit4-android than 1.7.8 is available: 1.10.2"
        errorLine1="uiTestJunit4Android = &quot;1.7.8&quot;"
        errorLine2="                      ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="37"
            column="23"/>
    </issue>

    <issue
        id="GradleDependency"
        message="A newer version of androidx.browser:browser than 1.8.0 is available: 1.9.0"
        errorLine1="browser = &quot;1.8.0&quot;"
        errorLine2="          ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="41"
            column="11"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.jetbrains.kotlin.android than 2.0.0 is available: 2.3.0"
        errorLine1="kotlin = &quot;2.0.0&quot;"
        errorLine2="         ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="4"
            column="10"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.jetbrains.kotlin.plugin.compose than 2.0.0 is available: 2.3.0"
        errorLine1="kotlin = &quot;2.0.0&quot;"
        errorLine2="         ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="4"
            column="10"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.jetbrains.kotlin.plugin.serialization than 2.0.0 is available: 2.3.0"
        errorLine1="kotlin = &quot;2.0.0&quot;"
        errorLine2="         ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="4"
            column="10"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.squareup.retrofit2:converter-kotlinx-serialization than 2.11.0 is available: 3.0.0"
        errorLine1="retrofit = &quot;2.11.0&quot;"
        errorLine2="           ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="12"
            column="12"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.squareup.retrofit2:converter-scalars than 2.11.0 is available: 3.0.0"
        errorLine1="retrofit = &quot;2.11.0&quot;"
        errorLine2="           ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="12"
            column="12"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.squareup.retrofit2:retrofit than 2.11.0 is available: 3.0.0"
        errorLine1="retrofit = &quot;2.11.0&quot;"
        errorLine2="           ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="12"
            column="12"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.google.dagger.hilt.android than 2.55 is available: 2.59.1"
        errorLine1="daggerHilt = &quot;2.55&quot;"
        errorLine2="             ~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="13"
            column="14"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.google.dagger:hilt-android than 2.55 is available: 2.59.1"
        errorLine1="daggerHilt = &quot;2.55&quot;"
        errorLine2="             ~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="13"
            column="14"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.google.dagger:hilt-android-compiler than 2.55 is available: 2.59.1"
        errorLine1="daggerHilt = &quot;2.55&quot;"
        errorLine2="             ~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="13"
            column="14"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.google.dagger:hilt-android-testing than 2.55 is available: 2.59.1"
        errorLine1="daggerHilt = &quot;2.55&quot;"
        errorLine2="             ~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="13"
            column="14"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.google.dagger:hilt-compiler than 2.55 is available: 2.59.1"
        errorLine1="daggerHilt = &quot;2.55&quot;"
        errorLine2="             ~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="13"
            column="14"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.jetbrains.kotlinx:kotlinx-serialization-json than 1.8.0 is available: 1.10.0"
        errorLine1="kotlinxSerializationJson = &quot;1.8.0&quot;"
        errorLine2="                           ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="15"
            column="28"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.jetbrains.kotlinx:kotlinx-datetime than 0.6.1 is available: 0.7.1"
        errorLine1="kotlinxDateTime = &quot;0.6.1&quot;"
        errorLine2="                  ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="16"
            column="19"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of io.mockk:mockk than 1.13.16 is available: 1.14.9"
        errorLine1="mockk = &quot;1.13.16&quot;"
        errorLine2="        ~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="17"
            column="9"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.jetbrains.kotlinx:kotlinx-coroutines-test than 1.10.1 is available: 1.10.2"
        errorLine1="coroutinesTest = &quot;1.10.1&quot;"
        errorLine2="                 ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="18"
            column="18"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of org.robolectric:robolectric than 4.14 is available: 4.16.1"
        errorLine1="robolectric = &quot;4.14&quot;"
        errorLine2="              ~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="20"
            column="15"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of io.coil-kt.coil3:coil-compose than 3.1.0 is available: 3.3.0"
        errorLine1="coil = &quot;3.1.0&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="30"
            column="8"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of io.coil-kt.coil3:coil-network-okhttp than 3.1.0 is available: 3.3.0"
        errorLine1="coil = &quot;3.1.0&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="30"
            column="8"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of io.coil-kt.coil3:coil-svg than 3.1.0 is available: 3.3.0"
        errorLine1="coil = &quot;3.1.0&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="30"
            column="8"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.squareup.okhttp3:logging-interceptor than 4.12.0 is available: 5.3.2"
        errorLine1="okhttp3 = &quot;4.12.0&quot;"
        errorLine2="          ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="31"
            column="11"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.squareup.okhttp3:mockwebserver than 4.12.0 is available: 5.3.2"
        errorLine1="okhttp3 = &quot;4.12.0&quot;"
        errorLine2="          ~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="31"
            column="11"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.google.crypto.tink:tink-android than 1.8.0 is available: 1.20.0"
        errorLine1="tink = &quot;1.8.0&quot;"
        errorLine2="       ~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="34"
            column="8"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.mikepenz.aboutlibraries.plugin than 12.0.0-a04 is available: 13.2.1"
        errorLine1="aboutLibraries = &quot;12.0.0-a04&quot;"
        errorLine2="                 ~~~~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="38"
            column="18"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.mikepenz:aboutlibraries-compose-m3 than 12.0.0-a04 is available: 13.2.1"
        errorLine1="aboutLibraries = &quot;12.0.0-a04&quot;"
        errorLine2="                 ~~~~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="38"
            column="18"/>
    </issue>

    <issue
        id="NewerVersionAvailable"
        message="A newer version of com.mikepenz:aboutlibraries-core than 12.0.0-a04 is available: 13.2.1"
        errorLine1="aboutLibraries = &quot;12.0.0-a04&quot;"
        errorLine2="                 ~~~~~~~~~~~~">
        <location
            file="$HOME/development/MyDeck/gradle/libs.versions.toml"
            line="38"
            column="18"/>
    </issue>

    <issue
        id="MutableCollectionMutableState"
        message="Creating a MutableState object with a mutable collection type"
        errorLine1="    var labels by remember { mutableStateOf(bookmark.labels.toMutableList()) }"
        errorLine2="                             ~~~~~~~~~~~~~~">
        <location
            file="src/main/java/com/mydeck/app/ui/detail/BookmarkDetailsDialog.kt"
            line="65"
            column="30"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;app_name&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;app_name&quot;>MyDeck&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="2"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;back&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;back&quot;>Back&lt;/string>"
        errorLine2="            ~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="3"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_topbar_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_topbar_title&quot;>Settings&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="4"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_account_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_account_title&quot;>Account&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="5"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_account_subtitle_default&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_account_subtitle_default&quot;>Not logged in&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="6"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;accountsettings_topbar_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;accountsettings_topbar_title&quot;>Account&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="7"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_topbar_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_topbar_title&quot;>Readeck URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="8"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_url_placeholder&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_url_placeholder&quot;>https://readeck.example.com/api&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="9"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_url_label&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_url_label&quot;>Readeck URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="10"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_username_placeholder&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_username_placeholder&quot;>email@example.com&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="11"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_username_label&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_username_label&quot;>Email Address&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="12"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_password_label&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_password_label&quot;>Password&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="13"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_password_placeholder&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_password_placeholder&quot;>password&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="14"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_login&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_login&quot;>Login&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="15"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_url_error&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_url_error&quot;>Invalid URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="16"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_username_error&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_username_error&quot;>Email address cannot be empty&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="17"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_password_error&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;account_settings_password_error&quot;>Password cannot be empty&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="18"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_allow_unencrypted&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish)"
        errorLine1="    &lt;string name=&quot;account_settings_allow_unencrypted&quot;>Allow unencrypted connections&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="19"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_sign_out_warning&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;account_settings_sign_out_warning&quot;>Signing out will clear all local data including saved bookmarks.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="20"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_sign_out&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;account_settings_sign_out&quot;>Sign Out&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="21"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_sign_out_confirm_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;account_settings_sign_out_confirm_title&quot;>Sign out?&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="22"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;account_settings_sign_out_confirm_message&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;account_settings_sign_out_confirm_message&quot;>This will clear all local data including saved bookmarks.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="23"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;sync_settings_topbar_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;sync_settings_topbar_title&quot;>Synchronization Settings&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="24"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;authors&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;authors&quot; translatable=&quot;true&quot;>"
        errorLine2="            ~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="25"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_open_source_libraries&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_open_source_libraries&quot;>Open Source Libraries&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="33"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_open_source_libraries_subtitle&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_open_source_libraries_subtitle&quot;>View the open source libraries used in this app.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="34"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;bookmarks&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;bookmarks&quot;>Bookmarks&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="35"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;menu&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;menu&quot;>Menu&lt;/string>"
        errorLine2="            ~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="36"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;refresh_bookmarks&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;refresh_bookmarks&quot;>Refresh Bookmarks&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="37"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;all&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;all&quot;>All&lt;/string>"
        errorLine2="            ~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="38"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;my_list&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;my_list&quot;>My List&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="39"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;archive&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;archive&quot;>Archive&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="40"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;favorites&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;favorites&quot;>Favorites&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="41"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;articles&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;articles&quot;>Articles&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="42"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;videos&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;videos&quot;>Videos&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="43"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;pictures&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;pictures&quot;>Pictures&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="44"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;labels&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;labels&quot;>Labels&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="45"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings&quot;>Settings&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="46"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;an_error_occurred&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;an_error_occurred&quot;>An error occurred.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="47"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;no_bookmarks_found&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;no_bookmarks_found&quot;>No bookmarks found.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="48"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;add_bookmark&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;add_bookmark&quot;>Add Bookmark&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="49"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;title&quot;>Title (Optional)&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="50"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;url&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;url&quot;>URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="51"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;invalid_url&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;invalid_url&quot;>Invalid URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="52"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;save&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;save&quot;>Save&lt;/string>"
        errorLine2="            ~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="53"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;cancel&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;cancel&quot;>Cancel&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="54"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;create_bookmark_error&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;create_bookmark_error&quot;>Error creating bookmark: %1$s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="55"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;add_new_bookmark&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;add_new_bookmark&quot;>Add New Bookmark&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="56"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;create&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;create&quot;>Create&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="57"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;error&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;error&quot;>Error&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="58"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;ok&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;ok&quot;>OK&lt;/string>"
        errorLine2="            ~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="59"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;not_valid_url&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;not_valid_url&quot;>Not a valid URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="60"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;log_view_title&quot;>Logs&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="61"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_send_logs&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;log_view_send_logs&quot;>Send Logs&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="62"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_logs&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_logs&quot;>Logs&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="63"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_logs_subtitle&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_logs_subtitle&quot;>View and Send Logfiles&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="64"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_share_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;log_view_share_title&quot;>Send Logs&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="65"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_no_log_file_found&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;log_view_no_log_file_found&quot;>No log file found&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="66"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_refresh&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;log_view_refresh&quot;>Refresh Logs&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="67"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_clear_logs&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;log_view_clear_logs&quot;>Clear Logs&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="68"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;log_view_logs_cleared&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;log_view_logs_cleared&quot;>Logs cleared&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="69"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync&quot;>Synchronization&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="70"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_subtitle&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync_subtitle&quot;>Synchronization Settings&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="71"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_ui&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_ui&quot;>User Interface&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="72"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_ui_subtitle&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_ui_subtitle&quot;>Appearance&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="73"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;ui_settings_topbar_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;ui_settings_topbar_title&quot;>User Interface Settings&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="74"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;ui_settings_theme_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;ui_settings_theme_title&quot;>Theme&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="75"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;theme_system&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;theme_system&quot;>System default&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="76"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;theme_light&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;theme_light&quot;>Light&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="77"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;theme_dark&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;theme_dark&quot;>Dark&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="78"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;theme_sepia&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;theme_sepia&quot;>Sepia&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="79"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;ui_settings_theme_heading&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;ui_settings_theme_heading&quot;>Theming&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="80"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;ui_settings_theme_dialog_support_text&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;ui_settings_theme_dialog_support_text&quot;>Which theme should be used?&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="81"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_favorite&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;action_favorite&quot;>Favorite&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="84"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_archive&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;action_archive&quot;>Archive&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="85"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_mark_read&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;action_mark_read&quot;>Read&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="86"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_mark_unread&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_mark_unread&quot;>Unread&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="87"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_share&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;action_share&quot;>Share link&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="88"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_delete&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;action_delete&quot;>Delete&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="89"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_open_in_browser&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;action_open_in_browser&quot;>Open in browser&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="90"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_view_original&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_view_original&quot;>View Original&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="91"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_view_article&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_view_article&quot;>View Article&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="92"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_view_photo&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_view_photo&quot;>View Photo&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="93"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_view_video&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_view_video&quot;>View Video&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="94"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_increase_text_size&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_increase_text_size&quot;>Increase text size&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="95"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;action_decrease_text_size&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;action_decrease_text_size&quot;>Decrease text size&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="96"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;error_no_article_content&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;error_no_article_content&quot;>Error, article content not available&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="97"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;update_successful&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;update_successful&quot;>Update successful&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="98"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;notification_channel_sync_name&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;notification_channel_sync_name&quot;>Synchronization Errors&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="99"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;notification_channel_sync_description&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;notification_channel_sync_description&quot;>Errors in synchronization&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="100"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;notification_authentication_error_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;notification_authentication_error_title&quot;>Authentication Required&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="101"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;notification_authentication_error_message&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;notification_authentication_error_message&quot;>Please validate your credentials.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="102"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_view_no_content&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;detail_view_no_content&quot;>No article content found&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="103"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;common_bookmark_image_content_description&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;common_bookmark_image_content_description&quot;>Bookmark Image&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="104"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_full_sync_heading&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync_full_sync_heading&quot;>Background Synchronization&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="105"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_auto_full_sync_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync_auto_full_sync_title&quot;>Background Synchronization&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="106"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_auto_full_button&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync_auto_full_button&quot;>Synchronize now&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="107"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_support_text&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync_support_text&quot;>To keep your bookmark list up-to-date, the app periodically syncs with the Readeck server to detect new, updated, and deleted bookmarks. Article content is downloaded in the background for offline reading.\n\nYou can manually sync on the list page to refresh from server, too, but would need to use \&apos;Synchronize now\&apos; button to sync deletes from the server.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="108"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_dialog_support_text&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;settings_sync_dialog_support_text&quot;>How often should the synchronization be performed in the background?&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="109"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_label&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_label&quot;>Schedule&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="110"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_manual&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_manual&quot;>Manual&lt;/string>>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="111"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_01_hours&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_01_hours&quot;>Every hour&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="112"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_06_hours&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_06_hours&quot;>Every 6 hours&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="113"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_12_hours&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_12_hours&quot;>Every 12 hours&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="114"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_07_days&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_07_days&quot;>Every 7 days&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="115"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_01_days&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_01_days&quot;>Once a day&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="116"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_14_days&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_14_days&quot;>Every 14 days&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="117"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_timeframe_30_days&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_timeframe_30_days&quot;>Every 30 days&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="118"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_next_run&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_next_run&quot;>Next synchronization on %1$s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="119"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_next_run_null&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_next_run_null&quot;>No synchronization scheduled&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="120"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_success&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_success&quot;>Synchronization successful&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="121"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_failure&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_failure&quot;>Synchronization failed&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="122"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_running&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_running&quot;>Background synchronization running.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="123"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_channel&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_channel&quot;>Background Synchronization&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="124"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_rationale_dialog_title&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_rationale_dialog_title&quot;>Notification Permission Required&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="125"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_rationale_dialog_text&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_rationale_dialog_text&quot;>To notify you about background sync failures, we need permission to send notifications.  Please grant this permission.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="126"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;auto_sync_notification_rationale_dialog_grant_button&quot; is not translated in &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish)"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_rationale_dialog_grant_button&quot;>Grant Permission&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="127"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_on_app_open_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;settings_sync_on_app_open_title&quot;>Sync on App Open&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="128"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_on_app_open_subtitle&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;settings_sync_on_app_open_subtitle&quot;>Automatically sync when the app is opened&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="129"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_notifications_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;settings_sync_notifications_title&quot;>Sync Notifications&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="130"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;settings_sync_notifications_subtitle&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;settings_sync_notifications_subtitle&quot;>Show notifications for background sync results&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="131"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;sync_status_heading&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;sync_status_heading&quot;>Sync Status&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="132"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;sync_status_bookmarks&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;sync_status_bookmarks&quot;>Bookmarks with content: %1$d / %2$d&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="133"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;sync_status_last_sync&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;sync_status_last_sync&quot;>Last sync: %1$s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="134"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;sync_status_never&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;sync_status_never&quot;>Last sync: Never&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="135"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;list_view_empty_not_loaded_yet&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;list_view_empty_not_loaded_yet&quot;>Bookmarks have not been loaded yet.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="136"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;list_view_empty_error_loading_bookmarks&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;list_view_empty_error_loading_bookmarks&quot;>An error has occurred while loading bookmarks.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="137"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;list_view_empty_nothing_to_see&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;list_view_empty_nothing_to_see&quot;>No bookmarks have been found.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="138"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_title&quot;>About&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="139"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_version&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_version&quot;>Version %s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="140"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_description&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_description&quot;>A read-later app for Readeck with a Pocket-like experience&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="141"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_credits_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_credits_title&quot;>Credits&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="142"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_credits_app_author&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_credits_app_author&quot;>MyDeck by Nate Eaton&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="143"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_credits_readeck&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_credits_readeck&quot;>Readeck server by Franois Revol and contributors&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="144"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_credits_fork&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_credits_fork&quot;>This is a fork of ReadeckApp by jensomato, reimagined with a Pocket-like user experience.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="145"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_system_info_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_system_info_title&quot;>System Info&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="146"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_system_info_version&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_system_info_version&quot;>Version %1$s (%2$d)&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="147"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_system_info_build_time&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_system_info_build_time&quot;>Built: %s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="148"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_system_info_android&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_system_info_android&quot;>Android %1$s (API %2$d)&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="149"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_system_info_device&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_system_info_device&quot;>Device: %1$s %2$s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="150"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_project_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_project_title&quot;>Project&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="151"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_project_this_repo&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_project_this_repo&quot;>MyDeck Repository (Fork)&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="152"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_project_original_repo&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_project_original_repo&quot;>Original ReadeckApp Repository&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="153"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_project_readeck_repo&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_project_readeck_repo&quot;>Readeck Server&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="154"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_license_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_license_title&quot;>License&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="155"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_license_text&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_license_text&quot;>MyDeck is licensed under the GNU General Public License v3 (GPLv3). Source code is available on GitHub.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="156"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;about_license_readeck&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;about_license_readeck&quot;>Readeck server is licensed under the AGPL-3.0 license.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="157"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_dialog_title&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_dialog_title&quot;>Bookmark Details&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="160"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_type&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_type&quot;>Type&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="161"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_language&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_language&quot;>Language&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="162"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_word_count&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_word_count&quot;>Word Count&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="163"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_reading_time&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_reading_time&quot;>Reading Time&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="164"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_minutes_short&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_minutes_short&quot;>min&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="165"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_labels&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_labels&quot;>Labels&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="166"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;detail_label_placeholder&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;detail_label_placeholder&quot;>Add labels (comma-separated)&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="167"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;bookmark_labels&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;bookmark_labels&quot;>Bookmark labels&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="170"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;select_label&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;select_label&quot;>Select Label&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="171"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;labels_description&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;labels_description&quot;>Select a label to view bookmarks&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="172"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;edit_label&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;edit_label&quot;>Edit label&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="173"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;delete_label&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;delete_label&quot;>Delete label&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="174"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;label_deleted&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;label_deleted&quot;>Label %s deleted&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="175"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;search_bookmarks&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;search_bookmarks&quot;>Search bookmarks&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="178"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;search&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;search&quot;>Search&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="179"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;close_search&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;close_search&quot;>Close search&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="180"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;clear_search&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;clear_search&quot;>Clear search&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="181"
            column="13"/>
    </issue>

    <issue
        id="MissingTranslation"
        message="&quot;search_no_results&quot; is not translated in &quot;de&quot; (German), &quot;ru&quot; (Russian), &quot;pt&quot; (Portuguese), &quot;gl&quot; (Galician), &quot;uk&quot; (Ukrainian), &quot;fr&quot; (French), &quot;pl&quot; (Polish), &quot;es&quot; (Spanish), &quot;zh&quot; (Chinese)"
        errorLine1="    &lt;string name=&quot;search_no_results&quot;>No results found&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="182"
            column="13"/>
    </issue>

    <issue
        id="ExtraTranslation"
        message="&quot;unread&quot; is translated here but not found in default locale"
        errorLine1="    &lt;string name=&quot;unread&quot;>Sen ler&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-gl-rES/strings.xml"
            line="33"
            column="13"/>
    </issue>

    <issue
        id="ExtraTranslation"
        message="&quot;unread&quot; is translated here but not found in default locale"
        errorLine1="    &lt;string name=&quot;unread&quot;>Sin leer&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-es-rES/strings.xml"
            line="34"
            column="13"/>
    </issue>

    <issue
        id="ExtraTranslation"
        message="&quot;unread&quot; is translated here but not found in default locale"
        errorLine1="    &lt;string name=&quot;unread&quot;>&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-zh-rCN/strings.xml"
            line="35"
            column="13"/>
    </issue>

    <issue
        id="ExtraTranslation"
        message="&quot;unread&quot; is translated here but not found in default locale"
        errorLine1="    &lt;string name=&quot;unread&quot;>Ungelesen&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-de-rDE/strings.xml"
            line="36"
            column="13"/>
    </issue>

    <issue
        id="StringFormatCount"
        message="Inconsistent number of arguments in formatting string `auto_sync_notification_success`; found both 1 here and 0 in values/strings.xml"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_success&quot;>Synchronisierung im Hintergrund erfolgreich. %1$d Lesezeichen gelscht.&lt;/string>"
        errorLine2="    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-de-rDE/strings.xml"
            line="96"
            column="5"/>
        <location
            file="src/main/res/values/strings.xml"
            line="121"
            column="5"
            message="Conflicting number of arguments (0) here"/>
    </issue>

    <issue
        id="StringFormatCount"
        message="Inconsistent number of arguments in formatting string `auto_sync_notification_success`; found both 1 here and 0 in values/strings.xml"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_success&quot;> %1$d &lt;/string>"
        errorLine2="    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-zh-rCN/strings.xml"
            line="99"
            column="5"/>
        <location
            file="src/main/res/values/strings.xml"
            line="121"
            column="5"
            message="Conflicting number of arguments (0) here"/>
    </issue>

    <issue
        id="StringFormatCount"
        message="Inconsistent number of arguments in formatting string `auto_sync_notification_success`; found both 1 here and 0 in values/strings.xml"
        errorLine1="    &lt;string name=&quot;auto_sync_notification_success&quot;>La sincronizacin en segundo plano fue correcta. Se borraron %1$d marcadores.&lt;/string>"
        errorLine2="    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-es-rES/strings.xml"
            line="106"
            column="5"/>
        <location
            file="src/main/res/values/strings.xml"
            line="121"
            column="5"
            message="Conflicting number of arguments (0) here"/>
    </issue>

    <issue
        id="SetJavaScriptEnabled"
        message="Using `setJavaScriptEnabled` can introduce XSS vulnerabilities into your application, review carefully"
        errorLine1="                        settings.javaScriptEnabled = true"
        errorLine2="                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/java/com/mydeck/app/ui/detail/BookmarkDetailScreen.kt"
            line="487"
            column="25"/>
    </issue>

    <issue
        id="AcceptsUserCertificates"
        message="The Network Security Configuration allows the use of user certificates in the release version of your app"
        errorLine1="            &lt;certificates src=&quot;user&quot; />"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/xml/network_security_config.xml"
            line="6"
            column="13"/>
    </issue>

    <issue
        id="InsecureBaseConfiguration"
        message="Insecure Base Configuration"
        errorLine1="    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;>"
        errorLine2="                                            ~~~~">
        <location
            file="src/main/res/xml/network_security_config.xml"
            line="3"
            column="45"/>
    </issue>

    <issue
        id="AutoboxingStateCreation"
        message="Prefer `mutableIntStateOf` instead of `mutableStateOf`"
        errorLine1="    var lastReportedProgress by remember { mutableStateOf(-1) }"
        errorLine2="                                           ~~~~~~~~~~~~~~">
        <location
            file="src/main/java/com/mydeck/app/ui/detail/BookmarkDetailScreen.kt"
            line="313"
            column="44"/>
    </issue>

    <issue
        id="AutoboxingStateCreation"
        message="Prefer `mutableIntStateOf` instead of `mutableStateOf`"
        errorLine1="    var loadingProgress by remember { mutableStateOf(0) }"
        errorLine2="                                      ~~~~~~~~~~~~~~">
        <location
            file="src/main/java/com/mydeck/app/ui/detail/BookmarkDetailScreen.kt"
            line="467"
            column="39"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.raw.aboutlibraries` appears to be unused">
        <location
            file="src/main/res/raw/aboutlibraries.json"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.purple_200` appears to be unused"
        errorLine1="    &lt;color name=&quot;purple_200&quot;>#FFBB86FC&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="3"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.purple_500` appears to be unused"
        errorLine1="    &lt;color name=&quot;purple_500&quot;>#FF6200EE&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="4"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.purple_700` appears to be unused"
        errorLine1="    &lt;color name=&quot;purple_700&quot;>#FF3700B3&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="5"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.teal_200` appears to be unused"
        errorLine1="    &lt;color name=&quot;teal_200&quot;>#FF03DAC5&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="6"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.teal_700` appears to be unused"
        errorLine1="    &lt;color name=&quot;teal_700&quot;>#FF018786&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="7"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.black` appears to be unused"
        errorLine1="    &lt;color name=&quot;black&quot;>#FF000000&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="8"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.white` appears to be unused"
        errorLine1="    &lt;color name=&quot;white&quot;>#FFFFFFFF&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~">
        <location
            file="src/main/res/values/colors.xml"
            line="9"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.dimen.activity_horizontal_margin` appears to be unused"
        errorLine1="    &lt;dimen name=&quot;activity_horizontal_margin&quot;>16dp&lt;/dimen>"
        errorLine2="           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/dimens.xml"
            line="3"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.dimen.activity_vertical_margin` appears to be unused"
        errorLine1="    &lt;dimen name=&quot;activity_vertical_margin&quot;>16dp&lt;/dimen>"
        errorLine2="           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/dimens.xml"
            line="4"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.drawable.ic_dashboard_black_24dp` appears to be unused"
        errorLine1="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;"
        errorLine2="^">
        <location
            file="src/main/res/drawable/ic_dashboard_black_24dp.xml"
            line="1"
            column="1"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.drawable.ic_home_black_24dp` appears to be unused"
        errorLine1="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;"
        errorLine2="^">
        <location
            file="src/main/res/drawable/ic_home_black_24dp.xml"
            line="1"
            column="1"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.drawable.ic_launcher_background` appears to be unused"
        errorLine1="&lt;vector"
        errorLine2="^">
        <location
            file="src/main/res/drawable/ic_launcher_background.xml"
            line="2"
            column="1"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.color.ic_launcher_background` appears to be unused"
        errorLine1="    &lt;color name=&quot;ic_launcher_background&quot;>#064C5C&lt;/color>"
        errorLine2="           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/ic_launcher_background.xml"
            line="3"
            column="12"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.drawable.ic_launcher_foreground` appears to be unused"
        errorLine1="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;"
        errorLine2="^">
        <location
            file="src/main/res/drawable/ic_launcher_foreground.xml"
            line="1"
            column="1"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.drawable.ic_notifications_black_24dp` appears to be unused"
        errorLine1="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;"
        errorLine2="^">
        <location
            file="src/main/res/drawable/ic_notifications_black_24dp.xml"
            line="1"
            column="1"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.account_settings_topbar_title` appears to be unused"
        errorLine1="    &lt;string name=&quot;account_settings_topbar_title&quot;>Readeck URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="8"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.bookmarks` appears to be unused"
        errorLine1="    &lt;string name=&quot;bookmarks&quot;>Bookmarks&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="35"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.unread` appears to be unused"
        errorLine1="    &lt;string name=&quot;unread&quot;>Ungelesen&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values-de-rDE/strings.xml"
            line="36"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.refresh_bookmarks` appears to be unused"
        errorLine1="    &lt;string name=&quot;refresh_bookmarks&quot;>Refresh Bookmarks&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="37"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.all` appears to be unused"
        errorLine1="    &lt;string name=&quot;all&quot;>All&lt;/string>"
        errorLine2="            ~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="38"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.articles` appears to be unused"
        errorLine1="    &lt;string name=&quot;articles&quot;>Articles&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="42"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.videos` appears to be unused"
        errorLine1="    &lt;string name=&quot;videos&quot;>Videos&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="43"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.pictures` appears to be unused"
        errorLine1="    &lt;string name=&quot;pictures&quot;>Pictures&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="44"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.an_error_occurred` appears to be unused"
        errorLine1="    &lt;string name=&quot;an_error_occurred&quot;>An error occurred.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="47"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.no_bookmarks_found` appears to be unused"
        errorLine1="    &lt;string name=&quot;no_bookmarks_found&quot;>No bookmarks found.&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="48"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.invalid_url` appears to be unused"
        errorLine1="    &lt;string name=&quot;invalid_url&quot;>Invalid URL&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="52"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.save` appears to be unused"
        errorLine1="    &lt;string name=&quot;save&quot;>Save&lt;/string>"
        errorLine2="            ~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="53"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.create_bookmark_error` appears to be unused"
        errorLine1="    &lt;string name=&quot;create_bookmark_error&quot;>Error creating bookmark: %1$s&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="55"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.ui_settings_theme_heading` appears to be unused"
        errorLine1="    &lt;string name=&quot;ui_settings_theme_heading&quot;>Theming&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="80"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.action_mark_unread` appears to be unused"
        errorLine1="    &lt;string name=&quot;action_mark_unread&quot;>Unread&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="87"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.action_open_in_browser` appears to be unused"
        errorLine1="    &lt;string name=&quot;action_open_in_browser&quot;>Open in browser&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="90"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.update_successful` appears to be unused"
        errorLine1="    &lt;string name=&quot;update_successful&quot;>Update successful&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="98"
            column="13"/>
    </issue>

    <issue
        id="UnusedResources"
        message="The resource `R.string.bookmark_labels` appears to be unused"
        errorLine1="    &lt;string name=&quot;bookmark_labels&quot;>Bookmark labels&lt;/string>"
        errorLine2="            ~~~~~~~~~~~~~~~~~~~~~~">
        <location
            file="src/main/res/values/strings.xml"
            line="170"
            column="13"/>
    </issue>

    <issue
        id="IconXmlAndPng"
        message="The following images appear both as density independent `.xml` files and as bitmap files: src/main/res/drawable/ic_launcher_background.xml, src/main/res/mipmap-hdpi/ic_launcher_background.png">
        <location
            file="src/main/res/mipmap-xxxhdpi/ic_launcher_background.png"/>
        <location
            file="src/main/res/mipmap-xxhdpi/ic_launcher_background.png"/>
        <location
            file="src/main/res/mipmap-xhdpi/ic_launcher_background.png"/>
        <location
            file="src/main/res/mipmap-mdpi/ic_launcher_background.png"/>
        <location
            file="src/main/res/mipmap-hdpi/ic_launcher_background.png"/>
        <location
            file="src/main/res/drawable/ic_launcher_background.xml"/>
    </issue>

    <issue
        id="IconXmlAndPng"
        message="The following images appear both as density independent `.xml` files and as bitmap files: src/main/res/drawable/ic_launcher_foreground.xml, src/main/res/mipmap-hdpi/ic_launcher_foreground.png">
        <location
            file="src/main/res/mipmap-xxxhdpi/ic_launcher_foreground.png"/>
        <location
            file="src/main/res/mipmap-xxhdpi/ic_launcher_foreground.png"/>
        <location
            file="src/main/res/mipmap-xhdpi/ic_launcher_foreground.png"/>
        <location
            file="src/main/res/mipmap-mdpi/ic_launcher_foreground.png"/>
        <location
            file="src/main/res/mipmap-hdpi/ic_launcher_foreground.png"/>
        <location
            file="src/main/res/drawable/ic_launcher_foreground.xml"/>
    </issue>

    <issue
        id="IconXmlAndPng"
        message="The following images appear both as density independent `.xml` files and as bitmap files: src/main/res/drawable-anydpi/ic_notification_logo.xml, src/main/res/drawable-hdpi/ic_notification_logo.png">
        <location
            file="src/main/res/drawable-xxhdpi/ic_notification_logo.png"/>
        <location
            file="src/main/res/drawable-xhdpi/ic_notification_logo.png"/>
        <location
            file="src/main/res/drawable-mdpi/ic_notification_logo.png"/>
        <location
            file="src/main/res/drawable-hdpi/ic_notification_logo.png"/>
        <location
            file="src/main/res/drawable-anydpi/ic_notification_logo.xml"/>
    </issue>

    <issue
        id="IconDuplicates"
        message="The following unrelated icon files have identical contents: ic_launcher_foreground.png, ic_launcher_monochrome.png">
        <location
            file="src/main/res/mipmap-hdpi/ic_launcher_monochrome.png"/>
        <location
            file="src/main/res/mipmap-hdpi/ic_launcher_foreground.png"/>
    </issue>

    <issue
        id="IconDuplicates"
        message="The following unrelated icon files have identical contents: ic_launcher_foreground.png, ic_launcher_monochrome.png">
        <location
            file="src/main/res/mipmap-mdpi/ic_launcher_monochrome.png"/>
        <location
            file="src/main/res/mipmap-mdpi/ic_launcher_foreground.png"/>
    </issue>

    <issue
        id="IconDuplicates"
        message="The following unrelated icon files have identical contents: ic_launcher_foreground.png, ic_launcher_monochrome.png">
        <location
            file="src/main/res/mipmap-xhdpi/ic_launcher_monochrome.png"/>
        <location
            file="src/main/res/mipmap-xhdpi/ic_launcher_foreground.png"/>
    </issue>

    <issue
        id="IconDuplicates"
        message="The following unrelated icon files have identical contents: ic_launcher_foreground.png, ic_launcher_monochrome.png">
        <location
            file="src/main/res/mipmap-xxhdpi/ic_launcher_monochrome.png"/>
        <location
            file="src/main/res/mipmap-xxhdpi/ic_launcher_foreground.png"/>
    </issue>

    <issue
        id="IconDuplicates"
        message="The following unrelated icon files have identical contents: ic_launcher_foreground.png, ic_launcher_monochrome.png">
        <location
            file="src/main/res/mipmap-xxxhdpi/ic_launcher_monochrome.png"/>
        <location
            file="src/main/res/mipmap-xxxhdpi/ic_launcher_foreground.png"/>
    </issue>

</issues>
</file>

<file path="app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

# Keep all network DTOs to prevent R8/ProGuard from stripping them
-keep class com.mydeck.app.io.rest.model.** { *; }

# Helpful for Retrofit / JSON reflection frameworks
-keepattributes *Annotation*
-keepattributes Signature
</file>

<file path=".gitignore">
.vscode/
.*.iml
.gradle
/local.properties
/.idea/
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
local.properties
/.aider*
/.cache
/.kotlin/
.attach_pid*
app/backup-icons/
.vscode/
</file>

<file path="README.md">
# MyDeck

[![License](https://img.shields.io/badge/License-GPLv3-blue.svg)](LICENSE)

## Overview

MyDeck is an Android application for managing and reading your saved articles and bookmarks with a Pocket-like user experience. It is forked from [ReadeckApp](https://github.com/jensomato/ReadeckApp) and is currently being refactored to provide a more streamlined and intuitive interface.

This app is a companion to [Readeck](https://readeck.org/en/), a self-hosted read-it-later service. To use this app, you'll need a Readeck account and server instance.

## Acknowledgements

MyDeck is based on [ReadeckApp](https://github.com/jensomato/ReadeckApp) by jensomato, which is licensed under the GNU General Public License v3.0.

### Major Changes

As required by the GNU GPL v3, here are the major modifications made to the original ReadeckApp:

**UI & Navigation:**
* Rebranding as MyDeck
* Pocket-like sidebar navigation: My List, Archive, Favorites views (replacing All/Unread)
* Revise header to show view name
* Add About menu option / dialog
* Add dedicated Labels view to browse and filter by labels
* Multiple bookmark list layouts: Grid, Compact, and Mosaic views
* List sorting functionality
* Shift reading view menu options from FAB to header

**Bookmark Management:**
* Full label management system: add, edit, and remove labels on individual bookmarks
* Inline action icons on bookmark cards (replacing 3-dot overflow menu)
* Reading time displayed on bookmark cards
* Bookmark details dialog showing metadata (type, language, word count, reading time, authors, description)
* Interactive labels section in details dialog with add/remove capabilities
* Label filtering: click any label to filter bookmarks by that label
* Clickable label chips on bookmark cards for quick filtering
* Auto-populate URL field when adding bookmarks using clipboard contents
* Account page automatically displays if not signed in

**Content & Reading:**
* Full support for Article, Photo, and Video bookmark types
* Dual content view modes: Article (Readeck-extracted content) and Original (embedded web view)
* Content view toggle in reading view header
* Embedded content support for photos and videos via iframe embeds
* Improved reading view for photo and video content with fallback descriptions

**Search & Discovery:**
* Global full-text search across bookmark titles, site names, and labels
* Search clears automatically when returning to list view

**Planned Features (In Development):**
* Revised sync model: decoupled bookmark metadata sync from content sync with configurable content policies (Automatic, Manual, Date Range)
* Enhanced sync status reporting and offline indicators
* Wi-Fi-only and battery-saver aware content downloads

## License

This project is licensed under the [GNU General Public License v3.0](LICENSE). Some of the used libraries are released under different licenses.
</file>

<file path="app/src/main/java/com/mydeck/app/domain/mapper/BookmarkMapper.kt">
package com.mydeck.app.domain.mapper

import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.io.db.model.ArticleContentEntity
import com.mydeck.app.io.db.model.BookmarkEntity
import com.mydeck.app.io.db.model.BookmarkWithArticleContent
import com.mydeck.app.io.db.model.ImageResourceEntity
import com.mydeck.app.io.db.model.ResourceEntity
import com.mydeck.app.io.rest.model.BookmarkDto as BookmarkDto
import com.mydeck.app.io.rest.model.Resource as ResourceDto
import com.mydeck.app.io.rest.model.ImageResource as ImageResourceDto
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import kotlinx.datetime.toInstant

fun Bookmark.toEntity(): BookmarkWithArticleContent = BookmarkWithArticleContent(
    bookmark = BookmarkEntity(
        id = id,
        href = href,
        created = created.toInstant(TimeZone.currentSystemDefault()),
        updated = updated.toInstant(TimeZone.currentSystemDefault()),
        state = when (state) {
            Bookmark.State.LOADED -> BookmarkEntity.State.LOADED
            Bookmark.State.ERROR -> BookmarkEntity.State.ERROR
            Bookmark.State.LOADING -> BookmarkEntity.State.LOADING
        },
        loaded = loaded,
        url = url,
        title = title,
        siteName = siteName,
        site = site,
        authors = authors,
        lang = lang,
        textDirection = textDirection,
        documentTpe = documentTpe,
        type = when (type) {
            Bookmark.Type.Article -> BookmarkEntity.Type.ARTICLE
            Bookmark.Type.Picture -> BookmarkEntity.Type.PHOTO
            Bookmark.Type.Video -> BookmarkEntity.Type.VIDEO
        },
        hasArticle = hasArticle,
        description = description,
        isDeleted = isDeleted,
        isMarked = isMarked,
        isArchived = isArchived,
        labels = labels,
        readProgress = readProgress,
        wordCount = wordCount,
        readingTime = readingTime,
        published = published?.toInstant(TimeZone.currentSystemDefault()),
        embed = embed,
        embedHostname = embedHostname,
        article = article.toEntity(),
        icon = icon.toEntity(),
        image = image.toEntity(),
        log = log.toEntity(),
        props = props.toEntity(),
        thumbnail = thumbnail.toEntity(),
        contentState = when (contentState) {
            Bookmark.ContentState.NOT_ATTEMPTED -> BookmarkEntity.ContentState.NOT_ATTEMPTED
            Bookmark.ContentState.DOWNLOADED -> BookmarkEntity.ContentState.DOWNLOADED
            Bookmark.ContentState.DIRTY -> BookmarkEntity.ContentState.DIRTY
            Bookmark.ContentState.PERMANENT_NO_CONTENT -> BookmarkEntity.ContentState.PERMANENT_NO_CONTENT
        },
        contentFailureReason = contentFailureReason
    ),
    articleContent = articleContent?.let { ArticleContentEntity(bookmarkId = id, content = it) }
)

fun Bookmark.Resource.toEntity(): ResourceEntity = ResourceEntity(
    src = this.src
)

fun Bookmark.ImageResource.toEntity(): ImageResourceEntity = ImageResourceEntity(
    src = this.src,
    width = this.width,
    height = this.height
)

fun BookmarkEntity.toDomain(): Bookmark = Bookmark(
    id = id,
    href = href,
    created = created.toLocalDateTime(TimeZone.currentSystemDefault()),
    updated = updated.toLocalDateTime(TimeZone.currentSystemDefault()),
    state = when (state) {
        BookmarkEntity.State.LOADED -> Bookmark.State.LOADED
        BookmarkEntity.State.ERROR -> Bookmark.State.ERROR
        BookmarkEntity.State.LOADING -> Bookmark.State.LOADING
    },
    loaded = loaded,
    url = url,
    title = title,
    siteName = siteName,
    site = site,
    authors = authors,
    lang = lang,
    textDirection = textDirection,
    documentTpe = documentTpe,
    type = when (type) {
        BookmarkEntity.Type.ARTICLE -> Bookmark.Type.Article
        BookmarkEntity.Type.PHOTO -> Bookmark.Type.Picture
        BookmarkEntity.Type.VIDEO -> Bookmark.Type.Video
    },
    hasArticle = hasArticle,
    description = description,
    isDeleted = isDeleted,
    isMarked = isMarked,
    isArchived = isArchived,
    labels = labels,
    readProgress = readProgress,
    wordCount = wordCount,
    readingTime = readingTime,
    published = published?.toLocalDateTime(TimeZone.currentSystemDefault()),
    embed = embed,
    embedHostname = embedHostname,
    article = article.toDomain(),
    icon = icon.toDomain(),
    image = image.toDomain(),
    log = log.toDomain(),
    props = props.toDomain(),
    thumbnail = thumbnail.toDomain(),
    articleContent = null, // Article content will be fetched separately
    contentState = when (contentState) {
        BookmarkEntity.ContentState.NOT_ATTEMPTED -> Bookmark.ContentState.NOT_ATTEMPTED
        BookmarkEntity.ContentState.DOWNLOADED -> Bookmark.ContentState.DOWNLOADED
        BookmarkEntity.ContentState.DIRTY -> Bookmark.ContentState.DIRTY
        BookmarkEntity.ContentState.PERMANENT_NO_CONTENT -> Bookmark.ContentState.PERMANENT_NO_CONTENT
    },
    contentFailureReason = contentFailureReason
)

fun ResourceEntity.toDomain(): Bookmark.Resource = Bookmark.Resource(
    src = this.src
)

fun ImageResourceEntity.toDomain(): Bookmark.ImageResource = Bookmark.ImageResource(
    src = this.src,
    width = this.width,
    height = this.height
)

fun BookmarkDto.toDomain(): Bookmark = Bookmark(
    id = id,
    href = href,
    created = created.toLocalDateTime(TimeZone.currentSystemDefault()),
    updated = updated.toLocalDateTime(TimeZone.currentSystemDefault()),
    state = when (state) {
        0 -> Bookmark.State.LOADED
        1 -> Bookmark.State.ERROR
        2 -> Bookmark.State.LOADING
        else -> Bookmark.State.ERROR
    },
    loaded = loaded,
    url = url,
    title = title,
    siteName = siteName,
    site = site,
    authors = authors ?: emptyList(),
    lang = lang,
    textDirection = textDirection,
    documentTpe = documentTpe,
    type = when (type.lowercase()) {
        "article" -> Bookmark.Type.Article
        "photo" -> Bookmark.Type.Picture
        "video" -> Bookmark.Type.Video
        else -> Bookmark.Type.Article
    },
    hasArticle = hasArticle,
    description = description,
    isDeleted = isDeleted,
    isMarked = isMarked,
    isArchived = isArchived,
    labels = labels,
    readProgress = readProgress ?: 0,
    wordCount = wordCount,
    readingTime = readingTime,
    published = published?.toLocalDateTime(TimeZone.currentSystemDefault()),
    embed = embed,
    embedHostname = embedHostname,
    article = resources.article.toDomain(),
    icon = resources.icon.toDomain(),
    image = resources.image.toDomain(),
    log = resources.log.toDomain(),
    props = resources.props.toDomain(),
    thumbnail = resources.thumbnail.toDomain(),
    articleContent = null,
    contentState = Bookmark.ContentState.NOT_ATTEMPTED,
    contentFailureReason = null
)

fun ResourceDto?.toDomain(): Bookmark.Resource = Bookmark.Resource(
    src = this?.src ?: ""
)

fun ImageResourceDto?.toDomain(): Bookmark.ImageResource = Bookmark.ImageResource(
    src = this?.src ?: "",
    width = this?.width ?: 0,
    height = this?.height ?: 0
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/Bookmark.kt">
package com.mydeck.app.domain.model

import kotlinx.datetime.LocalDateTime

data class Bookmark(
    val id: String,
    val href: String,
    val created: LocalDateTime,
    val updated: LocalDateTime,
    val state: State,
    val loaded: Boolean,
    val url: String,
    val title: String,
    val siteName: String,
    val site: String,
    val authors: List<String>,
    val lang: String,
    val textDirection: String,
    val documentTpe: String,
    val type: Type,
    val hasArticle: Boolean,
    val description: String,
    val isDeleted: Boolean,
    val isMarked: Boolean,
    val isArchived: Boolean,
    val labels: List<String>,
    val readProgress: Int,
    val wordCount: Int?,
    val readingTime: Int?,
    val published: LocalDateTime?,
    val embed: String?,
    val embedHostname: String?,
    val article: Resource,
    val articleContent: String?,
    val icon: ImageResource,
    val image: ImageResource,
    val log: Resource,
    val props: Resource,
    val thumbnail: ImageResource,
    val contentState: ContentState = ContentState.NOT_ATTEMPTED,
    val contentFailureReason: String? = null
) {
    fun isRead(): Boolean {
        return readProgress == 100
    }
    data class Resource(
        val src: String
    )
    data class ImageResource(
        val src: String,
        val width: Int,
        val height: Int
    )
    sealed class Type {
        data object Article: Type()
        data object Picture: Type()
        data object Video: Type()
    }
    enum class State {
        LOADED,
        ERROR,
        LOADING
    }
    enum class ContentState {
        NOT_ATTEMPTED,
        DOWNLOADED,
        DIRTY,
        PERMANENT_NO_CONTENT
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/BookmarkListItem.kt">
package com.mydeck.app.domain.model

import kotlinx.datetime.LocalDateTime

data class BookmarkListItem(
    val id: String,
    val url: String,
    val title: String,
    val siteName: String,
    val isMarked: Boolean,
    val isArchived: Boolean,
    val isRead: Boolean,
    val readProgress: Int,
    val thumbnailSrc: String,
    val iconSrc: String,
    val imageSrc: String,
    val labels: List<String>,
    val type: Bookmark.Type,
    val readingTime: Int?,
    val created: LocalDateTime,
    val wordCount: Int?,
    val published: LocalDateTime?
)
</file>

<file path="app/src/main/java/com/mydeck/app/domain/model/SortOption.kt">
package com.mydeck.app.domain.model

enum class SortOption(val sqlOrderBy: String, val displayName: String) {
    ADDED_NEWEST("created DESC", "Added, newest first"),
    ADDED_OLDEST("created ASC", "Added, oldest first"),
    PUBLISHED_NEWEST("published DESC", "Published, newest first"),
    PUBLISHED_OLDEST("published ASC", "Published, oldest first"),
    TITLE_A_TO_Z("title COLLATE NOCASE ASC", "Title, A to Z"),
    TITLE_Z_TO_A("title COLLATE NOCASE DESC", "Title, Z to A"),
    SITE_A_TO_Z("siteName COLLATE NOCASE ASC", "Site Name, A to Z"),
    SITE_Z_TO_A("siteName COLLATE NOCASE DESC", "Site Name, Z to A"),
    DURATION_SHORTEST("readingTime ASC", "Duration, shortest first"),
    DURATION_LONGEST("readingTime DESC", "Duration, longest first")
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/usecase/LoadBookmarksUseCase.kt">
package com.mydeck.app.domain.usecase

import androidx.work.Constraints
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.mapper.toDomain
import com.mydeck.app.domain.sync.ContentSyncPolicyEvaluator
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.io.rest.ReadeckApi
import com.mydeck.app.io.rest.model.BookmarkDto
import com.mydeck.app.worker.BatchArticleLoadWorker
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toInstant
import timber.log.Timber
import javax.inject.Inject

class LoadBookmarksUseCase @Inject constructor(
    private val bookmarkRepository: BookmarkRepository,
    private val readeckApi: ReadeckApi,
    private val settingsDataStore: SettingsDataStore,
    private val policyEvaluator: ContentSyncPolicyEvaluator,
    private val workManager: WorkManager
) {

    sealed class UseCaseResult<out DataType : Any> {
        data class Success<out DataType : Any>(val  dataType: DataType) : UseCaseResult<DataType>()
        data class Error(val exception: Throwable) : UseCaseResult<Nothing>()
    }

    suspend fun execute(pageSize: Int = DEFAULT_PAGE_SIZE, initialOffset: Int = 0): UseCaseResult<Unit> {
        Timber.d("execute(pageSize=$pageSize, initialOffset=$initialOffset")

        var offset = initialOffset
        try {
            val lastLoadedTimestamp = settingsDataStore.getLastBookmarkTimestamp()
            Timber.i("Loaded last bookmark timestamp: [utc=$lastLoadedTimestamp]")

            var hasMorePages = true
            while (hasMorePages) {
                val response = readeckApi.getBookmarks(pageSize, offset, lastLoadedTimestamp, ReadeckApi.SortOrder(ReadeckApi.Sort.Created))
                if (response.isSuccessful && response.body() != null) {
                    val bookmarks = (response.body() as List<BookmarkDto>).map { it.toDomain() }

                    val totalCountHeader = response.headers()[ReadeckApi.Header.TOTAL_COUNT]
                    val totalPagesHeader = response.headers()[ReadeckApi.Header.TOTAL_PAGES]
                    val currentPageHeader = response.headers()[ReadeckApi.Header.CURRENT_PAGE]

                    if (totalCountHeader == null || totalPagesHeader == null || currentPageHeader == null) {
                        return UseCaseResult.Error(Exception("Missing headers in API response"))
                    }

                    val totalCount = totalCountHeader.toInt()
                    val totalPages = totalPagesHeader.toInt()
                    val currentPage = currentPageHeader.toInt()

                    Timber.d("currentPage=$currentPage")
                    Timber.d("totalPages=$totalPages")
                    Timber.d("totalCount=$totalCount")

                    bookmarkRepository.insertBookmarks(bookmarks)

                    // Find the latest created timestamp in the current page
                    val latestBookmark = bookmarks.maxByOrNull { it.created }
                    latestBookmark?.let {
                        val timestamp = it.created.toInstant(TimeZone.currentSystemDefault())
                        settingsDataStore.saveLastBookmarkTimestamp(timestamp)
                        Timber.i("Saved last bookmark timestamp: [local=${it.created}, utc=$timestamp]")
                    }

                    if (currentPage < totalPages) {
                        offset += pageSize
                    } else {
                        hasMorePages = false
                    }
                } else {
                    Timber.w("Error loading bookmarks: [code=${response.code()}, body=${response.body()}]")
                    return UseCaseResult.Error(Exception("Unsuccessful response: ${response.code()}"))
                }
            }

            // After metadata sync completes, conditionally enqueue content sync
            if (policyEvaluator.shouldAutoFetchContent()) {
                enqueueBatchArticleLoader()
            }

            return UseCaseResult.Success(Unit)
        } catch (e: Exception) {
            Timber.e(e, "Error loading bookmarks")
            return UseCaseResult.Error(e)
        }
    }

    private fun enqueueBatchArticleLoader() {
        try {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()

            val request = OneTimeWorkRequestBuilder<BatchArticleLoadWorker>()
                .setConstraints(constraints)
                .build()

            workManager.enqueueUniqueWork(
                BatchArticleLoadWorker.UNIQUE_WORK_NAME,
                ExistingWorkPolicy.KEEP,
                request
            )
            Timber.d("Batch article loader enqueued (policy: AUTOMATIC)")
        } catch (e: Exception) {
            Timber.w(e, "Failed to enqueue batch article loader")
        }
    }

    companion object {
        const val DEFAULT_PAGE_SIZE = 50
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/model/BookmarkEntity.kt">
package com.mydeck.app.io.db.model

import androidx.room.Embedded
import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey
import kotlinx.datetime.Instant

@Entity(
    tableName = "bookmarks",
    indices = [
        Index(value = ["readProgress"]),
        Index(value = ["type"]),
        Index(value = ["isArchived"]),
        Index(value = ["isMarked"])
    ]
)
data class BookmarkEntity(
    @PrimaryKey
    val id: String,
    val href: String,
    val created: Instant,
    val updated: Instant,
    val state: State,
    val loaded: Boolean,
    val url: String,
    val title: String,
    val siteName: String,
    val site: String,
    val authors: List<String>,
    val lang: String,
    val textDirection: String,
    val documentTpe: String,
    val type: Type,
    val hasArticle: Boolean,
    val description: String,
    val isDeleted: Boolean,
    val isMarked: Boolean,
    val isArchived: Boolean,
    val labels: List<String>,
    val readProgress: Int,
    val wordCount: Int?,
    val readingTime: Int?,
    val published: Instant?,
    val embed: String?,
    val embedHostname: String?,

    // Embedded Resources
    @Embedded(prefix = "article_")
    val article: ResourceEntity,
    @Embedded(prefix = "icon_")
    val icon: ImageResourceEntity,
    @Embedded(prefix = "image_")
    val image: ImageResourceEntity,
    @Embedded(prefix = "log_")
    val log: ResourceEntity,
    @Embedded(prefix = "props_")
    val props: ResourceEntity,
    @Embedded(prefix = "thumbnail_")
    val thumbnail: ImageResourceEntity,

    val contentState: ContentState = ContentState.NOT_ATTEMPTED,
    val contentFailureReason: String? = null
) {
    enum class Type(val value: String) {
        ARTICLE("article"),
        VIDEO("video"),
        PHOTO("photo")
    }
    enum class State(val value: Int) {
        LOADED(0),
        ERROR(1),
        LOADING(2)
    }
    enum class ContentState(val value: Int) {
        NOT_ATTEMPTED(0),
        DOWNLOADED(1),
        DIRTY(2),
        PERMANENT_NO_CONTENT(3)
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/worker/BatchArticleLoadWorker.kt">
package com.mydeck.app.worker

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.Constraints
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import com.mydeck.app.domain.sync.ContentSyncPolicyEvaluator
import com.mydeck.app.domain.usecase.LoadArticleUseCase
import com.mydeck.app.io.db.dao.BookmarkDao
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import timber.log.Timber

@HiltWorker
class BatchArticleLoadWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val bookmarkDao: BookmarkDao,
    private val loadArticleUseCase: LoadArticleUseCase,
    private val policyEvaluator: ContentSyncPolicyEvaluator
) : CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        Timber.d("BatchArticleLoadWorker starting")

        try {
            val pendingBookmarkIds = bookmarkDao.getBookmarkIdsEligibleForContentFetch()
            Timber.i("Found ${pendingBookmarkIds.size} bookmarks without content")

            if (pendingBookmarkIds.isEmpty()) {
                return Result.success()
            }

            val batches = pendingBookmarkIds.chunked(BATCH_SIZE)
            batches.forEachIndexed { index, batch ->
                // Check constraints before each batch
                if (!policyEvaluator.canFetchContent().allowed) {
                    Timber.i("Content fetch blocked by constraints, stopping batch")
                    return Result.success()
                }

                Timber.d("Processing batch ${index + 1}, size=${batch.size}")

                coroutineScope {
                    batch.map { id ->
                        async {
                            try {
                                loadArticleUseCase.execute(id)
                            } catch (e: Exception) {
                                Timber.w(e, "Failed to load article $id")
                            }
                        }
                    }.awaitAll()
                }

                // Brief pause between batches to reduce resource contention
                if (index < batches.size - 1) {
                    delay(BATCH_DELAY_MS)
                }
            }

            Timber.i("BatchArticleLoadWorker completed successfully")
            return Result.success()
        } catch (e: Exception) {
            Timber.e(e, "BatchArticleLoadWorker failed")
            return Result.retry()
        }
    }

    companion object {
        const val UNIQUE_WORK_NAME = "batch_article_load"
        private const val BATCH_SIZE = 5
        private const val BATCH_DELAY_MS = 500L

        fun enqueue(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()

            val request = OneTimeWorkRequestBuilder<BatchArticleLoadWorker>()
                .setConstraints(constraints)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_WORK_NAME,
                ExistingWorkPolicy.KEEP,  // Don't restart if already running
                request
            )
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/AppModule.kt">
package com.mydeck.app

import android.content.Context
import timber.log.Timber
import androidx.startup.Initializer
import androidx.work.Configuration
import androidx.work.WorkManager
import dagger.Binds
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import com.mydeck.app.coroutine.ApplicationScope
import com.mydeck.app.coroutine.IoDispatcher
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.BookmarkRepositoryImpl
import com.mydeck.app.domain.UserRepository
import com.mydeck.app.domain.UserRepositoryImpl
import com.mydeck.app.domain.sync.ConnectivityMonitor
import com.mydeck.app.domain.sync.ConnectivityMonitorImpl
import com.mydeck.app.io.rest.NetworkModule
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.serialization.json.Json
import javax.inject.Singleton

@Module(includes = [NetworkModule::class])
@InstallIn(SingletonComponent::class)
abstract class AppModule {

    @Binds
    abstract fun bindBookmarkRepository(bookmarkRepositoryImpl: BookmarkRepositoryImpl): BookmarkRepository

    @Binds
    abstract fun bindUserRepository(userRepositoryImpl: UserRepositoryImpl): UserRepository

    @Binds
    @Singleton
    abstract fun bindConnectivityMonitor(impl: ConnectivityMonitorImpl): ConnectivityMonitor

    companion object {
        @Singleton
        @Provides
        @ApplicationScope
        fun provideApplicationScope(): CoroutineScope {
            return CoroutineScope(Dispatchers.IO + SupervisorJob())
        }

        @Singleton
        @Provides
        @IoDispatcher
        fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO

        @Provides
        @Singleton
        fun provideJson(): Json {
            return Json {
                ignoreUnknownKeys = true // Handle unknown keys gracefully
                isLenient = true // Allow lenient parsing
            }
        }
    }
}

@Module
@InstallIn(SingletonComponent::class)
@Suppress("EnsureInitializerMetadata")
object WorkManagerInitializer : Initializer<WorkManager> {

    @Provides
    @Singleton
    override fun create(@ApplicationContext context: Context): WorkManager {
        val configuration = Configuration.Builder().build()
//        WorkManager.initialize(context, configuration)
        Timber.tag("Hilt Init").d("WorkManager initialized by Hilt this time")
        return WorkManager.getInstance(context)
    }

    override fun dependencies(): List<Class<out Initializer<*>>> {
        // No dependencies on other libraries.
        return emptyList()
    }
}
</file>

<file path="app/src/main/res/values-de-rDE/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <string name="app_name">MyDeck</string>
    <string name="back">Zurck</string>
    <string name="settings_topbar_title">Einstellungen</string>
    <string name="settings_account_title">Konto</string>
    <string name="settings_account_subtitle_default">Nicht eingeloggt</string>
    <string name="accountsettings_topbar_title">Konto</string>
    <string name="account_settings_topbar_title">Readeck URL</string>
    <string name="account_settings_url_placeholder">https://readeck.example.com/api</string>
    <string name="account_settings_url_label">Readeck URL</string>
    <string name="account_settings_username_placeholder">Benutzername</string>
    <string name="account_settings_username_label">Benutzername</string>
    <string name="account_settings_password_label">Passwort</string>
    <string name="account_settings_password_placeholder">Passwort</string>
    <string name="account_settings_login">Einloggen</string>
    <string name="account_settings_url_error">Ungltige URL</string>
    <string name="account_settings_username_error">Benutzername darf nicht leer sein</string>
    <string name="account_settings_password_error">Passwort darf nicht leer sein</string>
    <string name="account_settings_allow_unencrypted">Unverschlsselte Verbindunge erlauben</string>
    <string name="sync_settings_topbar_title">Synchronisierungseinstellungen</string>
    <string name="authors" translatable="true">
{count, plural,
zero{}
one{von {author}}
many{von {author} et. al.}
other{}
}
    </string>
    <string name="settings_open_source_libraries">Open-Source-Bibliotheken</string>
    <string name="settings_open_source_libraries_subtitle">Zeige die in dieser App verwendeten Open-Source-Bibliotheken an.</string>
    <string name="bookmarks">Lesezeichen</string>
    <string name="menu">Men</string>
    <string name="refresh_bookmarks">Lesezeichen aktualisieren</string>
    <string name="all">Alle</string>
    <string name="unread">Ungelesen</string>
    <string name="archive">Archiv</string>
    <string name="favorites">Favoriten</string>
    <string name="articles">Artikel</string>
    <string name="videos">Videos</string>
    <string name="pictures">Bilder</string>
    <string name="settings">Einstellungen</string>
    <string name="an_error_occurred">Ein Fehler ist aufgetreten.</string>
    <string name="no_bookmarks_found">Keine Lesezeichen gefunden.</string>
    <string name="add_bookmark">Lesezeichen hinzufgen</string>
    <string name="title">Titel (Optional)</string>
    <string name="url">URL</string>
    <string name="invalid_url">Ungltige URL</string>
    <string name="save">Speichern</string>
    <string name="cancel">Abbrechen</string>
    <string name="create_bookmark_error">Fehler beim Erstellen des Lesezeichens: %1$s</string>
    <string name="add_new_bookmark">Neues Lesezeichen hinzufgen</string>
    <string name="create">Erstellen</string>
    <string name="error">Fehler</string>
    <string name="ok">OK</string>
    <string name="not_valid_url">Keine gltige URL</string>
    <string name="log_view_title">Logs</string>
    <string name="log_view_send_logs">Logs senden</string>
    <string name="settings_logs">Logs</string>
    <string name="settings_logs_subtitle">Logdateien anzeigen und senden</string>
    <string name="log_view_share_title">Logs senden</string>
    <string name="log_view_no_log_file_found">Keine Logdatei gefunden</string>
    <string name="settings_sync">Synchronisierung</string>
    <string name="settings_sync_subtitle">Synchronisierungseinstellungen</string>

    <!-- Bookmark Card Actions -->
    <string name="action_favorite">Favorit</string>
    <string name="action_archive">Archivieren</string>
    <string name="action_mark_read">Gelesen</string>
    <string name="action_share">Link teilen</string>
    <string name="action_delete">Lschen</string>
    <string name="action_open_in_browser">In Browser ffnen</string>
    <string name="error_no_article_content">Fehler, kein Artikelinhalt verfgbar</string>
    <string name="update_successful">Aktualisierung erfolgreich</string>
    <string name="notification_channel_sync_name">Synchronisierungsfehler</string>
    <string name="notification_channel_sync_description">Fehler, die zum Abbruch der Synchronisierung fhren</string>
    <string name="notification_authentication_error_title">Authentifizierung fehlgeschlagen</string>
    <string name="notification_authentication_error_message">Bitte Anmeldeinformationen prfen.</string>
    <string name="detail_view_no_content">Kein Artikelinhalt gefunden</string>
    <string name="common_bookmark_image_content_description">Lesezeichen Bild</string>
    <string name="settings_sync_full_sync_heading">Synchronisierung im Hintergrund</string>
    <string name="settings_sync_auto_full_sync_title">Synchronisierung im Hintergrund</string>
    <string name="settings_sync_auto_full_button">Jetzt Synchronisieren</string>
    <string name="settings_sync_dialog_support_text">Wie oft soll die Synchronisierung im Hintergrund durchgefhrt werden?</string>
    <string name="auto_sync_timeframe_manual">Manuell</string>
    <string name="auto_sync_timeframe_01_hours">Jede Stunde</string>
    <string name="auto_sync_timeframe_06_hours">Alle 6 Stunden</string>
    <string name="auto_sync_timeframe_12_hours">Alle 12 Stunden</string>
    <string name="auto_sync_timeframe_07_days">Alle 7 Tage</string>
    <string name="auto_sync_timeframe_01_days">Einmal pro Tag</string>
    <string name="auto_sync_timeframe_14_days">Alle 14 Tage</string>
    <string name="auto_sync_timeframe_30_days">Alle 30 Tage</string>
    <string name="auto_sync_next_run">Nchste Synchronisierung am %1$1s</string>
    <string name="auto_sync_next_run_null">Keine Synchronisierung geplant</string>
    <string name="settings_sync_support_text">Um deine Lesezeichenliste aktuell zu halten, prft die App gelegentlich, ob du Lesezeichen auf dem Readedeck-Server gelscht hast, und entfernt diese. Da dieser Vorgang das Herunterladen all deiner Lesezeichen-Daten erfordert, luft er automatisch im Hintergrund ab. So wird sichergestellt, dass deine App deine aktuellen Readedeck-Lesezeichen korrekt widerspiegelt, ohne dass du sie manuell lschen musst.</string>
    <string name="auto_sync_notification_success">Synchronisierung im Hintergrund erfolgreich. %1$d Lesezeichen gelscht.</string>
    <string name="auto_sync_notification_failure">Synchronisierung im Hintergrund gescheitert.</string>
    <string name="auto_sync_notification_running">Synchronisierung im Hintergrund luft.</string>
    <string name="auto_sync_notification_channel">Synchronisierung im Hintergrund</string>
    <string name="auto_sync_notification_rationale_dialog_title">Benachrichtigungen Berechtigung bentigt</string>
    <string name="auto_sync_notification_rationale_dialog_text">Um Sie ber Fehler bei der Hintergrundsynchronisierung zu informieren, bentigen wir die Berechtigung, Ihnen Benachrichtigungen zu senden. Bitte erteilen Sie diese Berechtigung.</string>
    <string name="auto_sync_notification_rationale_dialog_grant_button">Erteilen</string>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-es-rES/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">MyDeck</string>
    <string name="back">Volver</string>
    <string name="settings_topbar_title">Ajustes</string>
    <string name="settings_account_title">Cuenta</string>
    <string name="settings_account_subtitle_default">Sesin no iniciada</string>
    <string name="accountsettings_topbar_title">Cuenta</string>
    <string name="account_settings_topbar_title">URL de MyDeck</string>
    <string name="account_settings_url_placeholder">https://readeck.example.com/api</string>
    <string name="account_settings_url_label">URL de MyDeck</string>
    <string name="account_settings_username_placeholder">identificador</string>
    <string name="account_settings_username_label">Identificador</string>
    <string name="account_settings_password_label">Contrasea</string>
    <string name="account_settings_password_placeholder">contrasea</string>
    <string name="account_settings_login">Iniciar sesin</string>
    <string name="account_settings_url_error">URL no vlida</string>
    <string name="account_settings_username_error">Debes escribir el identificador</string>
    <string name="account_settings_password_error">Debes escribir una contrasea</string>
    <string name="authors" translatable="true">
{count, plural,
zero{}
one{de {author}}
many{de {author} y otros}
other{}
}
    </string>
    <string name="settings_open_source_libraries">Libreras de cdigo abierto</string>
    <string name="settings_open_source_libraries_subtitle">Ver las bibliotecas de cdigo abierto que usa esta app.</string>
    <string name="bookmarks">Marcadores</string>
    <string name="menu">Men</string>
    <string name="refresh_bookmarks">Actualizar marcadores</string>
    <string name="all">Todo</string>
    <string name="unread">Sin leer</string>
    <string name="archive">Archivo</string>
    <string name="favorites">Favoritos</string>
    <string name="articles">Artculos</string>
    <string name="videos">Vdeos</string>
    <string name="pictures">Fotos</string>
    <string name="settings">Ajustes</string>
    <string name="an_error_occurred">Ha habido un fallo.</string>
    <string name="no_bookmarks_found">No hay marcadores.</string>
    <string name="add_bookmark">Aadir marcador</string>
    <string name="title">Ttulo (Opcional)</string>
    <string name="url">URL</string>
    <string name="invalid_url">URL no vlida</string>
    <string name="save">Guardar</string>
    <string name="cancel">Cancelar</string>
    <string name="create_bookmark_error">Error al crear el marcador: %1$s</string>
    <string name="add_new_bookmark">Aadir nuevo marcador</string>
    <string name="create">Crear</string>
    <string name="error">Error</string>
    <string name="ok">OK</string>
    <string name="not_valid_url">URL no vlido</string>
    <string name="log_view_title">Registro</string>
    <string name="log_view_send_logs">Enviar registro</string>
    <string name="settings_logs">Registros</string>
    <string name="settings_logs_subtitle">Ver y enviar registros</string>
    <string name="log_view_share_title">Enviar registro</string>
    <string name="log_view_no_log_file_found">No hai fichero de registro</string>
    <!-- Bookmark Card Actions -->
    <string name="action_favorite">Favorito</string>
    <string name="action_archive">Archivo</string>
    <string name="action_mark_read">Ledo</string>
    <string name="action_delete">Eliminar</string>
    <string name="error_no_article_content">Error, no est disponible el contenido</string>
    <string name="update_successful">Actualizacin correcta</string>
    <string name="notification_channel_sync_name">Errores de sincronizacin</string>
    <string name="notification_channel_sync_description">Errores en la sincronizacin</string>
    <string name="notification_authentication_error_title">Se requiere autenticacin</string>
    <string name="notification_authentication_error_message">Por favor comprueba tus credenciales.</string>
    <string name="action_share">Compartir enlace</string>
    <string name="common_bookmark_image_content_description">Imagen del marcador</string>
    <string name="auto_sync_notification_rationale_dialog_title">Se requiere permisos de Notificacin</string>
    <string name="auto_sync_notification_rationale_dialog_text">Para avisarte acerca de los fallos de la sincronizacin en segundo plano, necesitamos permiso para enviar notificaciones. Por favor acepta el permiso.</string>
    <string name="settings_ui_subtitle">Apariencia</string>
    <string name="ui_settings_theme_title">Tema</string>
    <string name="theme_system">Predeterminado del sistema</string>
    <string name="theme_light">Claro</string>
    <string name="theme_dark">Oscuro</string>
    <string name="ui_settings_theme_heading">Temas</string>
    <string name="ui_settings_theme_dialog_support_text">Qu tema se debe usar?</string>
    <string name="action_open_in_browser">Abrir en el navegador</string>
    <string name="detail_view_no_content">No se encontr contenido del artculo</string>
    <string name="auto_sync_notification_rationale_dialog_grant_button">Dar permiso</string>
    <string name="ui_settings_topbar_title">Opciones de la interfaz de usuario</string>
    <string name="settings_ui">Interfaz de usuario</string>
    <string name="sync_settings_topbar_title">Opciones de sincronizacin</string>
    <string name="settings_sync">Sincronizacin</string>
    <string name="settings_sync_subtitle">Opciones de sincronizacin</string>
    <string name="settings_sync_full_sync_heading">Sincronizacin en segundo plano</string>
    <string name="settings_sync_auto_full_sync_title">Sincronizacin en segundo plano</string>
    <string name="settings_sync_auto_full_button">Sincronizar ahora</string>
    <string name="settings_sync_support_text">Para mantener la lista de tus marcadores actualizada, la aplicacin verifica ocasionalmente y borra marcadores que hayas borrado en el servidor de Readeck. Como este proceso requiere descargar toda la informacin de los marcadores, corre automticamente en segundo plano. Esto ayuda a que la aplicacin refleje los marcadores actuales de Readeck sin que tengas que borrarlos manualmente.</string>
    <string name="settings_sync_dialog_support_text">Cuan seguido debe realizarse la sincronizacin en segundo plano?</string>
    <string name="auto_sync_timeframe_manual">Manual</string>
    <string name="auto_sync_timeframe_01_hours">Cada hora</string>
    <string name="auto_sync_timeframe_06_hours">Cada 6 horas</string>
    <string name="auto_sync_timeframe_12_hours">Cada 12 horas</string>
    <string name="auto_sync_timeframe_07_days">Cada 7 das</string>
    <string name="auto_sync_timeframe_01_days">Una vez al da</string>
    <string name="auto_sync_timeframe_14_days">Cada 14 das</string>
    <string name="auto_sync_timeframe_30_days">Cada 30 das</string>
    <string name="auto_sync_next_run">La prxima sincronizacin ser en %1$s</string>
    <string name="auto_sync_next_run_null">No hay sincronizaciones planeadas</string>
    <string name="auto_sync_notification_success">La sincronizacin en segundo plano fue correcta. Se borraron %1$d marcadores.</string>
    <string name="auto_sync_notification_failure">Fall la sincronizacin en segundo plano.</string>
    <string name="auto_sync_notification_running">La sincronizacin en segundo plano est en proceso.</string>
    <string name="auto_sync_notification_channel">Sincronizacin en segundo plano</string>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-fr/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-gl-rES/strings.xml">
<resources>
    <string name="app_name">MyDeck</string>
    <string name="back">Volver</string>
    <string name="settings_topbar_title">Axustes</string>
    <string name="settings_account_title">Conta</string>
    <string name="settings_account_subtitle_default">Sesin non iniciada</string>
    <string name="accountsettings_topbar_title">Conta</string>
    <string name="account_settings_topbar_title">URL de MyDeck</string>
    <string name="account_settings_url_placeholder">https://readeck.example.com/api</string>
    <string name="account_settings_url_label">URL de MyDeck</string>
    <string name="account_settings_username_placeholder">identificador</string>
    <string name="account_settings_username_label">Identificador</string>
    <string name="account_settings_password_label">Contrasinal</string>
    <string name="account_settings_password_placeholder">contrasinal</string>
    <string name="account_settings_login">Acceder</string>
    <string name="account_settings_url_error">URL non vlido</string>
    <string name="account_settings_username_error">Tes que escribir o identificador</string>
    <string name="account_settings_password_error">Tes que escribir o contrasinal</string>
    <string name="authors" translatable="true">
{count, plural,
zero{}
one{de {author}}
many{de {author} e outros}
other{}
}
    </string>
    <string name="settings_open_source_libraries">Bibliotecas de Cdigo aberto</string>
    <string name="settings_open_source_libraries_subtitle">Ver as bibliotecas de cdigo aberto que usa esta app.</string>
    <string name="bookmarks">Marcadores</string>
    <string name="menu">Men</string>
    <string name="refresh_bookmarks">Actualizar Marcadores</string>
    <string name="all">Todo</string>
    <string name="unread">Sen ler</string>
    <string name="archive">Arquivo</string>
    <string name="favorites">Favoritos</string>
    <string name="articles">Artigos</string>
    <string name="videos">Vdeos</string>
    <string name="pictures">Imaxes</string>
    <string name="settings">Axustes</string>
    <string name="an_error_occurred">Houbo un fallo.</string>
    <string name="no_bookmarks_found">Non hai marcadores.</string>
    <string name="add_bookmark">Engadir marcador</string>
    <string name="title">Ttulo (Optativo)</string>
    <string name="url">URL</string>
    <string name="invalid_url">URL non vlido</string>
    <string name="save">Gardar</string>
    <string name="cancel">Desbotar</string>
    <string name="create_bookmark_error">Erro ao crear o marcador: %1$s</string>
    <string name="add_new_bookmark">Engadir Novo marcador</string>
    <string name="create">Crear</string>
    <string name="error">Erro</string>
    <string name="ok">OK</string>
    <string name="not_valid_url">URL non vlido</string>
    <string name="log_view_title">Rexistros</string>
    <string name="log_view_send_logs">Enviar rexistros</string>
    <string name="settings_logs">Rexistros</string>
    <string name="settings_logs_subtitle">Ver e Enviar ficheiro cos rexistros</string>
    <string name="log_view_share_title">Enviar rexistros</string>
    <string name="log_view_no_log_file_found">Non hai ficheiro de rexistro</string>

    <!-- Bookmark Card Actions -->
    <string name="action_favorite">Favorecer</string>
    <string name="action_archive">Arquivar</string>
    <string name="action_mark_read">Lido</string>
    <string name="action_delete">Eliminar</string>
    <string name="error_no_article_content">Erro, o contido do artigo non est dispoible</string>
    <string name="update_successful">Actualizacin correcta</string>
    <string name="notification_channel_sync_name">Erros ao sincronizar</string>
    <string name="notification_channel_sync_description">Erros na sincronizacin</string>
    <string name="notification_authentication_error_title">Require autenticacin</string>
    <string name="notification_authentication_error_message">Comproba as tas credenciais.</string>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-pl/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-pt-rPT/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-ru/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-uk/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/res/values-zh-rCN/strings.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="account_settings_password_label"></string>
    <string name="account_settings_password_placeholder"></string>
    <string name="account_settings_login"></string>
    <string name="account_settings_url_error"> URL</string>
    <string name="favorites"></string>
    <string name="url">URL</string>
    <string name="detail_view_no_content"></string>
    <string name="auto_sync_notification_rationale_dialog_title"></string>
    <string name="auto_sync_notification_rationale_dialog_text"></string>
    <string name="auto_sync_notification_rationale_dialog_grant_button"></string>
    <string name="settings_account_title"></string>
    <string name="app_name">MyDeck </string>
    <string name="back"></string>
    <string name="settings_topbar_title"></string>
    <string name="settings_account_subtitle_default"></string>
    <string name="accountsettings_topbar_title"></string>
    <string name="account_settings_topbar_title">Readeck URL</string>
    <string name="account_settings_url_placeholder">https://readeck.example.com/api</string>
    <string name="account_settings_url_label">Readeck URL</string>
    <string name="account_settings_username_placeholder"></string>
    <string name="account_settings_username_label"></string>
    <string name="account_settings_username_error"></string>
    <string name="account_settings_password_error"></string>
    <string name="account_settings_allow_unencrypted"></string>
    <string name="sync_settings_topbar_title"></string>
    <string name="authors" translatable="true">{count, plural, zero{} one{ {author}} many{ {author} } other{} }</string>
    <string name="settings_open_source_libraries"></string>
    <string name="settings_open_source_libraries_subtitle"></string>
    <string name="bookmarks"></string>
    <string name="menu"></string>
    <string name="refresh_bookmarks"></string>
    <string name="all"></string>
    <string name="unread"></string>
    <string name="archive"></string>
    <string name="articles"></string>
    <string name="videos"></string>
    <string name="pictures"></string>
    <string name="settings"></string>
    <string name="an_error_occurred"></string>
    <string name="no_bookmarks_found"></string>
    <string name="add_bookmark"></string>
    <string name="title"></string>
    <string name="invalid_url"> URL</string>
    <string name="save"></string>
    <string name="cancel"></string>
    <string name="create_bookmark_error">%1$s</string>
    <string name="add_new_bookmark"></string>
    <string name="create"></string>
    <string name="error"></string>
    <string name="ok"></string>
    <string name="not_valid_url"> URL</string>
    <string name="log_view_title"></string>
    <string name="log_view_send_logs"></string>
    <string name="settings_logs"></string>
    <string name="settings_logs_subtitle"></string>
    <string name="log_view_share_title"></string>
    <string name="log_view_no_log_file_found"></string>
    <string name="settings_sync"></string>
    <string name="settings_sync_subtitle"></string>
    <string name="settings_ui"></string>
    <string name="settings_ui_subtitle"></string>
    <string name="notification_authentication_error_title"></string>
    <string name="ui_settings_topbar_title"></string>
    <string name="ui_settings_theme_title"></string>
    <string name="theme_system"></string>
    <string name="theme_light"></string>
    <string name="theme_dark"></string>
    <string name="ui_settings_theme_heading"></string>
    <string name="ui_settings_theme_dialog_support_text"></string>
    <string name="action_favorite"></string>
    <string name="action_archive"></string>
    <string name="action_mark_read"></string>
    <string name="action_share"></string>
    <string name="action_delete"></string>
    <string name="action_open_in_browser"></string>
    <string name="error_no_article_content"></string>
    <string name="update_successful"></string>
    <string name="notification_channel_sync_name"></string>
    <string name="notification_channel_sync_description"></string>
    <string name="notification_authentication_error_message"></string>
    <string name="common_bookmark_image_content_description"></string>
    <string name="settings_sync_full_sync_heading"></string>
    <string name="settings_sync_auto_full_sync_title"></string>
    <string name="settings_sync_auto_full_button"></string>
    <string name="settings_sync_support_text"> Readedeck  Readedeck </string>
    <string name="settings_sync_dialog_support_text"></string>
    <string name="auto_sync_timeframe_manual"></string>
    <string name="auto_sync_timeframe_01_hours"></string>
    <string name="auto_sync_timeframe_06_hours"> 6 </string>
    <string name="auto_sync_timeframe_12_hours"> 12 </string>
    <string name="auto_sync_timeframe_07_days"> 7 </string>
    <string name="auto_sync_timeframe_01_days"></string>
    <string name="auto_sync_timeframe_14_days"> 14 </string>
    <string name="auto_sync_timeframe_30_days"> 30 </string>
    <string name="auto_sync_next_run"> %1$s</string>
    <string name="auto_sync_next_run_null"></string>
    <string name="auto_sync_notification_success"> %1$d </string>
    <string name="auto_sync_notification_failure"></string>
    <string name="auto_sync_notification_running"></string>
    <string name="auto_sync_notification_channel"></string>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>
    <string name="offline_tooltip">Offline  unable to reach server</string>
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>

    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
</resources>
</file>

<file path="app/src/main/java/com/mydeck/app/ui/detail/BookmarkDetailsDialog.kt">
package com.mydeck.app.ui.detail

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.ContentCopy
import androidx.compose.material.icons.filled.Share
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalClipboardManager
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.text.AnnotatedString
import kotlinx.coroutines.launch
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import com.mydeck.app.R

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun BookmarkDetailsDialog(
    bookmark: BookmarkDetailViewModel.Bookmark,
    onDismissRequest: () -> Unit,
    onLabelsUpdate: (List<String>) -> Unit = {}
) {
    var labels by remember { mutableStateOf(bookmark.labels.toMutableList()) }
    var newLabelInput by remember { mutableStateOf("") }
    val keyboardController = LocalSoftwareKeyboardController.current

    Scaffold(
        modifier = Modifier.fillMaxSize(),
        topBar = {
            TopAppBar(
                title = { Text(stringResource(R.string.detail_dialog_title)) },
                navigationIcon = {
                    IconButton(onClick = onDismissRequest) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(24.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Metadata fields
            MetadataField(
                label = stringResource(R.string.detail_type),
                value = when (bookmark.type) {
                    BookmarkDetailViewModel.Bookmark.Type.ARTICLE -> "Article"
                    BookmarkDetailViewModel.Bookmark.Type.PHOTO -> "Photo"
                    BookmarkDetailViewModel.Bookmark.Type.VIDEO -> "Video"
                }
            )

            if (bookmark.lang.isNotBlank() && bookmark.lang != "Unknown") {
                MetadataField(
                    label = stringResource(R.string.detail_language),
                    value = bookmark.lang
                )
            }

            bookmark.wordCount?.let { count ->
                if (count > 0) {
                    MetadataField(
                        label = stringResource(R.string.detail_word_count),
                        value = "$count words"
                    )
                }
            }

            bookmark.readingTime?.let { time ->
                if (time > 0) {
                    MetadataField(
                        label = stringResource(R.string.detail_reading_time),
                        value = "$time ${stringResource(R.string.detail_minutes_short)}"
                    )
                }
            }

            if (bookmark.authors.isNotEmpty()) {
                MetadataField(
                    label = "Authors",
                    value = bookmark.authors.joinToString(", ")
                )
            }

            if (bookmark.description.isNotBlank()) {
                MetadataField(
                    label = "Description",
                    value = bookmark.description
                )
            }

            // Labels Section
            LabelsSection(
                labels = labels,
                newLabelInput = newLabelInput,
                onNewLabelChange = { newLabelInput = it },
                onAddLabel = {
                    if (newLabelInput.isNotBlank()) {
                        val newLabels = newLabelInput.split(',')
                            .map { it.trim() }
                            .filter { it.isNotBlank() && !labels.contains(it) }

                        labels.addAll(newLabels)
                        newLabelInput = ""
                        keyboardController?.hide()
                        if (newLabels.isNotEmpty()) {
                            onLabelsUpdate(labels)
                        }
                    }
                },
                onRemoveLabel = { label ->
                    labels.remove(label)
                    onLabelsUpdate(labels)
                }
            )

            // Debug Info Section
            if (bookmark.debugInfo.isNotBlank()) {
                DebugInfoSection(debugInfo = bookmark.debugInfo)
            }
        }
    }
}

@Composable
private fun MetadataField(
    label: String,
    value: String
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        Text(
            text = label,
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurface
        )
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun LabelsSection(
    labels: List<String>,
    newLabelInput: String,
    onNewLabelChange: (String) -> Unit,
    onAddLabel: () -> Unit,
    onRemoveLabel: (String) -> Unit
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(
            text = stringResource(R.string.detail_labels),
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        // Existing labels
        if (labels.isNotEmpty()) {
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                labels.forEach { label ->
                    LabelChip(
                        label = label,
                        onRemove = { onRemoveLabel(label) }
                    )
                }
            }
        }

        // Input field for new label
        OutlinedTextField(
            value = newLabelInput,
            onValueChange = onNewLabelChange,
            placeholder = { Text(stringResource(R.string.detail_label_placeholder)) },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),
            keyboardActions = KeyboardActions(
                onDone = { onAddLabel() }
            ),
            textStyle = MaterialTheme.typography.bodySmall
        )
    }
}

@Composable
private fun LabelChip(
    label: String,
    onRemove: () -> Unit = {}
) {
    Card(
        modifier = Modifier.padding(4.dp),
        shape = RoundedCornerShape(16.dp)
    ) {
        Row(
            modifier = Modifier
                .padding(horizontal = 12.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = label,
                style = MaterialTheme.typography.labelSmall,
                modifier = Modifier.weight(1f, fill = false)
            )
            IconButton(
                onClick = onRemove,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    imageVector = Icons.Filled.Close,
                    contentDescription = "Remove label",
                    modifier = Modifier.size(16.dp)
                )
            }
        }
    }
}

@Composable
private fun DebugInfoSection(debugInfo: String) {
    val clipboardManager = LocalClipboardManager.current
    val context = LocalContext.current

    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Header with title and action buttons
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "Debug Info",
                style = MaterialTheme.typography.labelMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Row {
                // Copy button
                IconButton(
                    onClick = {
                        clipboardManager.setText(AnnotatedString(debugInfo))
                    }
                ) {
                    Icon(
                        imageVector = Icons.Filled.ContentCopy,
                        contentDescription = "Copy debug info",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }

                Spacer(modifier = Modifier.width(4.dp))

                // Share button
                IconButton(
                    onClick = {
                        val sendIntent = android.content.Intent().apply {
                            action = android.content.Intent.ACTION_SEND
                            putExtra(android.content.Intent.EXTRA_TEXT, debugInfo)
                            type = "text/plain"
                        }
                        val shareIntent = android.content.Intent.createChooser(sendIntent, "Share Debug Info")
                        context.startActivity(shareIntent)
                    }
                ) {
                    Icon(
                        imageVector = Icons.Filled.Share,
                        contentDescription = "Share debug info",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }

        Card(
            modifier = Modifier
                .fillMaxWidth()
                .height(300.dp)
        ) {
            Column(
                modifier = Modifier
                    .padding(12.dp)
                    .verticalScroll(rememberScrollState())
                    .horizontalScroll(rememberScrollState())
            ) {
                Text(
                    text = debugInfo,
                    style = MaterialTheme.typography.bodySmall.copy(
                        fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace
                    ),
                    color = MaterialTheme.colorScheme.onSurface
                )
            }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun BookmarkDetailsDialogPreview() {
    val sampleBookmark = BookmarkDetailViewModel.Bookmark(
        bookmarkId = "1",
        createdDate = "2024-01-15",
        url = "https://example.com",
        title = "Sample Bookmark",
        siteName = "Example",
        authors = listOf("John Doe", "Jane Smith"),
        imgSrc = "",
        isFavorite = false,
        isArchived = false,
        isRead = false,
        type = BookmarkDetailViewModel.Bookmark.Type.ARTICLE,
        articleContent = null,
        embed = null,
        lang = "English",
        wordCount = 1500,
        readingTime = 7,
        description = "This is a sample description for the bookmark",
        labels = listOf("tech", "android", "kotlin"),
        readProgress = 0,
        hasContent = true
    )

    BookmarkDetailsDialog(
        bookmark = sampleBookmark,
        onDismissRequest = {},
        onLabelsUpdate = {}
    )
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/settings/AccountSettingsScreen.kt">
package com.mydeck.app.ui.settings

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusDirection
import androidx.compose.ui.focus.FocusManager
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.mydeck.app.R
import com.mydeck.app.domain.usecase.AuthenticationResult

@Composable
fun AccountSettingsScreen(
    navHostController: NavHostController
) {
    val viewModel: AccountSettingsViewModel = hiltViewModel()
    val settingsUiState = viewModel.uiState.collectAsState().value
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val onUrlChanged: (String) -> Unit = { url -> viewModel.onUrlChanged(url) }
    val onUsernameChanged: (String) -> Unit = { username -> viewModel.onUsernameChanged(username) }
    val onPasswordChanged: (String) -> Unit = { password -> viewModel.onPasswordChanged(password) }
    val onLoginClicked: () -> Unit = { viewModel.login() }
    val onAllowUnencryptedConnectionChanged: (Boolean) -> Unit = { allow -> viewModel.onAllowUnencryptedConnectionChanged(allow) }
    val onClickBack: () -> Unit = { viewModel.onClickBack() }
    val onSignOut: () -> Unit = { viewModel.signOut() }
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()
    val isStartDestination = navHostController.previousBackStackEntry == null

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                is AccountSettingsViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
                is AccountSettingsViewModel.NavigationEvent.NavigateToBookmarkList -> {
                    navHostController.navigate(com.mydeck.app.ui.navigation.BookmarkListRoute()) {
                        popUpTo(com.mydeck.app.ui.navigation.AccountSettingsRoute) { inclusive = true }
                    }
                }
            }
            viewModel.onNavigationEventConsumed() // Consume the event
        }
    }

    LaunchedEffect(key1 = settingsUiState.authenticationResult) {
        settingsUiState.authenticationResult?.let { result ->
            when (result) {
                is AuthenticationResult.Success -> {
                    snackbarHostState.showSnackbar(
                        message = "Success",
                        duration = SnackbarDuration.Short
                    )
                }

                is AuthenticationResult.AuthenticationFailed -> {
                    snackbarHostState.showSnackbar(
                        message = result.message,
                        duration = SnackbarDuration.Short
                    )
                }

                is AuthenticationResult.NetworkError -> {
                    snackbarHostState.showSnackbar(
                        message = result.message,
                        duration = SnackbarDuration.Short
                    )
                }

                is AuthenticationResult.GenericError -> {
                    snackbarHostState.showSnackbar(
                        message = result.message,
                        duration = SnackbarDuration.Short
                    )
                }
            }
        }
    }

    AccountSettingsView(
        modifier = Modifier,
        snackbarHostState = snackbarHostState,
        settingsUiState = settingsUiState,
        onUrlChanged = onUrlChanged,
        onUsernameChanged = onUsernameChanged,
        onPasswordChanged = onPasswordChanged,
        onLoginClicked = onLoginClicked,
        onClickBack = onClickBack,
        onAllowUnencryptedConnectionChanged = onAllowUnencryptedConnectionChanged,
        onSignOut = onSignOut,
        isStartDestination = isStartDestination
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AccountSettingsView(
    modifier: Modifier = Modifier,
    snackbarHostState: SnackbarHostState,
    settingsUiState: AccountSettingsUiState,
    onUrlChanged: (String) -> Unit,
    onUsernameChanged: (String) -> Unit,
    onPasswordChanged: (String) -> Unit,
    onLoginClicked: () -> Unit,
    onClickBack: () -> Unit,
    onAllowUnencryptedConnectionChanged: (Boolean) -> Unit,
    onSignOut: () -> Unit,
    isStartDestination: Boolean = false
) {
    val keyboardController = LocalSoftwareKeyboardController.current
    val focusManager = LocalFocusManager.current
    val urlFocusRequester = remember { FocusRequester() }
    var showSignOutDialog by remember { mutableStateOf(false) }
    var passwordVisible by remember { mutableStateOf(false) }

    // Create TextFieldValue for URL field with cursor at the end
    val urlValue = remember(settingsUiState.url) {
        val url = settingsUiState.url ?: ""
        TextFieldValue(text = url, selection = TextRange(url.length))
    }

    // Request focus on URL field when screen opens
    LaunchedEffect(Unit) {
        urlFocusRequester.requestFocus()
    }

    if (showSignOutDialog) {
        AlertDialog(
            onDismissRequest = { showSignOutDialog = false },
            title = { Text(stringResource(R.string.account_settings_sign_out_confirm_title)) },
            text = { Text(stringResource(R.string.account_settings_sign_out_confirm_message)) },
            confirmButton = {
                TextButton(
                    onClick = {
                        showSignOutDialog = false
                        onSignOut()
                    }
                ) {
                    Text(stringResource(R.string.account_settings_sign_out), color = MaterialTheme.colorScheme.error)
                }
            },
            dismissButton = {
                TextButton(onClick = { showSignOutDialog = false }) {
                    Text(stringResource(R.string.cancel))
                }
            }
        )
    }

    Scaffold(
        modifier = modifier,
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            if (!isStartDestination) {
                TopAppBar(
                    title = { Text(stringResource(R.string.accountsettings_topbar_title)) },
                    navigationIcon = {
                        IconButton(
                            onClick = onClickBack,
                            modifier = Modifier.testTag(AccountSettingsScreenTestTags.BACK_BUTTON)
                        ) {
                            Icon(
                                Icons.AutoMirrored.Filled.ArrowBack,
                                contentDescription = stringResource(R.string.back)
                            )
                        }
                    }
                )
            } else {
                TopAppBar(
                    title = { Text(stringResource(R.string.accountsettings_topbar_title)) }
                )
            }
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .padding(padding)
                .padding(16.dp)
                .fillMaxSize(),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            item {
                OutlinedTextField(
                    value = urlValue,
                    placeholder = { Text(stringResource(R.string.account_settings_url_placeholder)) },
                    onValueChange = { textFieldValue -> onUrlChanged(textFieldValue.text) },
                    label = { Text(stringResource(R.string.account_settings_url_label)) },
                    modifier = Modifier
                        .fillMaxWidth()
                        .focusRequester(urlFocusRequester),
                    singleLine = true,
                    isError = settingsUiState.urlError != null,
                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Next),
                    keyboardActions = KeyboardActions(onNext = { focusManager.moveFocus(FocusDirection.Down) }),
                    supportingText = {
                        settingsUiState.urlError?.let {
                            Text(text = stringResource(it))
                        }
                    }
                )
            }
            item {
                OutlinedTextField(
                    value = settingsUiState.username ?: "",
                    placeholder = { Text(stringResource(R.string.account_settings_username_placeholder)) },
                    onValueChange = { onUsernameChanged(it) },
                    label = { Text(stringResource(R.string.account_settings_username_label)) },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    isError = settingsUiState.usernameError != null,
                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Next),
                    keyboardActions = KeyboardActions(onNext = { focusManager.moveFocus(FocusDirection.Down) }),
                    supportingText = {
                        settingsUiState.usernameError?.let {
                            Text(text = stringResource(it))
                        }
                    }
                )
            }
            item {
                OutlinedTextField(
                    value = settingsUiState.password ?: "",
                    placeholder = { Text(stringResource(R.string.account_settings_password_placeholder)) },
                    onValueChange = { onPasswordChanged(it) },
                    label = { Text(stringResource(R.string.account_settings_password_label)) },
                    visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                    trailingIcon = {
                        val image = if (passwordVisible)
                            Icons.Filled.Visibility
                        else Icons.Filled.VisibilityOff

                        // Please provide localized description if available
                        val description = if (passwordVisible) "Hide password" else "Show password"

                        IconButton(onClick = { passwordVisible = !passwordVisible }) {
                            Icon(imageVector = image, description)
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    isError = settingsUiState.passwordError != null,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password, imeAction = ImeAction.Done),
                    keyboardActions = KeyboardActions(
                        onDone = {
                            keyboardController?.hide()
                            if (settingsUiState.loginEnabled) {
                                onLoginClicked()
                            }
                        }
                    ),
                    supportingText = {
                        settingsUiState.passwordError?.let {
                            Text(text = stringResource(it))
                        }
                    }
                )
            }
            item {
                Row(
                    modifier = Modifier
                        .height(56.dp)
                        .selectable(
                            selected = settingsUiState.allowUnencryptedConnection,
                            onClick = { onAllowUnencryptedConnectionChanged(settingsUiState.allowUnencryptedConnection.not()) },
                            role = Role.Checkbox
                        ),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Checkbox(
                        checked = settingsUiState.allowUnencryptedConnection,
                        onCheckedChange = null
                    )
                    Text(text = stringResource(R.string.account_settings_allow_unencrypted))
                }
            }
            item {
                Button(
                    onClick = {
                        keyboardController?.hide()
                        onLoginClicked.invoke()
                    },
                    enabled = settingsUiState.loginEnabled,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(stringResource(R.string.account_settings_login))
                }
            }
            // Sign-out section (only show when logged in)
            if (settingsUiState.isLoggedIn) {
                item {
                    HorizontalDivider(modifier = Modifier.padding(vertical = 16.dp))
                }
                item {
                    Text(
                        text = stringResource(R.string.account_settings_sign_out_warning),
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.fillMaxWidth()
                    )
                }
                item {
                    OutlinedButton(
                        onClick = { showSignOutDialog = true },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = MaterialTheme.colorScheme.error
                        ),
                        border = androidx.compose.foundation.BorderStroke(1.dp, MaterialTheme.colorScheme.error)
                    ) {
                        Text(stringResource(R.string.account_settings_sign_out))
                    }
                }
            }
        }
    }
}

@Preview(showBackground = true)
@Composable
fun AccountSettingsScreenViewPreview() {
    val settingsUiState = AccountSettingsUiState(
        url = "https://example.com",
        username = "user",
        password = "pass",
        loginEnabled = true,
        urlError = R.string.account_settings_url_error,
        usernameError = null,
        passwordError = null,
        authenticationResult = null,
        allowUnencryptedConnection = false,
        isLoggedIn = true
    )
    AccountSettingsView(
        modifier = Modifier,
        snackbarHostState = SnackbarHostState(),
        settingsUiState = settingsUiState,
        onUrlChanged = {},
        onUsernameChanged = {},
        onPasswordChanged = {},
        onLoginClicked = {},
        onClickBack = {},
        onAllowUnencryptedConnectionChanged = {},
        onSignOut = {},
        isStartDestination = false
    )
}

object AccountSettingsScreenTestTags {
    const val BACK_BUTTON = "AccountSettingsScreenTestTags.BackButton"
    const val TOPBAR = "AccountSettingsScreenTestTags.TopBar"
    const val SETTINGS_ITEM = "AccountSettingsScreenTestTags.SettingsItem"
    const val SETTINGS_ITEM_TITLE = "AccountSettingsScreenTestTags.SettingsItem.Title"
    const val SETTINGS_ITEM_SUBTITLE = "AccountSettingsScreenTestTags.SettingsItem.Subtitle"
    const val SETTINGS_ITEM_ACCOUNT = "Account"
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/BookmarkRepository.kt">
package com.mydeck.app.domain

import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.BookmarkCounts
import kotlinx.coroutines.flow.Flow
import com.mydeck.app.domain.model.BookmarkListItem

interface BookmarkRepository {
    fun observeBookmarks(
        type: Bookmark.Type? = null,
        unread: Boolean? = null,
        archived: Boolean? = null,
        favorite: Boolean? = null,
        state: Bookmark.State? = null
    ): Flow<List<Bookmark>>

    fun observeBookmarkListItems(
        type: Bookmark.Type? = null,
        unread: Boolean? = null,
        archived: Boolean? = null,
        favorite: Boolean? = null,
        label: String? = null,
        state: Bookmark.State? = null,
        orderBy: String = "created DESC"
    ): Flow<List<BookmarkListItem>>

    suspend fun insertBookmarks(bookmarks: List<Bookmark>)
    suspend fun getBookmarkById(id: String): Bookmark
    suspend fun refreshBookmarkFromApi(id: String)
    fun observeBookmark(id: String): Flow<Bookmark?>
    suspend fun deleteAllBookmarks()
    suspend fun deleteBookmark(id: String): UpdateResult
    suspend fun createBookmark(title: String, url: String, labels: List<String> = emptyList()): String
    suspend fun updateBookmark(bookmarkId: String, isFavorite: Boolean?, isArchived: Boolean?, isRead: Boolean?): UpdateResult
    suspend fun updateReadProgress(bookmarkId: String, progress: Int): UpdateResult
    suspend fun updateLabels(bookmarkId: String, labels: List<String>): UpdateResult
    suspend fun performFullSync(): SyncResult
    suspend fun performDeltaSync(since: kotlinx.datetime.Instant?): SyncResult
    fun searchBookmarkListItems(
        searchQuery: String,
        type: Bookmark.Type? = null,
        unread: Boolean? = null,
        archived: Boolean? = null,
        favorite: Boolean? = null,
        label: String? = null,
        state: Bookmark.State? = null,
        orderBy: String = "created DESC"
    ): Flow<List<BookmarkListItem>>

    fun observeAllBookmarkCounts(): Flow<BookmarkCounts>
    fun observeAllLabelsWithCounts(): Flow<Map<String, Int>>
    suspend fun renameLabel(oldLabel: String, newLabel: String): UpdateResult
    suspend fun deleteLabel(label: String): UpdateResult
    sealed class UpdateResult {
        data object Success: UpdateResult()
        data class Error(val errorMessage: String, val code: Int? = null, val ex: Exception? = null): UpdateResult()
        data class NetworkError(val errorMessage: String, val ex: Exception?): UpdateResult()
    }
    sealed class SyncResult {
        data class Success(val countDeleted: Int): SyncResult()
        data class Error(val errorMessage: String, val code: Int? = null, val ex: Exception? = null): SyncResult()
        data class NetworkError(val errorMessage: String, val ex: Exception?): SyncResult()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/io/db/dao/BookmarkDao.kt">
package com.mydeck.app.io.db.dao

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.OnConflictStrategy.Companion.REPLACE
import androidx.room.Query
import androidx.room.RawQuery
import androidx.room.Transaction
import androidx.sqlite.db.SimpleSQLiteQuery
import androidx.sqlite.db.SupportSQLiteQuery
import com.mydeck.app.io.db.model.BookmarkEntity
import kotlinx.coroutines.flow.Flow
import timber.log.Timber
import com.mydeck.app.io.db.model.ArticleContentEntity
import com.mydeck.app.io.db.model.BookmarkWithArticleContent
import com.mydeck.app.io.db.model.BookmarkListItemEntity
import com.mydeck.app.io.db.model.RemoteBookmarkIdEntity
import com.mydeck.app.io.db.model.BookmarkCountsEntity

@Dao
interface BookmarkDao {
    @Query("SELECT * from bookmarks")
    suspend fun getBookmarks(): List<BookmarkEntity>

    @Query("SELECT * FROM bookmarks ORDER BY created DESC")
    fun getAllBookmarks(): Flow<List<BookmarkEntity>>

    @Query("SELECT * from bookmarks WHERE type = 'picture'")
    fun getPictures(): Flow<List<BookmarkEntity>>

    @Query("SELECT * from bookmarks WHERE type = 'video'")
    fun getVideos(): Flow<List<BookmarkEntity>>

    @Query("SELECT * from bookmarks WHERE type = 'article'")
    fun getArticles(): Flow<List<BookmarkEntity>>

    @Query("""
        SELECT labels FROM bookmarks WHERE state = 0 AND labels != '' AND labels IS NOT NULL
    """)
    fun observeAllLabels(): Flow<List<String>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertBookmarks(bookmarks: List<BookmarkEntity>)

    @Transaction
    suspend fun insertBookmarkWithArticleContent(bookmarkWithArticleContent: BookmarkWithArticleContent) {
        with(bookmarkWithArticleContent) {
            // For existing bookmarks, preserve content state and downloaded article content.
            // Room's REPLACE strategy does DELETE+INSERT, which triggers CASCADE DELETE on
            // the article_content foreign key. We must read and restore both.
            val existingState = getContentStateById(bookmark.id)
            val existingArticleContent = if (existingState != null) getArticleContent(bookmark.id) else null

            val bookmarkToInsert = if (existingState != null) {
                bookmark.copy(
                    contentState = existingState.contentState,
                    contentFailureReason = existingState.contentFailureReason
                )
            } else {
                bookmark
            }

            insertBookmark(bookmarkToInsert)

            // Re-insert article content: prefer new content, fall back to preserved existing
            val contentToSave = articleContent ?: existingArticleContent?.let {
                ArticleContentEntity(bookmarkId = bookmark.id, content = it)
            }
            contentToSave?.run { insertArticleContent(this) }
        }
    }

    @Transaction
    suspend fun insertBookmarksWithArticleContent(bookmarks: List<BookmarkWithArticleContent>) {
        bookmarks.forEach {
            insertBookmarkWithArticleContent(it)
        }
    }

    @Insert(onConflict = REPLACE)
    suspend fun insertBookmark(bookmarkEntity: BookmarkEntity)

    @Query("SELECT * FROM bookmarks ORDER BY updated DESC LIMIT 1")
    suspend fun getLastUpdatedBookmark(): BookmarkEntity?

    @Query("SELECT * FROM bookmarks WHERE id = :id")
    suspend fun getBookmarkById(id: String): BookmarkEntity

    @Query("SELECT * FROM bookmarks WHERE id = :id")
    fun observeBookmark(id: String): Flow<BookmarkEntity?>

    @Query("DELETE FROM bookmarks")
    suspend fun deleteAllBookmarks()

    @Query("DELETE FROM bookmarks WHERE id = :id")
    suspend fun deleteBookmark(id: String)

    @RawQuery(observedEntities = [BookmarkEntity::class])
    fun getBookmarksByFiltersDynamic(query: SupportSQLiteQuery): Flow<List<BookmarkEntity>>

    @RawQuery(observedEntities = [BookmarkEntity::class])
    fun getBookmarkListItemsByFiltersDynamic(query: SupportSQLiteQuery): Flow<List<BookmarkListItemEntity>>

    fun getBookmarksByFilters(
        type: BookmarkEntity.Type? = null,
        isUnread: Boolean? = null,
        isArchived: Boolean? = null,
        isFavorite: Boolean? = null,
        state: BookmarkEntity.State? = null,
        orderBy: String = "created DESC"
    ): Flow<List<BookmarkEntity>> {
        val args = mutableListOf<Any>()
        val sqlQuery = buildString {
            append("SELECT * FROM bookmarks WHERE 1=1")

            state?.let {
                append(" AND state = ?")
                args.add(it.value)
            }

            type?.let {
                append(" AND type = ?")
                args.add(it.value)
            }

            if (isUnread == true) {
                append(" AND readProgress < 100")
            } else if (isUnread == false) {
                append(" AND readProgress = 100")
            }

            isArchived?.let {
                append(" AND isArchived = ?")
                args.add(it)
            }

            isFavorite?.let {
                append(" AND isMarked = ?")
                args.add(it)
            }
            append(" ORDER BY $orderBy")
        }.let { SimpleSQLiteQuery(it, args.toTypedArray()) }
        Timber.d("query=${sqlQuery.sql}")
        return getBookmarksByFiltersDynamic(sqlQuery)
    }

    @Query("SELECT content FROM article_content WHERE bookmarkId = :bookmarkId")
    suspend fun getArticleContent(bookmarkId: String): String?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertArticleContent(articleContent: ArticleContentEntity): Unit

    @Query("DELETE FROM article_content WHERE bookmarkId = :bookmarkId")
    suspend fun deleteArticleContent(bookmarkId: String)

    @Query("SELECT * FROM bookmarks")
    suspend fun getAllBookmarksWithContent(): List<BookmarkWithArticleContent>

    @Query("SELECT * FROM bookmarks WHERE id = :id")
    fun observeBookmarkWithArticleContent(id: String): Flow<BookmarkWithArticleContent?>

    fun getBookmarkListItemsByFilters(
        type: BookmarkEntity.Type? = null,
        isUnread: Boolean? = null,
        isArchived: Boolean? = null,
        isFavorite: Boolean? = null,
        label: String? = null,
        state: BookmarkEntity.State? = null,
        orderBy: String = "created DESC"
    ): Flow<List<BookmarkListItemEntity>> {
        val args = mutableListOf<Any>()
        val sqlQuery = buildString {
            append("""SELECT
            id,
            url,
            title,
            siteName,
            isMarked,
            isArchived,
            readProgress,
            icon_src AS iconSrc,
            image_src AS imageSrc,
            labels,
            thumbnail_src AS thumbnailSrc,
            type,
            readingTime,
            created,
            wordCount,
            published
            """)

            append(" FROM bookmarks WHERE 1=1")

            state?.let {
                append(" AND state = ?")
                args.add(it.value)
            }

            type?.let {
                append(" AND type = ?")
                args.add(it.value)
            }

            if (isUnread == true) {
                append(" AND readProgress < 100")
            } else if (isUnread == false) {
                append(" AND readProgress = 100")
            }

            isArchived?.let {
                append(" AND isArchived = ?")
                args.add(it)
            }

            isFavorite?.let {
                append(" AND isMarked = ?")
                args.add(it)
            }

            label?.let {
                append(" AND labels LIKE ?")
                args.add("%$it%")
            }

            append(" ORDER BY $orderBy")
        }.let { SimpleSQLiteQuery(it, args.toTypedArray()) }
        Timber.d("query=${sqlQuery.sql}")
        return getBookmarkListItemsByFiltersDynamic(sqlQuery)
    }

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertRemoteBookmarkIds(ids: List<RemoteBookmarkIdEntity>)

    @Query("DELETE FROM remote_bookmark_ids")
    suspend fun clearRemoteBookmarkIds()

    @Query("SELECT id FROM remote_bookmark_ids")
    suspend fun getAllRemoteBookmarkIds(): List<String>

    @Query(
        """
            DELETE FROM bookmarks
            WHERE NOT EXISTS (SELECT 1 FROM remote_bookmark_ids WHERE bookmarks.id = remote_bookmark_ids.id)
        """
    )
    suspend fun removeDeletedBookmars(): Int

    @Query(
        """
        SELECT
            (SELECT COUNT(*) FROM bookmarks WHERE readProgress < 100 AND state = 0) AS unread_count,
            (SELECT COUNT(*) FROM bookmarks WHERE isArchived = 1 AND state = 0) AS archived_count,
            (SELECT COUNT(*) FROM bookmarks WHERE isMarked = 1 AND state = 0) AS favorite_count,
            (SELECT COUNT(*) FROM bookmarks WHERE type = 'article' AND state = 0) AS article_count,
            (SELECT COUNT(*) FROM bookmarks WHERE type = 'video' AND state = 0) AS video_count,
            (SELECT COUNT(*) FROM bookmarks WHERE type = 'photo' AND state = 0) AS picture_count,
            (SELECT COUNT(*) FROM bookmarks WHERE state = 0) AS total_count
        FROM bookmarks
        LIMIT 1
        """
    )
    fun observeAllBookmarkCounts(): Flow<BookmarkCountsEntity?>

    @Query("""
        SELECT
            (SELECT COUNT(*) FROM bookmarks) AS total,
            (SELECT COUNT(*) FROM article_content) AS withContent
    """)
    fun observeSyncStatus(): Flow<SyncStatusCounts?>

    @Query("""
        SELECT b.id FROM bookmarks b
        WHERE NOT EXISTS (SELECT 1 FROM article_content ac WHERE ac.bookmarkId = b.id)
        ORDER BY b.created DESC
    """)
    suspend fun getBookmarkIdsWithoutContent(): List<String>

    data class SyncStatusCounts(
        val total: Int,
        val withContent: Int
    )

    @Query("UPDATE bookmarks SET isMarked = :isMarked WHERE id = :id")
    suspend fun updateIsMarked(id: String, isMarked: Boolean)

    @Query("UPDATE bookmarks SET isArchived = :isArchived WHERE id = :id")
    suspend fun updateIsArchived(id: String, isArchived: Boolean)

    @Query("UPDATE bookmarks SET readProgress = :readProgress WHERE id = :id")
    suspend fun updateReadProgress(id: String, readProgress: Int)

    @Query("UPDATE bookmarks SET labels = :labels WHERE id = :id")
    suspend fun updateLabels(id: String, labels: String)

    fun searchBookmarkListItems(
        searchQuery: String,
        type: BookmarkEntity.Type? = null,
        isUnread: Boolean? = null,
        isArchived: Boolean? = null,
        isFavorite: Boolean? = null,
        label: String? = null,
        state: BookmarkEntity.State? = null,
        orderBy: String = "created DESC"
    ): Flow<List<BookmarkListItemEntity>> {
        val args = mutableListOf<Any>()
        val sqlQuery = buildString {
            append("""SELECT id, url, title, siteName, isMarked, isArchived,
            readProgress, icon_src AS iconSrc, image_src AS imageSrc,
            labels, thumbnail_src AS thumbnailSrc, type,
            readingTime, created, wordCount, published
            FROM bookmarks WHERE 1=1""")

            if (searchQuery.isNotBlank()) {
                append(" AND (title LIKE ? COLLATE NOCASE OR labels LIKE ? COLLATE NOCASE OR siteName LIKE ? COLLATE NOCASE)")
                val pattern = "%$searchQuery%"
                args.add(pattern)
                args.add(pattern)
                args.add(pattern)
            }

            state?.let {
                append(" AND state = ?")
                args.add(it.value)
            }

            type?.let {
                append(" AND type = ?")
                args.add(it.value)
            }

            if (isUnread == true) {
                append(" AND readProgress < 100")
            } else if (isUnread == false) {
                append(" AND readProgress = 100")
            }

            isArchived?.let {
                append(" AND isArchived = ?")
                args.add(it)
            }

            isFavorite?.let {
                append(" AND isMarked = ?")
                args.add(it)
            }

            label?.let {
                append(" AND labels LIKE ?")
                args.add("%$it%")
            }

            append(" ORDER BY $orderBy")
        }.let { SimpleSQLiteQuery(it, args.toTypedArray()) }
        Timber.d("searchQuery=${sqlQuery.sql}")
        return getBookmarkListItemsByFiltersDynamic(sqlQuery)
    }

    data class ContentStateInfo(
        val contentState: BookmarkEntity.ContentState,
        val contentFailureReason: String?
    )

    @Query("SELECT contentState, contentFailureReason FROM bookmarks WHERE id = :id")
    suspend fun getContentStateById(id: String): ContentStateInfo?

    @Query("UPDATE bookmarks SET contentState = :state, contentFailureReason = :reason WHERE id = :id")
    suspend fun updateContentState(id: String, state: Int, reason: String?)

    data class DetailedSyncStatusCounts(
        val total: Int,
        val unread: Int,
        val archived: Int,
        val favorites: Int,
        val contentDownloaded: Int,
        val contentAvailable: Int,
        val contentDirty: Int,
        val permanentNoContent: Int
    )

    @Query("""
        SELECT
            (SELECT COUNT(*) FROM bookmarks WHERE state = 0) AS total,
            (SELECT COUNT(*) FROM bookmarks WHERE readProgress < 100 AND state = 0) AS unread,
            (SELECT COUNT(*) FROM bookmarks WHERE isArchived = 1 AND state = 0) AS archived,
            (SELECT COUNT(*) FROM bookmarks WHERE isMarked = 1 AND state = 0) AS favorites,
            (SELECT COUNT(*) FROM bookmarks WHERE contentState = 1) AS contentDownloaded,
            (SELECT COUNT(*) FROM bookmarks WHERE contentState = 0 AND hasArticle = 1) AS contentAvailable,
            (SELECT COUNT(*) FROM bookmarks WHERE contentState = 2) AS contentDirty,
            (SELECT COUNT(*) FROM bookmarks WHERE contentState = 3) AS permanentNoContent
        FROM bookmarks LIMIT 1
    """)
    fun observeDetailedSyncStatus(): Flow<DetailedSyncStatusCounts?>

    @Query("""
        SELECT b.id FROM bookmarks b
        WHERE b.contentState IN (0, 2)
        AND b.hasArticle = 1
        ORDER BY b.created DESC
    """)
    suspend fun getBookmarkIdsEligibleForContentFetch(): List<String>

    @Query("""
        SELECT b.id FROM bookmarks b
        WHERE b.contentState IN (0, 2)
        AND b.hasArticle = 1
        AND b.created >= :fromEpoch AND b.created <= :toEpoch
        ORDER BY b.created DESC
    """)
    suspend fun getBookmarkIdsForDateRangeContentFetch(fromEpoch: Long, toEpoch: Long): List<String>
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/detail/BookmarkDetailViewModel.kt">
package com.mydeck.app.ui.detail

import android.content.Intent
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.model.Bookmark.ContentState
import com.mydeck.app.domain.model.Template
import com.mydeck.app.domain.model.Theme
import com.mydeck.app.domain.usecase.LoadArticleUseCase
import com.mydeck.app.domain.usecase.UpdateBookmarkUseCase
import com.mydeck.app.io.AssetLoader
import com.mydeck.app.io.prefs.SettingsDataStore
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.NonCancellable
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.datetime.LocalDateTime
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toInstant
import timber.log.Timber
import java.text.DateFormat
import java.util.Date
import javax.inject.Inject
import kotlin.io.encoding.ExperimentalEncodingApi

@HiltViewModel
class BookmarkDetailViewModel @Inject constructor(
    private val updateBookmarkUseCase: UpdateBookmarkUseCase,
    private val bookmarkRepository: BookmarkRepository,
    private val assetLoader: AssetLoader,
    private val settingsDataStore: SettingsDataStore,
    private val loadArticleUseCase: LoadArticleUseCase,
    savedStateHandle: SavedStateHandle
) : ViewModel() {
    private val _navigationEvent = MutableStateFlow<NavigationEvent?>(null)
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()

    private val _openUrlEvent = MutableStateFlow<String>("")
    val openUrlEvent = _openUrlEvent.asStateFlow()

    private val _shareIntent = MutableStateFlow<Intent?>(null)
    val shareIntent: StateFlow<Intent?> = _shareIntent.asStateFlow()

    private val bookmarkId: String? = savedStateHandle["bookmarkId"]
    private val template: Flow<Template?> = settingsDataStore.themeFlow.map {
        it?.let {
            Theme.valueOf(it)
        } ?: Theme.SYSTEM
    }.map {
        when (it) {
            Theme.DARK -> assetLoader.loadAsset(Template.DARK_TEMPLATE_FILE)?.let { Template.SimpleTemplate(it) }
            Theme.LIGHT -> assetLoader.loadAsset(Template.LIGHT_TEMPLATE_FILE)?.let { Template.SimpleTemplate(it) }
            Theme.SEPIA -> assetLoader.loadAsset(Template.SEPIA_TEMPLATE_FILE)?.let { Template.SimpleTemplate(it) }
            Theme.SYSTEM -> {
                val light = assetLoader.loadAsset(Template.LIGHT_TEMPLATE_FILE)
                val dark = assetLoader.loadAsset(Template.DARK_TEMPLATE_FILE)
                if (!light.isNullOrBlank() && !dark.isNullOrBlank()) {
                    Template.DynamicTemplate(light = light, dark = dark)
                } else null
            }
        }
    }
    private val zoomFactor: Flow<Int> = settingsDataStore.zoomFactorFlow
    private val updateState = MutableStateFlow<UpdateBookmarkState?>(null)

    // Local tracking of scroll progress (not immediately persisted)
    private var currentScrollProgress = 0
    private var initialReadProgress = 0
    private var bookmarkType: com.mydeck.app.domain.model.Bookmark.Type? = null
    private var isReadLocked = false // true when article has been completed; disables scroll tracking

    // Content loading state for on-demand fetch
    private val _contentLoadState = MutableStateFlow<ContentLoadState>(ContentLoadState.Idle)
    val contentLoadState: StateFlow<ContentLoadState> = _contentLoadState.asStateFlow()

    // Pending deletion state (for undo functionality)
    // Uses a separate scope so deletion survives ViewModel clearing (e.g. user navigates back)
    private val deletionScope = CoroutineScope(Dispatchers.IO)
    private var pendingDeletionJob: Job? = null
    private val _pendingDeletion = MutableStateFlow(false)
    val pendingDeletion: StateFlow<Boolean> = _pendingDeletion.asStateFlow()

    init {
        // Load initial progress and handle type-specific behavior
        if (bookmarkId != null) {
            viewModelScope.launch {
                try {
                    val bookmark = bookmarkRepository.getBookmarkById(bookmarkId)
                    initialReadProgress = bookmark.readProgress
                    bookmarkType = bookmark.type

                    // For photos and videos, auto-mark as 100% when opened
                    // and refresh from API to ensure embed data is available
                    when (bookmark.type) {
                        is com.mydeck.app.domain.model.Bookmark.Type.Picture,
                        is com.mydeck.app.domain.model.Bookmark.Type.Video -> {
                            if (bookmark.readProgress < 100) {
                                bookmarkRepository.updateReadProgress(bookmarkId, 100)
                                currentScrollProgress = 100
                            }
                            // Refresh from API to get embed and other fields
                            // that may not have been present during initial sync
                            bookmarkRepository.refreshBookmarkFromApi(bookmarkId)
                        }
                        is com.mydeck.app.domain.model.Bookmark.Type.Article -> {
                            currentScrollProgress = bookmark.readProgress
                            // If article was already completed, lock scroll tracking
                            // so scrolling back up doesn't reduce progress from 100
                            isReadLocked = bookmark.isRead()

                            // Handle content availability
                            when (bookmark.contentState) {
                                ContentState.DOWNLOADED -> { /* Content available, nothing to do */ }
                                ContentState.PERMANENT_NO_CONTENT -> {
                                    // Signal to UI that content is permanently unavailable
                                    _contentLoadState.value = ContentLoadState.Failed(
                                        reason = bookmark.contentFailureReason ?: "No content available",
                                        canRetry = false
                                    )
                                }
                                else -> {
                                    // NOT_ATTEMPTED or DIRTY  attempt on-demand fetch
                                    fetchContentOnDemand(bookmarkId)
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    Timber.e(e, "Error initializing bookmark progress: ${e.message}")
                }
            }
        }
    }

    override fun onCleared() {
        super.onCleared()
        // Save final progress when leaving the detail view
        // viewModelScope is cancelled during onCleared(), so use an independent scope
        // to ensure the save completes even during ViewModel teardown
        CoroutineScope(
            kotlinx.coroutines.SupervisorJob() + Dispatchers.IO
        ).launch {
            saveCurrentProgress()
        }
    }

    fun getInitialReadProgress(): Int = currentScrollProgress.takeIf { it > 0 } ?: initialReadProgress

    private suspend fun saveCurrentProgress() {
        if (bookmarkId != null && currentScrollProgress > 0) {
            try {
                bookmarkRepository.updateReadProgress(bookmarkId, currentScrollProgress)
                Timber.d("Saved final read progress: $currentScrollProgress%")
            } catch (e: Exception) {
                Timber.e(e, "Error saving final progress: ${e.message}")
            }
        }
    }

    @OptIn(ExperimentalEncodingApi::class)
    val uiState = combine(
        bookmarkRepository.observeBookmark(bookmarkId!!),
        updateState,
        template,
        zoomFactor
    ) { bookmark, updateState, template, zoomFactor ->
        if (bookmark == null) {
            Timber.e("Error loading bookmark [bookmarkId=$bookmarkId]")
            UiState.Error
        } else if (template == null) {
            Timber.e("Error loading template(s)")
            UiState.Error
        } else {
            UiState.Success(
                bookmark = Bookmark(
                    url = bookmark.url,
                    title = bookmark.title,
                    authors = bookmark.authors,
                    createdDate = formatLocalDateTimeWithDateFormat(bookmark.created),
                    bookmarkId = bookmarkId,
                    siteName = bookmark.siteName,
                    imgSrc = bookmark.image.src,
                    isFavorite = bookmark.isMarked,
                    isArchived = bookmark.isArchived,
                    isRead = bookmark.isRead(),
                    type = when (bookmark.type) {
                        is com.mydeck.app.domain.model.Bookmark.Type.Article -> Bookmark.Type.ARTICLE
                        is com.mydeck.app.domain.model.Bookmark.Type.Picture -> Bookmark.Type.PHOTO
                        is com.mydeck.app.domain.model.Bookmark.Type.Video -> Bookmark.Type.VIDEO
                    },
                    articleContent = bookmark.articleContent,
                    embed = bookmark.embed,
                    lang = bookmark.lang,
                    wordCount = bookmark.wordCount,
                    readingTime = bookmark.readingTime,
                    description = bookmark.description,
                    labels = bookmark.labels,
                    readProgress = bookmark.readProgress,
                    debugInfo = buildDebugInfo(bookmark),
                    hasContent = when (bookmark.type) {
                        is com.mydeck.app.domain.model.Bookmark.Type.Article -> !bookmark.articleContent.isNullOrBlank()
                        is com.mydeck.app.domain.model.Bookmark.Type.Video -> !bookmark.articleContent.isNullOrBlank() || !bookmark.embed.isNullOrBlank()
                        is com.mydeck.app.domain.model.Bookmark.Type.Picture -> true
                    }
                ),
                updateBookmarkState = updateState,
                template = template,
                zoomFactor = zoomFactor
            )
        }
    }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = UiState.Loading
        )

    fun onToggleFavorite(bookmarkId: String, isFavorite: Boolean) {
        updateBookmark {
            updateBookmarkUseCase.updateIsFavorite(
                bookmarkId = bookmarkId,
                isFavorite = isFavorite
            )
        }
    }

    fun onUpdateBookmarkStateConsumed() {
        updateState.value = null
    }

    fun onToggleArchive(bookmarkId: String, isArchived: Boolean) {
        updateBookmark {
            updateBookmarkUseCase.updateIsArchived(
                bookmarkId = bookmarkId,
                isArchived = isArchived
            )
        }
    }

    fun onToggleMarkRead(bookmarkId: String, isRead: Boolean) {
        updateBookmark {
            updateBookmarkUseCase.updateIsRead(
                bookmarkId = bookmarkId,
                isRead = isRead
            )
        }
    }

    fun onUpdateLabels(bookmarkId: String, labels: List<String>) {
        updateBookmark {
            // For now, we'll handle labels through the repository directly
            // This should be implemented in UpdateBookmarkUseCase.updateLabels()
            val result = bookmarkRepository.updateLabels(bookmarkId, labels)
            when (result) {
                is BookmarkRepository.UpdateResult.Success -> UpdateBookmarkUseCase.Result.Success
                is BookmarkRepository.UpdateResult.Error -> UpdateBookmarkUseCase.Result.GenericError(result.errorMessage)
                is BookmarkRepository.UpdateResult.NetworkError -> UpdateBookmarkUseCase.Result.NetworkError(result.errorMessage)
            }
        }
    }

    fun onScrollProgressChanged(progress: Int) {
        // Once article is marked read, ignore further scroll updates
        // (matches native Readeck behavior: lock on completion)
        if (isReadLocked) return

        val clamped = progress.coerceIn(0, 100)
        currentScrollProgress = clamped

        // Auto-complete: when user reaches the bottom, lock tracking
        if (clamped >= 100) {
            isReadLocked = true
        }
    }

    fun onToggleRead(bookmarkId: String, isRead: Boolean) {
        viewModelScope.launch {
            try {
                val newProgress = if (isRead) 100 else 0
                bookmarkRepository.updateReadProgress(bookmarkId, newProgress)
                currentScrollProgress = newProgress
                isReadLocked = isRead // Lock on "mark read", unlock on "mark unread"
                Timber.d("Manually set read progress to $newProgress%")
            } catch (e: Exception) {
                Timber.e(e, "Error updating read state: ${e.message}")
            }
        }
    }

    private fun updateBookmark(update: suspend () -> UpdateBookmarkUseCase.Result) {
        viewModelScope.launch {
            val state = when (val result = update()) {
                is UpdateBookmarkUseCase.Result.Success -> UpdateBookmarkState.Success
                is UpdateBookmarkUseCase.Result.GenericError -> UpdateBookmarkState.Error(result.message)
                is UpdateBookmarkUseCase.Result.NetworkError -> UpdateBookmarkState.Error(result.message)
            }
            updateState.value = state
        }
    }

    fun onClickShareBookmark(url: String) {

        val intent = Intent().apply {
            action = Intent.ACTION_SEND
            putExtra(Intent.EXTRA_TEXT, url)
            type = "text/plain"
        }

        _shareIntent.value = intent
    }

    fun onShareIntentConsumed() {
        _shareIntent.value = null
    }

    fun deleteBookmark(bookmarkId: String) {
        // Cancel any existing pending deletion
        pendingDeletionJob?.cancel()

        _pendingDeletion.value = true

        pendingDeletionJob = deletionScope.launch {
            try {
                delay(10000)

                val state = when (val result = updateBookmarkUseCase.deleteBookmark(bookmarkId)) {
                    is UpdateBookmarkUseCase.Result.Success -> UpdateBookmarkState.Success
                    is UpdateBookmarkUseCase.Result.GenericError -> UpdateBookmarkState.Error(result.message)
                    is UpdateBookmarkUseCase.Result.NetworkError -> UpdateBookmarkState.Error(result.message)
                }
                if (state is UpdateBookmarkState.Success) {
                    _navigationEvent.update { NavigationEvent.NavigateBack }
                }
                updateState.value = state
                _pendingDeletion.value = false
            } catch (e: CancellationException) {
                Timber.d("Deletion cancelled by user")
                _pendingDeletion.value = false
                throw e
            } catch (e: Exception) {
                Timber.e(e, "Error deleting bookmark: ${e.message}")
                _pendingDeletion.value = false
            }
        }
    }

    fun onCancelDeleteBookmark() {
        pendingDeletionJob?.cancel()
        pendingDeletionJob = null
        _pendingDeletion.value = false
        Timber.d("Delete bookmark cancelled")
    }

    fun onClickOpenUrl(url: String){
         _openUrlEvent.value = url
    }

    fun onClickBack() {
        // Save progress before navigating back
        viewModelScope.launch {
            saveCurrentProgress()
            _navigationEvent.update { NavigationEvent.NavigateBack }
        }
    }

    fun onClickChangeZoomFactor(value: Int) {
        viewModelScope.launch {
            val currentZoom = settingsDataStore.zoomFactorFlow
                .stateIn(viewModelScope)
                .value
            val newZoom = (currentZoom + value).coerceAtMost(400).coerceAtLeast(25)
            settingsDataStore.saveZoomFactor(newZoom)
        }
    }

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null } // Reset the event
    }

    fun onOpenUrlEventConsumed() {
        _openUrlEvent.value = ""
    }

    private fun formatLocalDateTimeWithDateFormat(localDateTime: LocalDateTime): String {
        val dateFormat = DateFormat.getDateInstance(
            DateFormat.MEDIUM
        )
        val timeZone = TimeZone.currentSystemDefault()
        val epochMillis = localDateTime.toInstant(timeZone).toEpochMilliseconds()
        return dateFormat.format(Date(epochMillis))
    }

    private fun fetchContentOnDemand(bookmarkId: String) {
        viewModelScope.launch {
            _contentLoadState.value = ContentLoadState.Loading
            val result = loadArticleUseCase.execute(bookmarkId)
            _contentLoadState.value = when (result) {
                is LoadArticleUseCase.Result.Success -> ContentLoadState.Loaded
                is LoadArticleUseCase.Result.AlreadyDownloaded -> ContentLoadState.Loaded
                is LoadArticleUseCase.Result.TransientFailure -> ContentLoadState.Failed(
                    reason = result.reason,
                    canRetry = true
                )
                is LoadArticleUseCase.Result.PermanentFailure -> ContentLoadState.Failed(
                    reason = result.reason,
                    canRetry = false
                )
            }
        }
    }

    fun retryContentFetch() {
        bookmarkId?.let { fetchContentOnDemand(it) }
    }

    sealed class ContentLoadState {
        data object Idle : ContentLoadState()
        data object Loading : ContentLoadState()
        data object Loaded : ContentLoadState()
        data class Failed(val reason: String, val canRetry: Boolean) : ContentLoadState()
    }

    sealed class NavigationEvent {
        data object NavigateBack : NavigationEvent()
    }

    sealed class UiState {
        data class Success(val bookmark: Bookmark, val updateBookmarkState: UpdateBookmarkState?, val template: Template, val zoomFactor: Int) :
            UiState()

        data object Loading : UiState()
        data object Error : UiState()
    }

    data class Bookmark(
        val url: String,
        val title: String,
        val authors: List<String>,
        val createdDate: String,
        val bookmarkId: String,
        val siteName: String,
        val imgSrc: String,
        val isFavorite: Boolean,
        val isArchived: Boolean,
        val isRead: Boolean,
        val type: Type,
        val articleContent: String?,
        val embed: String?,
        val lang: String,
        val wordCount: Int?,
        val readingTime: Int?,
        val description: String,
        val labels: List<String>,
        val readProgress: Int,
        val debugInfo: String = "",
        val hasContent: Boolean
    ) {
        enum class Type {
            ARTICLE, PHOTO, VIDEO
        }
        fun getContent(template: Template, isDark: Boolean): String? {
            val htmlTemplate = when (template) {
                is Template.SimpleTemplate -> template.template
                is Template.DynamicTemplate -> {
                    if (isDark) {
                        template.dark
                    } else {
                        template.light
                    }
                }
            }
            return when (type) {
                Type.PHOTO -> {
                    val textPart = articleContent ?: description.takeIf { it.isNotBlank() }?.let { "<p>$it</p>" } ?: ""
                    val imagePart = """<img src="$imgSrc"/>"""
                    htmlTemplate.replace("%s", textPart + imagePart)
                }

                Type.VIDEO -> {
                    val textPart = articleContent ?: description.takeIf { it.isNotBlank() }?.let { "<p>$it</p>" } ?: ""
                    val embedPart = embed ?: ""
                    val content = textPart + embedPart
                    if (content.isNotEmpty()) htmlTemplate.replace("%s", content) else null
                }

                Type.ARTICLE -> {
                    articleContent?.let {
                        htmlTemplate.replace("%s", it)
                    }
                }
            }
        }
    }

    sealed class UpdateBookmarkState {
        data object Success : UpdateBookmarkState()
        data class Error(val message: String) : UpdateBookmarkState()
    }

    private fun buildDebugInfo(bookmark: com.mydeck.app.domain.model.Bookmark): String {
        return buildString {
            appendLine("=== BOOKMARK DEBUG INFO ===")
            appendLine()
            appendLine("ID: ${bookmark.id}")
            appendLine("State: ${bookmark.state}")
            appendLine("Loaded: ${bookmark.loaded}")
            appendLine("Has Article: ${bookmark.hasArticle}")
            appendLine("Is Deleted: ${bookmark.isDeleted}")
            appendLine()
            appendLine("Timestamps:")
            appendLine("  Created: ${bookmark.created}")
            appendLine("  Updated: ${bookmark.updated}")
            appendLine("  Published: ${bookmark.published ?: "N/A"}")
            appendLine()
            appendLine("URLs & Resources:")
            appendLine("  URL: ${bookmark.url}")
            appendLine("  HREF: ${bookmark.href}")
            appendLine("  Site: ${bookmark.site}")
            appendLine("  Site Name: ${bookmark.siteName}")
            appendLine("  Article Resource: ${bookmark.article.src}")
            appendLine("  Icon: ${bookmark.icon.src} (${bookmark.icon.width}x${bookmark.icon.height})")
            appendLine("  Image: ${bookmark.image.src} (${bookmark.image.width}x${bookmark.image.height})")
            appendLine("  Thumbnail: ${bookmark.thumbnail.src} (${bookmark.thumbnail.width}x${bookmark.thumbnail.height})")
            appendLine("  Log: ${bookmark.log.src}")
            appendLine("  Props: ${bookmark.props.src}")
            appendLine()
            appendLine("Content Info:")
            appendLine("  Type: ${bookmark.type}")
            appendLine("  Document Type: ${bookmark.documentTpe}")
            appendLine("  Language: ${bookmark.lang}")
            appendLine("  Text Direction: ${bookmark.textDirection}")
            appendLine("  Word Count: ${bookmark.wordCount ?: "N/A"}")
            appendLine("  Reading Time: ${bookmark.readingTime ?: "N/A"} min")
            appendLine("  Read Progress: ${bookmark.readProgress}%")
            appendLine("  Embed: ${bookmark.embed ?: "N/A"}")
            appendLine("  Embed Hostname: ${bookmark.embedHostname ?: "N/A"}")
            appendLine("  Has Article Content: ${bookmark.articleContent != null}")
            if (bookmark.articleContent != null) {
                appendLine("  Article Content Length: ${bookmark.articleContent.length} chars")
            }
            appendLine()
            appendLine("Metadata:")
            appendLine("  Authors: ${if (bookmark.authors.isEmpty()) "None" else bookmark.authors.joinToString(", ")}")
            appendLine("  Labels: ${if (bookmark.labels.isEmpty()) "None" else bookmark.labels.joinToString(", ")}")
            appendLine("  Is Marked: ${bookmark.isMarked}")
            appendLine("  Is Archived: ${bookmark.isArchived}")
            appendLine()
            if (bookmark.description.isNotBlank()) {
                appendLine("Description:")
                appendLine(bookmark.description)
            }
        }
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/domain/BookmarkRepositoryImpl.kt">
package com.mydeck.app.domain

import androidx.work.Constraints
import androidx.work.Data
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import com.mydeck.app.coroutine.ApplicationScope
import com.mydeck.app.coroutine.IoDispatcher
import com.mydeck.app.domain.mapper.toDomain
import com.mydeck.app.domain.mapper.toEntity
import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.BookmarkCounts
import com.mydeck.app.domain.model.BookmarkListItem
import com.mydeck.app.io.db.dao.BookmarkDao
import com.mydeck.app.io.db.model.BookmarkEntity
import com.mydeck.app.io.db.model.RemoteBookmarkIdEntity
import com.mydeck.app.io.rest.ReadeckApi
import com.mydeck.app.io.rest.model.CreateBookmarkDto
import com.mydeck.app.io.rest.model.EditBookmarkDto
import com.mydeck.app.io.rest.model.EditBookmarkErrorDto
import com.mydeck.app.io.rest.model.StatusMessageDto
import com.mydeck.app.io.rest.model.SyncContentRequestDto
import com.mydeck.app.worker.LoadArticleWorker
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import kotlinx.serialization.SerializationException
import kotlinx.serialization.json.Json
import timber.log.Timber
import java.io.IOException
import javax.inject.Inject

class BookmarkRepositoryImpl @Inject constructor(
    private val bookmarkDao: BookmarkDao,
    private val readeckApi: ReadeckApi,
    private val json: Json,
    private val workManager: WorkManager,
    @ApplicationScope
    private val applicationScope: CoroutineScope,
    @IoDispatcher
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) : BookmarkRepository {
    override fun observeBookmarks(
        type: Bookmark.Type?,
        unread: Boolean?,
        archived: Boolean?,
        favorite: Boolean?,
        state: Bookmark.State?
    ): Flow<List<Bookmark>> {
        return bookmarkDao.getBookmarksByFilters(
            type = type?.let {
                when (it) {
                    Bookmark.Type.Article -> BookmarkEntity.Type.ARTICLE
                    Bookmark.Type.Picture -> BookmarkEntity.Type.PHOTO
                    Bookmark.Type.Video -> BookmarkEntity.Type.VIDEO
                }
            },
            isUnread = unread,
            isArchived = archived,
            isFavorite = favorite,
            state = state?.let {
                when (it) {
                    Bookmark.State.LOADED -> BookmarkEntity.State.LOADED
                    Bookmark.State.ERROR -> BookmarkEntity.State.ERROR
                    Bookmark.State.LOADING -> BookmarkEntity.State.LOADING
                }
            }
        ).map { bookmarks -> bookmarks.map { it.toDomain() } }
    }

    override fun observeBookmarkListItems(
        type: Bookmark.Type?,
        unread: Boolean?,
        archived: Boolean?,
        favorite: Boolean?,
        label: String?,
        state: Bookmark.State?,
        orderBy: String
    ): Flow<List<BookmarkListItem>> {
        return bookmarkDao.getBookmarkListItemsByFilters(
            type = type?.let {
                when (it) {
                    Bookmark.Type.Article -> BookmarkEntity.Type.ARTICLE
                    Bookmark.Type.Picture -> BookmarkEntity.Type.PHOTO
                    Bookmark.Type.Video -> BookmarkEntity.Type.VIDEO
                }
            },
            isUnread = unread,
            isArchived = archived,
            isFavorite = favorite,
            label = label,
            state = state?.let {
                when (it) {
                    Bookmark.State.LOADED -> BookmarkEntity.State.LOADED
                    Bookmark.State.ERROR -> BookmarkEntity.State.ERROR
                    Bookmark.State.LOADING -> BookmarkEntity.State.LOADING
                }
            },
            orderBy = orderBy
        ).map { listItems ->
            listItems.map { listItem ->
                BookmarkListItem(
                    id = listItem.id,
                    url = listItem.url,
                    title = listItem.title,
                    siteName = listItem.siteName,
                    isMarked = listItem.isMarked,
                    isArchived = listItem.isArchived,
                    isRead = listItem.readProgress == 100,
                    readProgress = listItem.readProgress,
                    thumbnailSrc = listItem.thumbnailSrc,
                    iconSrc = listItem.iconSrc,
                    imageSrc = listItem.imageSrc,
                    labels = listItem.labels,
                    type = when (listItem.type) {
                        BookmarkEntity.Type.ARTICLE -> Bookmark.Type.Article
                        BookmarkEntity.Type.PHOTO -> Bookmark.Type.Picture
                        BookmarkEntity.Type.VIDEO -> Bookmark.Type.Video
                    },
                    readingTime = listItem.readingTime,
                    created = listItem.created.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault()),
                    wordCount = listItem.wordCount,
                    published = listItem.published?.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault())
                )
            }
        }
    }

    override fun searchBookmarkListItems(
        searchQuery: String,
        type: Bookmark.Type?,
        unread: Boolean?,
        archived: Boolean?,
        favorite: Boolean?,
        label: String?,
        state: Bookmark.State?,
        orderBy: String
    ): Flow<List<BookmarkListItem>> {
        return bookmarkDao.searchBookmarkListItems(
            searchQuery = searchQuery,
            type = type?.let {
                when (it) {
                    Bookmark.Type.Article -> BookmarkEntity.Type.ARTICLE
                    Bookmark.Type.Picture -> BookmarkEntity.Type.PHOTO
                    Bookmark.Type.Video -> BookmarkEntity.Type.VIDEO
                }
            },
            isUnread = unread,
            isArchived = archived,
            isFavorite = favorite,
            label = label,
            state = state?.let {
                when (it) {
                    Bookmark.State.LOADED -> BookmarkEntity.State.LOADED
                    Bookmark.State.ERROR -> BookmarkEntity.State.ERROR
                    Bookmark.State.LOADING -> BookmarkEntity.State.LOADING
                }
            },
            orderBy = orderBy
        ).map { listItems ->
            listItems.map { listItem ->
                BookmarkListItem(
                    id = listItem.id,
                    url = listItem.url,
                    title = listItem.title,
                    siteName = listItem.siteName,
                    isMarked = listItem.isMarked,
                    isArchived = listItem.isArchived,
                    isRead = listItem.readProgress == 100,
                    readProgress = listItem.readProgress,
                    thumbnailSrc = listItem.thumbnailSrc,
                    iconSrc = listItem.iconSrc,
                    imageSrc = listItem.imageSrc,
                    labels = listItem.labels,
                    type = when (listItem.type) {
                        BookmarkEntity.Type.ARTICLE -> Bookmark.Type.Article
                        BookmarkEntity.Type.PHOTO -> Bookmark.Type.Picture
                        BookmarkEntity.Type.VIDEO -> Bookmark.Type.Video
                    },
                    readingTime = listItem.readingTime,
                    created = listItem.created.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault()),
                    wordCount = listItem.wordCount,
                    published = listItem.published?.toLocalDateTime(kotlinx.datetime.TimeZone.currentSystemDefault())
                )
            }
        }
    }

    override suspend fun insertBookmarks(bookmarks: List<Bookmark>) {
        bookmarkDao.insertBookmarksWithArticleContent(bookmarks.map { it.toEntity() })
    }

    override suspend fun getBookmarkById(id: String): Bookmark {
        return bookmarkDao.getBookmarkById(id).toDomain()
    }

    override suspend fun refreshBookmarkFromApi(id: String) {
        withContext(dispatcher) {
            try {
                val response = readeckApi.getBookmarkById(id)
                if (response.isSuccessful && response.body() != null) {
                    val bookmark = response.body()!!.toDomain()
                    insertBookmarks(listOf(bookmark))
                    Timber.d("Refreshed bookmark from API: $id")
                }
            } catch (e: Exception) {
                Timber.w(e, "Failed to refresh bookmark from API: $id")
            }
        }
    }

    override fun observeBookmark(id: String): Flow<Bookmark?> {
        return bookmarkDao.observeBookmarkWithArticleContent(id).map {
            it?.let {
                it.bookmark.toDomain().copy(articleContent = it.articleContent?.content)
            }
        }
    }

    override suspend fun deleteAllBookmarks() {
        bookmarkDao.deleteAllBookmarks()
    }

    override suspend fun createBookmark(title: String, url: String, labels: List<String>): String {
        val createBookmarkDto = CreateBookmarkDto(labels = labels, title = title, url = url)
        val response = readeckApi.createBookmark(createBookmarkDto)
        if (!response.isSuccessful) {
            throw Exception("Failed to create bookmark")
        }

        val bookmarkId = response.headers()[ReadeckApi.Header.BOOKMARK_ID]!!

        // Fetch and insert bookmark metadata
        try {
            val bookmarkResponse = readeckApi.getBookmarkById(bookmarkId)
            if (bookmarkResponse.isSuccessful && bookmarkResponse.body() != null) {
                val bookmark = bookmarkResponse.body()!!.toDomain()
                insertBookmarks(listOf(bookmark))
                Timber.d("Bookmark created and inserted locally: $bookmarkId")

                // If not yet loaded, poll in the background
                if (bookmark.state == Bookmark.State.LOADING) {
                    pollForBookmarkReady(bookmarkId)
                } else if (bookmark.hasArticle) {
                    // Content available, enqueue download
                    enqueueArticleDownload(bookmarkId)
                }
            }
        } catch (e: Exception) {
            Timber.w(e, "Failed to fetch and insert created bookmark")
        }

        return bookmarkId
    }

    private fun pollForBookmarkReady(bookmarkId: String) {
        // Launch in application scope so it survives navigation
        applicationScope.launch {
            var attempts = 0
            val maxAttempts = 30
            val delayMs = 2000L

            while (attempts < maxAttempts) {
                delay(delayMs)
                attempts++

                try {
                    val response = readeckApi.getBookmarkById(bookmarkId)
                    if (response.isSuccessful && response.body() != null) {
                        val bookmark = response.body()!!.toDomain()
                        insertBookmarks(listOf(bookmark))  // Update local metadata

                        when (bookmark.state) {
                            Bookmark.State.LOADED -> {
                                Timber.d("Bookmark loaded after $attempts polls: $bookmarkId")
                                if (bookmark.hasArticle) {
                                    enqueueArticleDownload(bookmarkId)
                                }
                                return@launch  // Done
                            }
                            Bookmark.State.ERROR -> {
                                Timber.w("Bookmark extraction failed: $bookmarkId")
                                return@launch  // Done (with error)
                            }
                            else -> { /* still loading, continue polling */ }
                        }
                    }
                } catch (e: Exception) {
                    Timber.w(e, "Poll attempt $attempts failed for $bookmarkId")
                }
            }

            Timber.w("Polling timed out for bookmark $bookmarkId after $maxAttempts attempts")
        }
    }

    private fun enqueueArticleDownload(bookmarkId: String) {
        val request = OneTimeWorkRequestBuilder<LoadArticleWorker>()
            .setInputData(
                Data.Builder()
                    .putString(LoadArticleWorker.PARAM_BOOKMARK_ID, bookmarkId)
                    .build()
            )
            .setConstraints(
                Constraints.Builder()
                    .setRequiredNetworkType(NetworkType.CONNECTED)
                    .build()
            )
            .build()
        workManager.enqueue(request)
        Timber.d("Article download enqueued for bookmark: $bookmarkId")
    }

    override suspend fun updateBookmark(
        bookmarkId: String,
        isFavorite: Boolean?,
        isArchived: Boolean?,
        isRead: Boolean?
    ): BookmarkRepository.UpdateResult {
        return withContext(dispatcher) {
            try {
                val response =
                    readeckApi.editBookmark(
                        id = bookmarkId,
                        body = EditBookmarkDto(
                            isMarked = isFavorite,
                            isArchived = isArchived,
                            readProgress = isRead?.let { if (it) 100 else 0 }
                        )
                    )
                if (response.isSuccessful) {
                    // Update local database to reflect the change immediately
                    isFavorite?.let { bookmarkDao.updateIsMarked(bookmarkId, it) }
                    isArchived?.let { bookmarkDao.updateIsArchived(bookmarkId, it) }
                    isRead?.let { bookmarkDao.updateReadProgress(bookmarkId, if (it) 100 else 0) }
                    Timber.i("Update Bookmark successful")
                    BookmarkRepository.UpdateResult.Success
                } else {
                    val code = response.code()
                    val errorBodyString = response.errorBody()?.string()
                    Timber.w("Error while Update Bookmark [code=$code, body=$errorBodyString]")
                    when (code) {
                        422 -> {
                            if (!errorBodyString.isNullOrBlank()) {
                                try {
                                    json.decodeFromString<EditBookmarkErrorDto>(errorBodyString)
                                        .let {
                                            BookmarkRepository.UpdateResult.Error(
                                                it.errors.toString(),
                                                response.code()
                                            )
                                        }
                                } catch (e: SerializationException) {
                                    Timber.e(e, "Failed to parse error: ${e.message}")
                                    BookmarkRepository.UpdateResult.Error(
                                        errorMessage = "Failed to parse error: ${e.message}",
                                        code = response.code(),
                                        ex = e
                                    )
                                }
                            } else {
                                Timber.e("Empty error body")
                                BookmarkRepository.UpdateResult.Error(
                                    errorMessage = "Empty error body",
                                    code = code
                                )
                            }
                        }

                        else -> {
                            val errorState = handleStatusMessage(response.code(), errorBodyString)
                            BookmarkRepository.UpdateResult.Error(
                                errorMessage = errorState.message,
                                code = errorState.status
                            )
                        }
                    }
                }
            } catch (e: IOException) {
                Timber.e(e, "Network error while Update Bookmark: ${e.message}")
                BookmarkRepository.UpdateResult.NetworkError("Network error: ${e.message}", ex = e)
            } catch (e: Exception) {
                Timber.e(e, "Unexpected error while Update Bookmark: ${e.message}")
                BookmarkRepository.UpdateResult.Error(
                    "An unexpected error occurred: ${e.message}",
                    ex = e
                )
            }
        }
    }

    override suspend fun deleteBookmark(id: String): BookmarkRepository.UpdateResult {
        return withContext(dispatcher) {
            try {
                val response =
                    readeckApi.deleteBookmark(id = id)
                if (response.isSuccessful) {
                    bookmarkDao.deleteBookmark(id)
                    Timber.i("Delete Bookmark successful")
                    BookmarkRepository.UpdateResult.Success
                } else {
                    val code = response.code()
                    val errorBodyString = response.errorBody()?.string()
                    Timber.w("Error while Delete Bookmark [code=$code, body=$errorBodyString]")
                    val errorState = handleStatusMessage(code, errorBodyString)
                    BookmarkRepository.UpdateResult.Error(
                        errorMessage = errorState.message,
                        code = errorState.status
                    )
                }
            } catch (e: IOException) {
                Timber.e(e, "Network error while Delete Bookmark: ${e.message}")
                BookmarkRepository.UpdateResult.NetworkError("Network error: ${e.message}", ex = e)
            } catch (e: Exception) {
                Timber.e(e, "Unexpected error while Delete Bookmark: ${e.message}")
                BookmarkRepository.UpdateResult.Error(
                    "An unexpected error occurred: ${e.message}",
                    ex = e
                )
            }
        }
    }

    override suspend fun updateLabels(
        bookmarkId: String,
        labels: List<String>
    ): BookmarkRepository.UpdateResult {
        return withContext(dispatcher) {
            try {
                // Get current labels to calculate diff
                val currentBookmark = bookmarkDao.getBookmarkById(bookmarkId)
                val currentLabels = currentBookmark.labels

                // Calculate added and removed labels
                val addedLabels = labels.filter { !currentLabels.contains(it) }
                val removedLabels = currentLabels.filter { !labels.contains(it) }

                val response = readeckApi.editBookmark(
                    id = bookmarkId,
                    body = EditBookmarkDto(
                        addLabels = addedLabels.ifEmpty { null },
                        removeLabels = removedLabels.ifEmpty { null }
                    )
                )

                if (response.isSuccessful) {
                    // Update local database with new labels
                    val labelsString = labels.joinToString(",")
                    bookmarkDao.updateLabels(bookmarkId, labelsString)
                    Timber.i("Update Labels successful")
                    BookmarkRepository.UpdateResult.Success
                } else {
                    val code = response.code()
                    val errorBodyString = response.errorBody()?.string()
                    Timber.w("Error while Update Labels [code=$code, body=$errorBodyString]")
                    val errorState = handleStatusMessage(code, errorBodyString)
                    BookmarkRepository.UpdateResult.Error(
                        errorMessage = errorState.message,
                        code = errorState.status
                    )
                }
            } catch (e: IOException) {
                Timber.e(e, "Network error while Update Labels: ${e.message}")
                BookmarkRepository.UpdateResult.NetworkError("Network error: ${e.message}", ex = e)
            } catch (e: Exception) {
                Timber.e(e, "Unexpected error while Update Labels: ${e.message}")
                BookmarkRepository.UpdateResult.Error(
                    "An unexpected error occurred: ${e.message}",
                    ex = e
                )
            }
        }
    }

    override suspend fun updateReadProgress(
        bookmarkId: String,
        progress: Int
    ): BookmarkRepository.UpdateResult {
        return withContext(dispatcher) {
            try {
                val response = readeckApi.editBookmark(
                    id = bookmarkId,
                    body = EditBookmarkDto(
                        readProgress = progress.coerceIn(0, 100)
                    )
                )

                if (response.isSuccessful) {
                    // Update local database with new progress
                    bookmarkDao.updateReadProgress(bookmarkId, progress.coerceIn(0, 100))
                    Timber.i("Update Read Progress successful")
                    BookmarkRepository.UpdateResult.Success
                } else {
                    val code = response.code()
                    val errorBodyString = response.errorBody()?.string()
                    Timber.w("Error while Update Read Progress [code=$code, body=$errorBodyString]")
                    val errorState = handleStatusMessage(code, errorBodyString)
                    BookmarkRepository.UpdateResult.Error(
                        errorMessage = errorState.message,
                        code = errorState.status
                    )
                }
            } catch (e: IOException) {
                Timber.e(e, "Network error while Update Read Progress: ${e.message}")
                BookmarkRepository.UpdateResult.NetworkError("Network error: ${e.message}", ex = e)
            } catch (e: Exception) {
                Timber.e(e, "Unexpected error while Update Read Progress: ${e.message}")
                BookmarkRepository.UpdateResult.Error(
                    "An unexpected error occurred: ${e.message}",
                    ex = e
                )
            }
        }
    }

    private fun handleStatusMessage(code: Int, errorBody: String?): StatusMessageDto {
        return if (!errorBody.isNullOrBlank()) {
            try {
                json.decodeFromString<StatusMessageDto>(errorBody)
            } catch (e: SerializationException) {
                Timber.e(e, "Failed to parse error: ${e.message}")
                StatusMessageDto(
                    status = code,
                    message = "Failed to parse error: ${e.message}"
                )
            }
        } else {
            Timber.e("Empty error body")
            StatusMessageDto(
                status = code,
                message = "Empty error body"
            )
        }
    }

    override suspend fun performFullSync(): BookmarkRepository.SyncResult = withContext(dispatcher) {
        try {
            bookmarkDao.clearRemoteBookmarkIds() // Clear any previous sync data

            val pageSize = 50
            var offset = 0
            var hasMore = true

            while (hasMore) {
                val response = readeckApi.getBookmarks(limit = pageSize, offset = offset, updatedSince = null, ReadeckApi.SortOrder(ReadeckApi.Sort.Created))

                if (response.isSuccessful) {
                    val remoteBookmarks = response.body() ?: emptyList()
                    Timber.d("Fetched ${remoteBookmarks.size} remote bookmarks (offset=$offset)")

                    val totalCountHeader = response.headers()[ReadeckApi.Header.TOTAL_COUNT]
                    val totalPagesHeader = response.headers()[ReadeckApi.Header.TOTAL_PAGES]
                    val currentPageHeader = response.headers()[ReadeckApi.Header.CURRENT_PAGE]

                    if (totalCountHeader == null || totalPagesHeader == null || currentPageHeader == null) {
                        return@withContext BookmarkRepository.SyncResult.Error("Missing headers in API response")
                    }

                    val totalCount = totalCountHeader.toInt()
                    val totalPages = totalPagesHeader.toInt()
                    val currentPage = currentPageHeader.toInt()

                    Timber.d("currentPage=$currentPage")
                    Timber.d("totalPages=$totalPages")
                    Timber.d("totalCount=$totalCount")

                    // Save remote bookmark IDs to the temporary table
                    val remoteBookmarkIdEntities = remoteBookmarks.map { RemoteBookmarkIdEntity(it.id) }
                    bookmarkDao.insertRemoteBookmarkIds(remoteBookmarkIdEntities)

                    if (currentPage < totalPages) {
                        offset += pageSize
                    } else {
                        hasMore = false
                    }
                } else {
                    Timber.e("Full sync failed at offset=$offset with code: ${response.code()}")
                    return@withContext BookmarkRepository.SyncResult.Error(
                        errorMessage = "Full sync failed",
                        code = response.code(),
                        ex = null
                    )
                }
            }

            // After fetching all remote IDs, find local bookmarks to delete
            val deleted = bookmarkDao.removeDeletedBookmars()
            Timber.i("Deleted bookmarks: $deleted")

            bookmarkDao.clearRemoteBookmarkIds() // Clean up the temporary table

            BookmarkRepository.SyncResult.Success(countDeleted = deleted)
        } catch (e: Exception) {
            Timber.e(e, "Full sync failed")
            BookmarkRepository.SyncResult.NetworkError(errorMessage = "Network error during full sync", ex = e)
        }
    }

    override suspend fun performDeltaSync(since: kotlinx.datetime.Instant?): BookmarkRepository.SyncResult = withContext(dispatcher) {
        // DEPRECATED: The /api/bookmarks/sync endpoint has a server-side bug with SQLite.
        // This method is kept for future use if/when the server bug is fixed.
        // For now, always return an error to trigger fallback to full sync.
        Timber.w("Delta sync is disabled due to server-side SQLite compatibility issue")
        return@withContext BookmarkRepository.SyncResult.Error(
            errorMessage = "Delta sync disabled - server endpoint incompatible with SQLite",
            code = 500
        )
    }

    override fun observeAllBookmarkCounts(): Flow<BookmarkCounts> {
        return bookmarkDao.observeAllBookmarkCounts().map { entity ->
            if (entity != null) {
                BookmarkCounts(
                    unread = entity.unread,
                    archived = entity.archived,
                    favorite = entity.favorite,
                    article = entity.article,
                    video = entity.video,
                    picture = entity.picture,
                    total = entity.total
                )
            } else {
                BookmarkCounts()
            }
        }
    }

    override fun observeAllLabelsWithCounts(): Flow<Map<String, Int>> =
        bookmarkDao.observeAllLabels().map { labelsStringList ->
            val labelCounts = mutableMapOf<String, Int>()

            // Parse each labels string and count occurrences
            for (labelsString in labelsStringList) {
                if (labelsString.isNotEmpty()) {
                    // Split by comma to get individual labels
                    val labels = labelsString.split(",").map { it.trim() }.filter { it.isNotEmpty() }
                    for (label in labels) {
                        labelCounts[label] = (labelCounts[label] ?: 0) + 1
                    }
                }
            }

            labelCounts.toMap()
        }

    override suspend fun renameLabel(oldLabel: String, newLabel: String): BookmarkRepository.UpdateResult =
        withContext(dispatcher) {
            try {
                // Get all bookmarks with the old label
                val bookmarksWithContent = bookmarkDao.getAllBookmarksWithContent()
                    .filter { bookmark ->
                        bookmark.bookmark.labels.contains(oldLabel)
                    }

                // Update each bookmark by replacing the old label with the new one
                for (bookmarkWithContent in bookmarksWithContent) {
                    val bookmark = bookmarkWithContent.bookmark
                    val updatedLabels = bookmark.labels.map { label ->
                        if (label == oldLabel) newLabel else label
                    }

                    // Update locally (use targeted UPDATE to avoid CASCADE DELETE from REPLACE)
                    bookmarkDao.updateLabels(bookmark.id, updatedLabels.joinToString(","))

                    // Update on server - use addLabels and removeLabels
                    try {
                        val response = readeckApi.editBookmark(
                            id = bookmark.id,
                            body = EditBookmarkDto(
                                addLabels = listOf(newLabel),
                                removeLabels = listOf(oldLabel)
                            )
                        )

                        if (!response.isSuccessful) {
                            return@withContext BookmarkRepository.UpdateResult.Error(
                                errorMessage = "Failed to rename label on server",
                                code = response.code()
                            )
                        }
                    } catch (e: Exception) {
                        Timber.e(e, "Error renaming label on server")
                        // Continue with other bookmarks
                    }
                }

                BookmarkRepository.UpdateResult.Success
            } catch (e: Exception) {
                Timber.e(e, "Error renaming label")
                BookmarkRepository.UpdateResult.NetworkError(
                    errorMessage = "Network error while renaming label",
                    ex = e
                )
            }
        }

    override suspend fun deleteLabel(label: String): BookmarkRepository.UpdateResult =
        withContext(dispatcher) {
            try {
                // Get all bookmarks with the label
                val bookmarksWithContent = bookmarkDao.getAllBookmarksWithContent()
                    .filter { bookmark ->
                        bookmark.bookmark.labels.contains(label)
                    }

                // Update each bookmark by removing the label
                for (bookmarkWithContent in bookmarksWithContent) {
                    val bookmark = bookmarkWithContent.bookmark
                    val updatedLabels = bookmark.labels.filter { it != label }

                    // Update locally (use targeted UPDATE to avoid CASCADE DELETE from REPLACE)
                    bookmarkDao.updateLabels(bookmark.id, updatedLabels.joinToString(","))

                    // Update on server - use removeLabels
                    try {
                        val response = readeckApi.editBookmark(
                            id = bookmark.id,
                            body = EditBookmarkDto(
                                removeLabels = listOf(label)
                            )
                        )

                        if (!response.isSuccessful) {
                            return@withContext BookmarkRepository.UpdateResult.Error(
                                errorMessage = "Failed to delete label on server",
                                code = response.code()
                            )
                        }
                    } catch (e: Exception) {
                        Timber.e(e, "Error deleting label on server")
                        // Continue with other bookmarks
                    }
                }

                BookmarkRepository.UpdateResult.Success
            } catch (e: Exception) {
                Timber.e(e, "Error deleting label")
                BookmarkRepository.UpdateResult.NetworkError(
                    errorMessage = "Network error while deleting label",
                    ex = e
                )
            }
        }
}
</file>

<file path="app/src/main/res/values/strings.xml">
<resources>
    <string name="app_name">MyDeck</string>
    <string name="back">Back</string>
    <string name="settings_topbar_title">Settings</string>
    <string name="settings_account_title">Account</string>
    <string name="settings_account_subtitle_default">Not logged in</string>
    <string name="accountsettings_topbar_title">Account</string>
    <string name="account_settings_topbar_title">Readeck URL</string>
    <string name="account_settings_url_placeholder">https://readeck.example.com/api</string>
    <string name="account_settings_url_label">Readeck URL</string>
    <string name="account_settings_username_placeholder">email@example.com</string>
    <string name="account_settings_username_label">Email Address</string>
    <string name="account_settings_password_label">Password</string>
    <string name="account_settings_password_placeholder">password</string>
    <string name="account_settings_login">Login</string>
    <string name="account_settings_url_error">Invalid URL</string>
    <string name="account_settings_username_error">Email address cannot be empty</string>
    <string name="account_settings_password_error">Password cannot be empty</string>
    <string name="account_settings_allow_unencrypted">Allow unencrypted connections</string>
    <string name="account_settings_sign_out_warning">Signing out will clear all local data including saved bookmarks.</string>
    <string name="account_settings_sign_out">Sign Out</string>
    <string name="account_settings_sign_out_confirm_title">Sign out?</string>
    <string name="account_settings_sign_out_confirm_message">This will clear all local data including saved bookmarks.</string>
    <string name="sync_settings_topbar_title">Synchronization Settings</string>
    <string name="authors" translatable="true">
{count, plural,
zero{}
one{from {author}}
many{from {author} et. al.}
other{}
}
    </string>
    <string name="settings_open_source_libraries">Open Source Libraries</string>
    <string name="settings_open_source_libraries_subtitle">View the open source libraries used in this app.</string>
    <string name="bookmarks">Bookmarks</string>
    <string name="menu">Menu</string>
    <string name="refresh_bookmarks">Refresh Bookmarks</string>
    <string name="all">All</string>
    <string name="my_list">My List</string>
    <string name="archive">Archive</string>
    <string name="favorites">Favorites</string>
    <string name="articles">Articles</string>
    <string name="videos">Videos</string>
    <string name="pictures">Pictures</string>
    <string name="labels">Labels</string>
    <string name="settings">Settings</string>
    <string name="an_error_occurred">An error occurred.</string>
    <string name="no_bookmarks_found">No bookmarks found.</string>
    <string name="add_bookmark">Add Bookmark</string>
    <string name="title">Title (Optional)</string>
    <string name="url">URL</string>
    <string name="invalid_url">Invalid URL</string>
    <string name="save">Save</string>
    <string name="cancel">Cancel</string>
    <string name="retry">Retry</string>
    <string name="webview_error_title">Unable to load page</string>
    <string name="webview_error_message">The page could not be loaded (HTTP %1$d)</string>
    <string name="create_bookmark_error">Error creating bookmark: %1$s</string>
    <string name="add_new_bookmark">Add New Bookmark</string>
    <string name="create">Create</string>
    <string name="error">Error</string>
    <string name="ok">OK</string>
    <string name="not_valid_url">Not a valid URL</string>
    <string name="log_view_title">Logs</string>
    <string name="log_view_send_logs">Send Logs</string>
    <string name="settings_logs">Logs</string>
    <string name="settings_logs_subtitle">View and Send Logfiles</string>
    <string name="log_view_share_title">Send Logs</string>
    <string name="log_view_no_log_file_found">No log file found</string>
    <string name="log_view_refresh">Refresh Logs</string>
    <string name="log_view_clear_logs">Clear Logs</string>
    <string name="log_view_logs_cleared">Logs cleared</string>
    <string name="settings_sync">Synchronization</string>
    <string name="settings_sync_subtitle">Synchronization Settings</string>
    <string name="settings_ui">User Interface</string>
    <string name="settings_ui_subtitle">Appearance</string>
    <string name="ui_settings_topbar_title">User Interface Settings</string>
    <string name="ui_settings_theme_title">Theme</string>
    <string name="theme_system">System default</string>
    <string name="theme_light">Light</string>
    <string name="theme_dark">Dark</string>
    <string name="theme_sepia">Sepia</string>
    <string name="ui_settings_theme_heading">Theming</string>
    <string name="ui_settings_theme_dialog_support_text">Which theme should be used?</string>

    <!-- Bookmark Card Actions -->
    <string name="action_favorite">Favorite</string>
    <string name="action_archive">Archive</string>
    <string name="action_mark_read">Read</string>
    <string name="action_mark_unread">Unread</string>
    <string name="action_share">Share link</string>
    <string name="action_delete">Delete</string>
    <string name="action_open_in_browser">Open in browser</string>
    <string name="action_view_original">View Original</string>
    <string name="action_view_article">View Article</string>
    <string name="action_view_photo">View Photo</string>
    <string name="action_view_video">View Video</string>
    <string name="action_increase_text_size">Increase text size</string>
    <string name="action_decrease_text_size">Decrease text size</string>
    <string name="error_no_article_content">Error, article content not available</string>
    <string name="update_successful">Update successful</string>
    <string name="notification_channel_sync_name">Synchronization Errors</string>
    <string name="notification_channel_sync_description">Errors in synchronization</string>
    <string name="notification_authentication_error_title">Authentication Required</string>
    <string name="notification_authentication_error_message">Please validate your credentials.</string>
    <string name="detail_view_no_content">No article content found</string>
    <string name="common_bookmark_image_content_description">Bookmark Image</string>
    <string name="settings_sync_full_sync_heading">Background Synchronization</string>
    <string name="settings_sync_auto_full_sync_title">Background Synchronization</string>
    <string name="settings_sync_auto_full_button">Synchronize now</string>
    <string name="settings_sync_support_text">To keep your bookmark list up-to-date, the app periodically syncs with the Readeck server to detect new, updated, and deleted bookmarks. Article content is downloaded in the background for offline reading.\n\nYou can manually sync on the list page to refresh from server, too, but would need to use \'Synchronize now\' button to sync deletes from the server.</string>
    <string name="settings_sync_dialog_support_text">How often should the synchronization be performed in the background?</string>
    <string name="auto_sync_timeframe_label">Schedule</string>
    <string name="auto_sync_timeframe_manual">Manual</string>>
    <string name="auto_sync_timeframe_01_hours">Every hour</string>
    <string name="auto_sync_timeframe_06_hours">Every 6 hours</string>
    <string name="auto_sync_timeframe_12_hours">Every 12 hours</string>
    <string name="auto_sync_timeframe_07_days">Every 7 days</string>
    <string name="auto_sync_timeframe_01_days">Once a day</string>
    <string name="auto_sync_timeframe_14_days">Every 14 days</string>
    <string name="auto_sync_timeframe_30_days">Every 30 days</string>
    <string name="auto_sync_next_run">Next synchronization on %1$s</string>
    <string name="auto_sync_next_run_null">No synchronization scheduled</string>
    <string name="auto_sync_notification_success">Synchronization successful</string>
    <string name="auto_sync_notification_failure">Synchronization failed</string>
    <string name="auto_sync_notification_running">Background synchronization running.</string>
    <string name="auto_sync_notification_channel">Background Synchronization</string>
    <string name="auto_sync_notification_rationale_dialog_title">Notification Permission Required</string>
    <string name="auto_sync_notification_rationale_dialog_text">To notify you about background sync failures, we need permission to send notifications.  Please grant this permission.</string>
    <string name="auto_sync_notification_rationale_dialog_grant_button">Grant Permission</string>
    <string name="settings_sync_on_app_open_title">Sync on App Open</string>
    <string name="settings_sync_on_app_open_subtitle">Automatically sync when the app is opened</string>
    <string name="settings_sync_notifications_title">Sync Notifications</string>
    <string name="settings_sync_notifications_subtitle">Show notifications for background sync results</string>
    <string name="sync_status_heading">Sync Status</string>
    <string name="sync_status_bookmarks">Bookmarks with content: %1$d / %2$d</string>
    <string name="sync_status_last_sync">Last sync: %1$s</string>
    <string name="sync_status_never">Last sync: Never</string>
    <string name="list_view_empty_not_loaded_yet">Bookmarks have not been loaded yet.</string>
    <string name="list_view_empty_error_loading_bookmarks">An error has occurred while loading bookmarks.</string>
    <string name="list_view_empty_nothing_to_see">No bookmarks have been found.</string>
    <string name="about_title">About</string>
    <string name="about_version">Version %s</string>
    <string name="about_description">A read-later app for Readeck with a Pocket-like experience</string>
    <string name="about_credits_title">Credits</string>
    <string name="about_credits_app_author">MyDeck by Nate Eaton</string>
    <string name="about_credits_readeck">Readeck server by Franois Revol and contributors</string>
    <string name="about_credits_fork">This is a fork of ReadeckApp by jensomato, reimagined with a Pocket-like user experience.</string>
    <string name="about_system_info_title">System Info</string>
    <string name="about_system_info_version">Version %1$s (%2$d)</string>
    <string name="about_system_info_build_time">Built: %s</string>
    <string name="about_system_info_android">Android %1$s (API %2$d)</string>
    <string name="about_system_info_device">Device: %1$s %2$s</string>
    <string name="about_project_title">Project</string>
    <string name="about_project_this_repo">MyDeck Repository (Fork)</string>
    <string name="about_project_original_repo">Original ReadeckApp Repository</string>
    <string name="about_project_readeck_repo">Readeck Server</string>
    <string name="about_license_title">License</string>
    <string name="about_license_text">MyDeck is licensed under the GNU General Public License v3 (GPLv3). Source code is available on GitHub.</string>
    <string name="about_license_readeck">Readeck server is licensed under the AGPL-3.0 license.</string>

    <!-- Bookmark Details Dialog -->
    <string name="detail_dialog_title">Bookmark Details</string>
    <string name="detail_type">Type</string>
    <string name="detail_language">Language</string>
    <string name="detail_word_count">Word Count</string>
    <string name="detail_reading_time">Reading Time</string>
    <string name="detail_minutes_short">min</string>
    <string name="detail_labels">Labels</string>
    <string name="detail_label_placeholder">Add labels (comma-separated)</string>

    <!-- Labels View -->
    <string name="bookmark_labels">Bookmark labels</string>
    <string name="select_label">Select Label</string>
    <string name="labels_description">Select a label to view bookmarks</string>
    <string name="edit_label">Edit label</string>
    <string name="delete_label">Delete label</string>
    <string name="label_deleted">Label %s deleted</string>

    <!-- Search -->
    <string name="search_bookmarks">Search bookmarks</string>
    <string name="search">Search</string>
    <string name="close_search">Close search</string>
    <string name="clear_search">Clear search</string>
    <string name="search_no_results">No results found</string>

    <!-- Sync Settings - Phase 3 -->
    <string name="sync_bookmark_section_title">Bookmark Sync</string>
    <string name="sync_bookmark_description">Bookmarks are always kept in sync.</string>
    <string name="sync_bookmark_frequency_label">Sync frequency</string>
    <string name="sync_content_section_title">Content Sync</string>
    <string name="sync_content_automatic">Automatic</string>
    <string name="sync_content_automatic_desc">Content is downloaded during bookmark sync</string>
    <string name="sync_content_manual">Manual</string>
    <string name="sync_content_manual_desc">Content is downloaded only when you open a bookmark</string>
    <string name="sync_content_date_range">Date Range</string>
    <string name="sync_content_date_range_desc">Download content for bookmarks added in a date range</string>
    <string name="sync_content_date_from">From</string>
    <string name="sync_content_date_to">To</string>
    <string name="sync_content_download_button">Download</string>
    <string name="sync_content_downloading">Downloading</string>
    <string name="sync_constraints_section_title">Constraints</string>
    <string name="sync_wifi_only">Only download on Wi-Fi</string>
    <string name="sync_allow_battery_saver">Allow download on battery saver</string>

    <!-- Sync Status - Phase 3 -->
    <string name="sync_status_section_title">Sync Status</string>
    <string name="sync_status_total">Total bookmarks: %d</string>
    <string name="sync_status_unread">Unread: %d</string>
    <string name="sync_status_archived">Archived: %d</string>
    <string name="sync_status_favorites">Favorites: %d</string>
    <string name="sync_status_content_downloaded">Content downloaded: %d</string>
    <string name="sync_status_content_available">Available to download: %d</string>
    <string name="sync_status_content_dirty">Download failed (retryable): %d</string>
    <string name="sync_status_no_content">No article content: %d</string>

    <!-- Offline Indicator -->
    <string name="offline_tooltip">Offline  unable to reach server</string>

    <!-- Permission Rationale - Phase 3 -->
    <string name="background_sync_rationale_title">Background Downloads</string>
    <string name="background_sync_rationale_body">Content downloads may continue while the app is in the background. This allows your bookmarks to be ready for offline reading.</string>
    <string name="background_sync_rationale_allow">Allow</string>
</resources>
</file>

<file path="app/src/main/java/com/mydeck/app/ui/list/BookmarkListViewModel.kt">
package com.mydeck.app.ui.list

import android.content.Context
import android.content.Intent
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.work.WorkInfo
import androidx.work.WorkManager
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import com.mydeck.app.R
import com.mydeck.app.domain.BookmarkRepository
import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.BookmarkCounts
import com.mydeck.app.domain.model.BookmarkListItem
import com.mydeck.app.domain.model.LayoutMode
import com.mydeck.app.domain.model.SortOption
import com.mydeck.app.domain.sync.ConnectivityMonitor
import com.mydeck.app.domain.usecase.FullSyncUseCase
import com.mydeck.app.domain.usecase.UpdateBookmarkUseCase
import com.mydeck.app.io.prefs.SettingsDataStore
import com.mydeck.app.util.extractUrlAndTitle
import com.mydeck.app.util.isValidUrl
import com.mydeck.app.util.MAX_TITLE_LENGTH
import com.mydeck.app.worker.LoadBookmarksWorker
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.CoroutineExceptionHandler
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import kotlinx.coroutines.Job
import kotlinx.coroutines.CancellationException
import timber.log.Timber
import javax.inject.Inject

@OptIn(ExperimentalCoroutinesApi::class)
@HiltViewModel
class BookmarkListViewModel @Inject constructor(
    private val updateBookmarkUseCase: UpdateBookmarkUseCase,
    private val fullSyncUseCase: FullSyncUseCase,
    workManager: WorkManager,
    private val bookmarkRepository: BookmarkRepository,
    @ApplicationContext private val context: Context,
    private val settingsDataStore: SettingsDataStore,
    private val savedStateHandle: SavedStateHandle,
    connectivityMonitor: ConnectivityMonitor
) : ViewModel() {

    val isOnline: StateFlow<Boolean> = connectivityMonitor.observeConnectivity()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = true
        )
    private val _navigationEvent =
        MutableStateFlow<NavigationEvent?>(null) // Using StateFlow for navigation events
    val navigationEvent: StateFlow<NavigationEvent?> = _navigationEvent.asStateFlow()

    private val _openUrlEvent = MutableStateFlow<String>("")
    val openUrlEvent = _openUrlEvent.asStateFlow()

    private val _filterState = MutableStateFlow(FilterState(archived = false))
    val filterState: StateFlow<FilterState> = _filterState.asStateFlow()

    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()

    private val _isSearchActive = MutableStateFlow(false)
    val isSearchActive: StateFlow<Boolean> = _isSearchActive.asStateFlow()

    private val _layoutMode = MutableStateFlow(LayoutMode.GRID)
    val layoutMode: StateFlow<LayoutMode> = _layoutMode.asStateFlow()

    private val _sortOption = MutableStateFlow(SortOption.ADDED_NEWEST)
    val sortOption: StateFlow<SortOption> = _sortOption.asStateFlow()

    private val _uiState = MutableStateFlow<UiState>(UiState.Empty(R.string.list_view_empty_not_loaded_yet))
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()

    private val _shareIntent = MutableStateFlow<Intent?>(null)
    val shareIntent: StateFlow<Intent?> = _shareIntent.asStateFlow()

    val loadBookmarksIsRunning: StateFlow<Boolean> = workManager.getWorkInfosForUniqueWorkFlow(
        LoadBookmarksWorker.UNIQUE_WORK_NAME
    ).map { it.any { it.state == WorkInfo.State.RUNNING}}
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = false
        )

    // Add state for the CreateBookmarkDialog
    private val _createBookmarkUiState =
        MutableStateFlow<CreateBookmarkUiState>(CreateBookmarkUiState.Closed)
    val createBookmarkUiState: StateFlow<CreateBookmarkUiState> =
        _createBookmarkUiState.asStateFlow()

    // State for pending deletion (for undo functionality)
    private var pendingDeletionJob: Job? = null
    private var pendingDeletionBookmarkId: String? = null

    val loadBookmarkExceptionHandler = CoroutineExceptionHandler { _, ex ->
        Timber.e(ex, "Error loading bookmarks")
        _uiState.value = UiState.Empty(R.string.list_view_empty_error_loading_bookmarks)
    }

    val bookmarkCounts: StateFlow<BookmarkCounts> = bookmarkRepository.observeAllBookmarkCounts()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = BookmarkCounts()
        )

    val labelsWithCounts: StateFlow<Map<String, Int>> = bookmarkRepository.observeAllLabelsWithCounts()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyMap()
        )

    init {
        savedStateHandle.get<String>("sharedText").takeIf { it != null }?.let {
            val sharedText = it.extractUrlAndTitle()
            val urlError = if (sharedText == null) {
                R.string.account_settings_url_error // Use resource ID
            } else {
                null
            }

            _createBookmarkUiState.value = CreateBookmarkUiState.Open(
                title = sharedText?.title ?: "",
                url = sharedText?.url ?: "",
                urlError = urlError,
                isCreateEnabled = urlError == null
            )
        }

        viewModelScope.launch(loadBookmarkExceptionHandler) {
            combine(_filterState, _searchQuery, _sortOption) { filter, query, sort ->
                Triple(filter, query, sort)
            }.flatMapLatest { (filter, query, sort) ->
                if (query.isNotBlank()) {
                    delay(300) // debounce
                    bookmarkRepository.searchBookmarkListItems(
                        searchQuery = query,
                        type = filter.type,
                        unread = filter.unread,
                        archived = filter.archived,
                        favorite = filter.favorite,
                        label = filter.label,
                        state = Bookmark.State.LOADED,
                        orderBy = sort.sqlOrderBy
                    )
                } else {
                    bookmarkRepository.observeBookmarkListItems(
                        type = filter.type,
                        unread = filter.unread,
                        archived = filter.archived,
                        favorite = filter.favorite,
                        label = filter.label,
                        state = Bookmark.State.LOADED,
                        orderBy = sort.sqlOrderBy
                    )
                }
            }.collectLatest {
                _uiState.value = if (it.isEmpty()) {
                    if (_searchQuery.value.isNotBlank()) {
                        UiState.Empty(R.string.search_no_results)
                    } else {
                        UiState.Empty(R.string.list_view_empty_nothing_to_see)
                    }
                } else {
                    UiState.Success(bookmarks = it, updateBookmarkState = null)
                }
            }
        }

        viewModelScope.launch(loadBookmarkExceptionHandler) {
            // Check if the initial sync has been performed
            if (!settingsDataStore.isInitialSyncPerformed()) {
                Timber.d("loadBookmarks")
                loadBookmarks() // Start incremental sync when the ViewModel is created
            }
        }

        // Trigger sync on app open (always on - toggle removed in Phase 3)
        viewModelScope.launch {
            Timber.d("Triggering full sync on app open")
            fullSyncUseCase.performFullSync()
        }

        // Load persisted layout mode and sort option
        viewModelScope.launch {
            settingsDataStore.getLayoutMode()?.let { layoutModeStr ->
                try {
                    _layoutMode.value = LayoutMode.valueOf(layoutModeStr)
                } catch (e: IllegalArgumentException) {
                    Timber.w("Invalid layout mode: $layoutModeStr, using default")
                }
            }

            settingsDataStore.getSortOption()?.let { sortOptionStr ->
                try {
                    _sortOption.value = SortOption.valueOf(sortOptionStr)
                } catch (e: IllegalArgumentException) {
                    Timber.w("Invalid sort option: $sortOptionStr, using default")
                }
            }
        }
    }

    // Filter update functions
    private fun setTypeFilter(type: Bookmark.Type?) {
        _filterState.value = _filterState.value.copy(type = type, label = null, viewingLabelsList = false)
    }

    private fun setUnreadFilter(unread: Boolean?) {
        _filterState.value =
            _filterState.value.copy(unread = unread, archived = null, favorite = null, label = null, viewingLabelsList = false)
    }

    private fun setArchivedFilter(archived: Boolean?) {
        _filterState.value =
            _filterState.value.copy(archived = archived, unread = null, favorite = null, label = null, viewingLabelsList = false)
    }

    private fun setFavoriteFilter(favorite: Boolean?) {
        _filterState.value =
            _filterState.value.copy(favorite = favorite, unread = null, archived = null, label = null, viewingLabelsList = false)
    }

    // UI event handlers (already present, but need modification)
    fun onClickAll() {
        Timber.d("onClickAll")
        clearFilters()
    }

    private fun clearFilters() {
        _filterState.value = FilterState()
    }

    fun onSearchQueryChange(query: String) {
        _searchQuery.value = query
    }

    fun onSearchActiveChange(active: Boolean) {
        _isSearchActive.value = active
        if (!active) {
            _searchQuery.value = ""
        }
    }

    fun onClearSearch() {
        _searchQuery.value = ""
    }

    fun onClickMyList() {
        Timber.d("onClickMyList")
        setArchivedFilter(false)
    }

    fun onClickArchive() {
        Timber.d("onClickArchive")
        setArchivedFilter(true)
    }

    fun onClickFavorite() {
        Timber.d("onClickFavorite")
        setFavoriteFilter(true)
    }

    fun onClickArticles() {
        Timber.d("onClickArticles")
        setTypeFilter(Bookmark.Type.Article)
    }

    fun onClickPictures() {
        Timber.d("onClickPictures")
        setTypeFilter(Bookmark.Type.Picture)
    }

    fun onClickVideos() {
        Timber.d("onClickVideos")
        setTypeFilter(Bookmark.Type.Video)
    }

    fun onClickLabelsView() {
        Timber.d("onClickLabelsView")
        setLabelsListView()
    }

    private fun setLabelsListView() {
        // Show the labels list view
        _filterState.value = FilterState(viewingLabelsList = true)
    }

    fun onClickLabel(label: String) {
        Timber.d("onClickLabel: $label")
        setLabelFilter(label)
    }

    private fun setLabelFilter(label: String?) {
        // Clear all other filters when selecting a label filter
        _filterState.value = FilterState(label = label)
    }

    fun onRenameLabel(oldLabel: String, newLabel: String) {
        viewModelScope.launch {
            try {
                when (bookmarkRepository.renameLabel(oldLabel, newLabel)) {
                    is BookmarkRepository.UpdateResult.Success -> {
                        // Update the filter state with the new label name
                        if (_filterState.value.label == oldLabel) {
                            setLabelFilter(newLabel)
                        }
                        // Labels will auto-refresh via Flow
                    }
                    is BookmarkRepository.UpdateResult.Error,
                    is BookmarkRepository.UpdateResult.NetworkError -> {
                        Timber.e("Failed to rename label")
                    }
                }
            } catch (e: Exception) {
                Timber.e(e, "Error renaming label")
            }
        }
    }

    fun onDeleteLabel(label: String) {
        viewModelScope.launch {
            try {
                when (bookmarkRepository.deleteLabel(label)) {
                    is BookmarkRepository.UpdateResult.Success -> {
                        // Navigate back to labels list page
                        _filterState.value = FilterState(viewingLabelsList = true)
                        // Labels will auto-refresh via Flow
                    }
                    is BookmarkRepository.UpdateResult.Error,
                    is BookmarkRepository.UpdateResult.NetworkError -> {
                        Timber.e("Failed to delete label")
                    }
                }
            } catch (e: Exception) {
                Timber.e(e, "Error deleting label")
            }
        }
    }

    fun onClickSettings() {
        Timber.d("onClickSettings")
        _navigationEvent.update { NavigationEvent.NavigateToSettings }
    }

    fun onClickAbout() {
        Timber.d("onClickAbout")
        _navigationEvent.update { NavigationEvent.NavigateToAbout }
    }

    fun onClickBookmark(bookmarkId: String) {
        Timber.d("onClickBookmark")
        _navigationEvent.update { NavigationEvent.NavigateToBookmarkDetail(bookmarkId) }
    }

    fun onClickBookmarkOpenOriginal(bookmarkId: String) {
        Timber.d("onClickBookmarkOpenOriginal")
        _navigationEvent.update { NavigationEvent.NavigateToBookmarkDetail(bookmarkId, showOriginal = true) }
    }

    fun onNavigationEventConsumed() {
        _navigationEvent.update { null } // Reset the event
    }

    fun onOpenUrlEventConsumed() {
        _openUrlEvent.value = ""
    }

    private fun loadBookmarks(initialLoad: Boolean = false) {
        viewModelScope.launch {
            try {
                LoadBookmarksWorker.enqueue(context, isInitialLoad = initialLoad) // Enqueue for incremental sync
            } catch (e: Exception) {
                // Handle errors (e.g., show error message)
                _uiState.value = UiState.Empty(R.string.list_view_empty_error_loading_bookmarks)
                Timber.e(e, "Error loading bookmarks: ${e.message}")
            }
        }
    }

    fun onClickShareBookmark(url: String) {
        val intent = Intent().apply {
            action = Intent.ACTION_SEND
            putExtra(Intent.EXTRA_TEXT, url)
            type = "text/plain"
        }
        _shareIntent.value = intent
    }

    fun onShareIntentConsumed() {
        _shareIntent.value = null
    }

    fun onPullToRefresh() {
        loadBookmarks(false)
    }

    fun onDeleteBookmark(bookmarkId: String) {
        // Cancel any existing pending deletion
        pendingDeletionJob?.cancel()

        // Store the bookmark ID for potential undo
        pendingDeletionBookmarkId = bookmarkId

        // Start a new deletion job with 10-second delay
        pendingDeletionJob = viewModelScope.launch {
            try {
                // Wait 10 seconds before actually deleting
                delay(10000)

                // After delay, perform the actual deletion
                updateBookmark {
                    updateBookmarkUseCase.deleteBookmark(bookmarkId)
                }

                // Clear pending deletion state
                pendingDeletionBookmarkId = null
                pendingDeletionJob = null
            } catch (e: CancellationException) {
                // Job was cancelled (undo was clicked), just rethrow
                Timber.d("Deletion cancelled by user")
                throw e
            } catch (e: Exception) {
                // Some other error occurred
                Timber.e(e, "Error deleting bookmark: ${e.message}")
            }
        }
    }

    fun onCancelDeleteBookmark() {
        // Cancel the pending deletion job
        pendingDeletionJob?.cancel()
        pendingDeletionJob = null
        pendingDeletionBookmarkId = null
        Timber.d("Delete bookmark cancelled")
    }

    fun onToggleMarkReadBookmark(bookmarkId: String, isRead: Boolean) {
        updateBookmark {
            updateBookmarkUseCase.updateIsRead(
                bookmarkId = bookmarkId,
                isRead = isRead
            )
        }
    }

    fun onToggleFavoriteBookmark(bookmarkId: String, isFavorite: Boolean) {
        updateBookmark {
            updateBookmarkUseCase.updateIsFavorite(
                bookmarkId = bookmarkId,
                isFavorite = isFavorite
            )
        }
    }

    fun onToggleArchiveBookmark(bookmarkId: String, isArchived: Boolean) {
        updateBookmark {
            updateBookmarkUseCase.updateIsArchived(
                bookmarkId = bookmarkId,
                isArchived = isArchived
            )
        }
    }

    private fun updateBookmark(update: suspend () -> UpdateBookmarkUseCase.Result) {
        viewModelScope.launch {
            val state = when (val result = update()) {
                is UpdateBookmarkUseCase.Result.Success -> UpdateBookmarkState.Success
                is UpdateBookmarkUseCase.Result.GenericError -> UpdateBookmarkState.Error(result.message)
                is UpdateBookmarkUseCase.Result.NetworkError -> UpdateBookmarkState.Error(result.message)
            }
            _uiState.update {
                when (it) {
                    is UiState.Success -> it.copy(updateBookmarkState = state)
                    else -> it
                }
            }
        }
    }

    // Create Bookmark Dialog
    fun openCreateBookmarkDialog(clipboardText: String? = null) {
        val sharedText = clipboardText?.extractUrlAndTitle()

        _createBookmarkUiState.value = if (sharedText != null) {
            CreateBookmarkUiState.Open(
                title = sharedText.title?.take(MAX_TITLE_LENGTH) ?: "",
                url = sharedText.url,
                urlError = null,
                isCreateEnabled = true
            )
        } else {
            CreateBookmarkUiState.Open(
                title = "",
                url = "",
                urlError = null,
                isCreateEnabled = false
            )
        }
    }

    fun closeCreateBookmarkDialog() {
        _createBookmarkUiState.value = CreateBookmarkUiState.Closed
    }

    fun updateCreateBookmarkTitle(title: String) {
        _createBookmarkUiState.update {
            (it as? CreateBookmarkUiState.Open)?.copy(
                title = title,
                isCreateEnabled = it.url.isValidUrl()
            ) ?: it
        }
    }

    fun updateCreateBookmarkUrl(url: String) {
        val isValidUrl = url.isValidUrl()
        val urlError = if (!isValidUrl && url.isNotEmpty()) {
            R.string.account_settings_url_error // Use resource ID
        } else {
            null
        }
        _createBookmarkUiState.update {
            (it as? CreateBookmarkUiState.Open)?.copy(
                url = url,
                urlError = urlError,
                isCreateEnabled = isValidUrl
            ) ?: it
        }
    }

    fun updateCreateBookmarkLabels(labels: List<String>) {
        _createBookmarkUiState.update {
            (it as? CreateBookmarkUiState.Open)?.copy(
                labels = labels
            ) ?: it
        }
    }

    fun createBookmark() {
        viewModelScope.launch {
            val url = (_createBookmarkUiState.value as CreateBookmarkUiState.Open).url
            val title = (_createBookmarkUiState.value as CreateBookmarkUiState.Open).title
            val labels = (_createBookmarkUiState.value as CreateBookmarkUiState.Open).labels

            _createBookmarkUiState.value = CreateBookmarkUiState.Loading
            try {
                bookmarkRepository.createBookmark(title = title, url = url, labels = labels)
                _createBookmarkUiState.value = CreateBookmarkUiState.Success
            } catch (e: Exception) {
                _createBookmarkUiState.value =
                    CreateBookmarkUiState.Error(e.message ?: "Unknown error")
            }
        }
    }

    fun onLayoutModeSelected(mode: LayoutMode) {
        _layoutMode.value = mode
        viewModelScope.launch {
            settingsDataStore.saveLayoutMode(mode.name)
        }
    }

    fun onSortOptionSelected(option: SortOption) {
        _sortOption.value = option
        viewModelScope.launch {
            settingsDataStore.saveSortOption(option.name)
        }
    }

    sealed class NavigationEvent {
        data object NavigateToSettings : NavigationEvent()
        data object NavigateToAbout : NavigationEvent()
        data class NavigateToBookmarkDetail(val bookmarkId: String, val showOriginal: Boolean = false) : NavigationEvent()
    }

    data class FilterState(
        val type: Bookmark.Type? = null,
        val unread: Boolean? = null,
        val archived: Boolean? = null,
        val favorite: Boolean? = null,
        val label: String? = null,
        val viewingLabelsList: Boolean = false
    )

    sealed class UiState {
        data class Success(
            val bookmarks: List<BookmarkListItem>,
            val updateBookmarkState: UpdateBookmarkState?
        ) : UiState()

        data class Empty(
            val messageResource: Int
        ) : UiState()
    }

    sealed class CreateBookmarkUiState {
        data object Closed : CreateBookmarkUiState()
        data class Open(
            val title: String,
            val url: String,
            val urlError: Int?,
            val isCreateEnabled: Boolean,
            val labels: List<String> = emptyList()
        ) : CreateBookmarkUiState()

        data object Loading : CreateBookmarkUiState()
        data object Success : CreateBookmarkUiState()
        data class Error(val message: String) : CreateBookmarkUiState()
    }

    sealed class UpdateBookmarkState {
        data object Success : UpdateBookmarkState()
        data class Error(val message: String) : UpdateBookmarkState()
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/detail/BookmarkDetailScreen.kt">
package com.mydeck.app.ui.detail

import android.icu.text.MessageFormat
import android.view.View
import android.webkit.WebView
import androidx.compose.foundation.clickable
import androidx.compose.ui.draw.alpha
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.OpenInNew
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Grade
import androidx.compose.material.icons.filled.Image
import androidx.compose.material.icons.filled.Movie
import androidx.compose.material.icons.outlined.Info
import androidx.compose.material.icons.filled.Inventory2
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.icons.filled.TextDecrease
import androidx.compose.material.icons.filled.TextIncrease
import androidx.compose.material.icons.outlined.CheckCircle
import androidx.compose.material.icons.outlined.Description
import androidx.compose.material.icons.outlined.Grade
import androidx.compose.material.icons.outlined.Inventory2
import androidx.compose.material.icons.outlined.Share
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.LocalContentColor
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalInspectionMode
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.mydeck.app.R
import com.mydeck.app.domain.model.Template
import com.mydeck.app.util.openUrlInCustomTab
import com.mydeck.app.ui.components.ShareBookmarkChooser
import com.mydeck.app.ui.detail.BookmarkDetailViewModel.ContentLoadState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@Composable
fun BookmarkDetailScreen(navHostController: NavController, bookmarkId: String?, showOriginal: Boolean = false) {
    val viewModel: BookmarkDetailViewModel = hiltViewModel()
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val openUrlEvent = viewModel.openUrlEvent.collectAsState()
    val onClickBack: () -> Unit = { viewModel.onClickBack() }
    val onClickToggleFavorite: (String, Boolean) -> Unit =
        { id, isFavorite -> viewModel.onToggleFavorite(id, isFavorite) }
    val onClickToggleArchive: (String, Boolean) -> Unit =
        { id, isArchived -> viewModel.onToggleArchive(id, isArchived) }
    val onClickIncreaseZoomFactor: () -> Unit =
        { viewModel.onClickChangeZoomFactor(25) }
    val onClickDecreaseZoomFactor: () -> Unit =
        { viewModel.onClickChangeZoomFactor(-25) }

    val onClickOpenUrl: (String) -> Unit = { viewModel.onClickOpenUrl(it) }
    val onClickShareBookmark: (String) -> Unit = { url -> viewModel.onClickShareBookmark(url) }
    val onClickToggleRead: (String, Boolean) -> Unit = { id, isRead -> viewModel.onToggleRead(id, isRead) }
    val onUpdateLabels: (String, List<String>) -> Unit = { id, labels -> viewModel.onUpdateLabels(id, labels) }
    val snackbarHostState = remember { SnackbarHostState() }
    val uiState = viewModel.uiState.collectAsState().value
    val contentLoadState = viewModel.contentLoadState.collectAsState().value
    var showDetailsDialog by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()
    val onClickDeleteBookmark: (String) -> Unit = { id ->
        viewModel.deleteBookmark(id)
        scope.launch {
            val result = snackbarHostState.showSnackbar(
                message = "Bookmark deleted",
                actionLabel = "UNDO",
                duration = SnackbarDuration.Long
            )
            if (result == SnackbarResult.ActionPerformed) {
                viewModel.onCancelDeleteBookmark()
            }
        }
    }

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                is BookmarkDetailViewModel.NavigationEvent.NavigateBack -> {
                    navHostController.popBackStack()
                }
            }
            viewModel.onNavigationEventConsumed() // Consume the event
        }
    }

    val context = LocalContext.current
    LaunchedEffect(key1 = openUrlEvent.value){
        openUrlInCustomTab(context, openUrlEvent.value)
        viewModel.onOpenUrlEventConsumed()
    }

    when (uiState) {
        is BookmarkDetailViewModel.UiState.Success -> {
            var contentMode by remember(uiState.bookmark.bookmarkId) {
                mutableStateOf(
                    if (showOriginal) ContentMode.ORIGINAL
                    else ContentMode.READER
                )
            }

            // Auto-switch to Original mode when content fetch fails (any reason)
            // This handles both permanent failures (no server content) and
            // transient failures (server error fetching article)
            LaunchedEffect(contentLoadState) {
                if (contentLoadState is ContentLoadState.Failed &&
                    contentMode == ContentMode.READER &&
                    !uiState.bookmark.hasContent) {
                    contentMode = ContentMode.ORIGINAL
                }
            }

            LaunchedEffect(key1 = uiState) {
                uiState.updateBookmarkState?.let {
                    when (it) {
                        is BookmarkDetailViewModel.UpdateBookmarkState.Success -> { }
                        is BookmarkDetailViewModel.UpdateBookmarkState.Error -> {
                            snackbarHostState.showSnackbar(
                                message = it.message,
                                duration = SnackbarDuration.Long
                            )
                        }
                    }
                    viewModel.onUpdateBookmarkStateConsumed()
                }
            }
            BookmarkDetailScreen(
                modifier = Modifier,
                snackbarHostState = snackbarHostState,
                onClickBack = onClickBack,
                onClickToggleFavorite = onClickToggleFavorite,
                onClickToggleArchive = onClickToggleArchive,
                onClickToggleRead = onClickToggleRead,
                onClickShareBookmark = onClickShareBookmark,
                onClickDeleteBookmark = onClickDeleteBookmark,
                uiState = uiState,
                onClickOpenUrl = onClickOpenUrl,
                onClickIncreaseZoomFactor = onClickIncreaseZoomFactor,
                onClickDecreaseZoomFactor = onClickDecreaseZoomFactor,
                onShowDetails = { showDetailsDialog = true },
                onScrollProgressChanged = { progress ->
                    viewModel.onScrollProgressChanged(progress)
                },
                initialReadProgress = viewModel.getInitialReadProgress(),
                contentMode = contentMode,
                onContentModeChange = { contentMode = it },
                contentLoadState = contentLoadState,
            )
            // Consumes a shareIntent and creates the corresponding share dialog
            ShareBookmarkChooser(
                context = LocalContext.current,
                intent = viewModel.shareIntent.collectAsState().value,
                onShareIntentConsumed = { viewModel.onShareIntentConsumed() }
            )
            if (showDetailsDialog) {
                BookmarkDetailsDialog(
                    bookmark = uiState.bookmark,
                    onDismissRequest = { showDetailsDialog = false },
                    onLabelsUpdate = { newLabels ->
                        onUpdateLabels(uiState.bookmark.bookmarkId, newLabels)
                    }
                )
            }
        }

        is BookmarkDetailViewModel.UiState.Loading -> {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        }

        else -> {
            BookmarkDetailErrorScreen()
        }
    }

}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BookmarkDetailScreen(
    modifier: Modifier,
    snackbarHostState: SnackbarHostState,
    onClickBack: () -> Unit,
    uiState: BookmarkDetailViewModel.UiState.Success,
    onClickToggleFavorite: (String, Boolean) -> Unit,
    onClickToggleArchive: (String, Boolean) -> Unit,
    onClickToggleRead: (String, Boolean) -> Unit,
    onClickDeleteBookmark: (String) -> Unit,
    onClickOpenUrl: (String) -> Unit,
    onClickShareBookmark: (String) -> Unit,
    onClickIncreaseZoomFactor: () -> Unit,
    onClickDecreaseZoomFactor: () -> Unit,
    onShowDetails: () -> Unit = {},
    onScrollProgressChanged: (Int) -> Unit = {},
    initialReadProgress: Int = 0,
    contentMode: ContentMode = ContentMode.READER,
    onContentModeChange: (ContentMode) -> Unit = {},
    contentLoadState: ContentLoadState = ContentLoadState.Idle
) {
    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        modifier = modifier,
        topBar = {
            TopAppBar(
                title = { },
                navigationIcon = {
                    IconButton(onClick = onClickBack) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(R.string.back)
                        )
                    }
                },
                actions = {
                    IconButton(onClick = {
                        onClickToggleFavorite(uiState.bookmark.bookmarkId, !uiState.bookmark.isFavorite)
                    }) {
                        Icon(
                            imageVector = if (uiState.bookmark.isFavorite) Icons.Filled.Grade else Icons.Outlined.Grade,
                            contentDescription = stringResource(R.string.action_favorite)
                        )
                    }
                    IconButton(onClick = {
                        onClickToggleArchive(uiState.bookmark.bookmarkId, !uiState.bookmark.isArchived)
                    }) {
                        Icon(
                            imageVector = if (uiState.bookmark.isArchived) Icons.Filled.Inventory2 else Icons.Outlined.Inventory2,
                            contentDescription = stringResource(R.string.action_archive)
                        )
                    }
                    IconButton(onClick = { onShowDetails() }) {
                        Icon(
                            imageVector = Icons.Outlined.Info,
                            contentDescription = stringResource(R.string.detail_dialog_title)
                        )
                    }
                    BookmarkDetailMenu(
                        uiState = uiState,
                        onClickToggleRead = onClickToggleRead,
                        onClickShareBookmark = onClickShareBookmark,
                        onClickDeleteBookmark = onClickDeleteBookmark,
                        onClickIncreaseZoomFactor = onClickIncreaseZoomFactor,
                        onClickDecreaseZoomFactor = onClickDecreaseZoomFactor,
                        contentMode = contentMode,
                        onContentModeChange = onContentModeChange
                    )
                }
            )
        }
    ) { padding ->
        BookmarkDetailContent(
            modifier = Modifier.padding(padding),
            uiState = uiState,
            onClickOpenUrl = onClickOpenUrl,
            onScrollProgressChanged = onScrollProgressChanged,
            initialReadProgress = initialReadProgress,
            contentMode = contentMode,
            contentLoadState = contentLoadState
        )
    }
}

@Composable
fun BookmarkDetailContent(
    modifier: Modifier = Modifier,
    uiState: BookmarkDetailViewModel.UiState.Success,
    onClickOpenUrl: (String) -> Unit,
    onScrollProgressChanged: (Int) -> Unit = {},
    initialReadProgress: Int = 0,
    contentMode: ContentMode = ContentMode.READER,
    contentLoadState: ContentLoadState = ContentLoadState.Idle
) {
    val scrollState = rememberScrollState()
    val hasArticleContent = uiState.bookmark.articleContent != null
    val isArticle = uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.ARTICLE
    val needsRestore = isArticle && hasArticleContent && initialReadProgress > 0 && initialReadProgress <= 100
    // Key on hasArticleContent so when content arrives after on-demand fetch,
    // the state resets and scroll position restore is triggered
    var hasRestoredPosition by remember(hasArticleContent) { mutableStateOf(!needsRestore) }
    var lastReportedProgress by remember { mutableStateOf(-1) }

    // Restore scroll position when content is loaded (using initial progress, not reactive)
    LaunchedEffect(scrollState.maxValue) {
        if (!hasRestoredPosition && scrollState.maxValue > 0 && initialReadProgress > 0 && initialReadProgress <= 100) {
            val targetPosition = (scrollState.maxValue * initialReadProgress / 100f).toInt()
            scrollState.scrollTo(targetPosition)
            hasRestoredPosition = true
        }
    }

    // Track scroll progress and report changes (only depends on scroll value, not bookmark updates)
    // Only report when progress actually changes to avoid spam
    LaunchedEffect(scrollState.value, scrollState.maxValue) {
        val progress = if (scrollState.maxValue > 0) {
            ((scrollState.value.toFloat() / scrollState.maxValue.toFloat()) * 100).toInt().coerceIn(0, 100)
        } else {
            // Content fits on screen or is loading.
            // Returning 0 prevents premature 'read' lock on long articles that are still loading.
            0
        }

        // Only report if progress changed
        if (progress != lastReportedProgress) {
            lastReportedProgress = progress
            onScrollProgressChanged(progress)
        }
    }

    Box(modifier = modifier) {
        if (contentMode == ContentMode.ORIGINAL) {
            // Original mode: no outer scroll, WebView handles its own scrolling
            // Header is not shown in Original mode - full content experience
            BookmarkDetailOriginalWebView(
                modifier = Modifier.fillMaxSize(),
                uiState = uiState
            )
        } else {
            // Reader mode: scrollable Column for article content
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .verticalScroll(scrollState)
                    .alpha(if (hasRestoredPosition) 1f else 0f),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                BookmarkDetailHeader(
                    modifier = Modifier,
                    uiState = uiState,
                    onClickOpenUrl = onClickOpenUrl
                )

                val hasContent = uiState.bookmark.hasContent
                if (hasContent) {
                    BookmarkDetailArticle(
                        modifier = Modifier,
                        uiState = uiState
                    )
                } else {
                    // No content yet  show loading spinner while fetch is in progress.
                    // Auto-switch to Original mode is handled by LaunchedEffect above
                    // when the content load state transitions to Failed.
                    when (contentLoadState) {
                        is ContentLoadState.Loading -> {
                            Box(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .height(200.dp),
                                contentAlignment = Alignment.Center
                            ) {
                                CircularProgressIndicator()
                            }
                        }
                        else -> {
                            // Brief fallback while auto-switch hasn't happened yet
                            EmptyBookmarkDetailArticle(
                                modifier = Modifier
                            )
                        }
                    }
                }
            }

            // Scrollbar for reader mode
            com.mydeck.app.ui.components.VerticalScrollbar(
                modifier = Modifier
                    .align(Alignment.CenterEnd)
                    .fillMaxHeight(),
                scrollState = scrollState
            )
        }
    }
    }


@Composable
fun EmptyBookmarkDetailArticle(
    modifier: Modifier
) {
    Text(
        modifier = modifier,
        text = stringResource(R.string.detail_view_no_content)
    )
}

@Composable
fun BookmarkDetailArticle(
    modifier: Modifier,
    uiState: BookmarkDetailViewModel.UiState.Success
) {
    val isSystemInDarkMode = isSystemInDarkTheme()
    val content = remember(uiState.bookmark.bookmarkId, isSystemInDarkMode, uiState.template) {
        mutableStateOf<String?>(null)
    }
    val webViewRef = remember { mutableStateOf<WebView?>(null) }
    LaunchedEffect(uiState.bookmark.bookmarkId, isSystemInDarkMode, uiState.template) {
        content.value = getTemplate(uiState, isSystemInDarkMode)
        webViewRef.value?.settings?.textZoom = uiState.zoomFactor
    }
    if (content.value != null) {
        if (!LocalInspectionMode.current) {
            AndroidView(
                modifier = Modifier.padding(0.dp),
                factory = { context ->
                    WebView(context).apply {
                        val isVideo = uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.VIDEO
                        settings.javaScriptEnabled = isVideo
                        settings.domStorageEnabled = isVideo
                        settings.mediaPlaybackRequiresUserGesture = true
                        settings.useWideViewPort = false
                        settings.loadWithOverviewMode = false
                        setLayerType(View.LAYER_TYPE_HARDWARE, null)
                        settings.defaultTextEncodingName = "utf-8"
                        isVerticalScrollBarEnabled = false
                        isHorizontalScrollBarEnabled = false
                        settings.textZoom = uiState.zoomFactor
                        webViewRef.value = this
                    }
                },
                update = {
                    if (content.value != null && it.tag as? String != content.value) {
                        val baseUrl = if (uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.VIDEO) {
                            uiState.bookmark.url
                        } else {
                            null
                        }
                        it.loadDataWithBaseURL(
                            baseUrl,
                            content.value!!,
                            "text/html",
                            "utf-8",
                            null
                        )
                        it.tag = content.value
                    }
                    // Update reference and zoom
                    webViewRef.value = it
                    it.settings.textZoom = uiState.zoomFactor
                }
            )
        }

    } else {
        CircularProgressIndicator()
    }
}

@Composable
fun BookmarkDetailOriginalWebView(
    modifier: Modifier = Modifier,
    uiState: BookmarkDetailViewModel.UiState.Success
) {
    var loadingProgress by remember { mutableStateOf(0) }
    var httpError by remember { mutableStateOf<Pair<Int, String>?>(null) }

    Column(modifier = modifier) {
        // Show progress indicator while loading
        if (loadingProgress < 100 && httpError == null) {
            LinearProgressIndicator(
                progress = { loadingProgress / 100f },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(4.dp)
            )
        }

        if (httpError != null) {
            // App-provided error message for HTTP errors
            val (errorCode, _) = httpError!!
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.padding(32.dp)
                ) {
                    Text(
                        text = stringResource(R.string.webview_error_title),
                        style = MaterialTheme.typography.titleMedium,
                        textAlign = TextAlign.Center
                    )
                    Spacer(Modifier.height(8.dp))
                    Text(
                        text = stringResource(R.string.webview_error_message, errorCode),
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        } else if (!LocalInspectionMode.current) {
            AndroidView(
                modifier = Modifier
                    .fillMaxWidth()
                    .fillMaxHeight(),
                factory = { context ->
                    WebView(context).apply {
                        settings.javaScriptEnabled = true
                        settings.domStorageEnabled = true
                        settings.mediaPlaybackRequiresUserGesture = false
                        settings.useWideViewPort = true
                        settings.loadWithOverviewMode = true
                        setLayerType(View.LAYER_TYPE_HARDWARE, null)
                        settings.defaultTextEncodingName = "utf-8"
                        isVerticalScrollBarEnabled = false
                        isHorizontalScrollBarEnabled = false

                        // Intercept HTTP errors to show app-provided messages
                        webViewClient = object : android.webkit.WebViewClient() {
                            override fun onReceivedHttpError(
                                view: WebView?,
                                request: android.webkit.WebResourceRequest?,
                                errorResponse: android.webkit.WebResourceResponse?
                            ) {
                                super.onReceivedHttpError(view, request, errorResponse)
                                // Only handle errors for the main page, not subresources
                                if (request?.isForMainFrame == true) {
                                    val code = errorResponse?.statusCode ?: 0
                                    val description = errorResponse?.reasonPhrase ?: "Unknown error"
                                    httpError = Pair(code, description)
                                }
                            }
                        }

                        // Track loading progress
                        webChromeClient = object : android.webkit.WebChromeClient() {
                            override fun onProgressChanged(view: WebView?, newProgress: Int) {
                                super.onProgressChanged(view, newProgress)
                                loadingProgress = newProgress
                            }
                        }

                        loadUrl(uiState.bookmark.url)
                    }
                }
            )
        }
    }
}

suspend fun getTemplate(uiState: BookmarkDetailViewModel.UiState.Success, isSystemInDarkMode: Boolean): String? {
    return withContext(Dispatchers.IO) {
        uiState.bookmark.getContent(uiState.template, isSystemInDarkMode)
    }
}


@Composable
fun BookmarkDetailHeader(
    modifier: Modifier,
    uiState: BookmarkDetailViewModel.UiState.Success,
    onClickOpenUrl: (String) -> Unit
) {
    val msg = stringResource(R.string.authors)
    val author = MessageFormat.format(
        msg, mapOf(
            "count" to uiState.bookmark.authors.size,
            "author" to uiState.bookmark.authors.firstOrNull()
        )
    )
    Column(
        modifier = modifier,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Header Section Start
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            text = uiState.bookmark.title,
            style = MaterialTheme.typography.headlineSmall,
            textAlign = TextAlign.Center,
            overflow = TextOverflow.Ellipsis,
            maxLines = 2
        )
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            modifier = Modifier
                .fillMaxWidth(),
            text = "$author - ${uiState.bookmark.createdDate}",
            style = MaterialTheme.typography.titleMedium,
            textAlign = TextAlign.Center,
        )
        Text(
            text = uiState.bookmark.siteName,
            style = MaterialTheme.typography.titleMedium,
        )

        Spacer(modifier = Modifier.height(16.dp))
        // Header Section End
    }
}

@Composable
fun BookmarkDetailMenu(
    uiState: BookmarkDetailViewModel.UiState.Success,
    onClickToggleRead: (String, Boolean) -> Unit,
    onClickShareBookmark: (String) -> Unit,
    onClickDeleteBookmark: (String) -> Unit,
    onClickIncreaseZoomFactor: () -> Unit,
    onClickDecreaseZoomFactor: () -> Unit,
    contentMode: ContentMode = ContentMode.READER,
    onContentModeChange: (ContentMode) -> Unit = {}
) {
    var expanded by remember { mutableStateOf(false) }

    Box {
        IconButton(onClick = { expanded = true }) {
            Icon(Icons.Filled.MoreVert, contentDescription = "Actions")
        }
        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            DropdownMenuItem(
                text = { Text(stringResource(R.string.action_increase_text_size)) },
                onClick = {
                    onClickIncreaseZoomFactor()
                },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Filled.TextIncrease,
                        contentDescription = stringResource(R.string.action_increase_text_size)
                    )
                }
            )
            DropdownMenuItem(
                text = { Text(stringResource(R.string.action_decrease_text_size)) },
                onClick = {
                    onClickDecreaseZoomFactor()
                },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Filled.TextDecrease,
                        contentDescription = stringResource(R.string.action_decrease_text_size)
                    )
                }
            )
            DropdownMenuItem(
                text = { Text(stringResource(R.string.action_mark_read)) },
                onClick = {
                    onClickToggleRead(uiState.bookmark.bookmarkId, !uiState.bookmark.isRead)
                    expanded = false
                },
                leadingIcon = {
                    Icon(
                        imageVector = if (uiState.bookmark.isRead) Icons.Filled.CheckCircle else Icons.Outlined.CheckCircle,
                        contentDescription = stringResource(R.string.action_mark_read)
                    )
                }
            )
            // View Original/Content toggle for all bookmark types
            if (uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.ARTICLE ||
                uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.PHOTO ||
                uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.VIDEO) {

                val (labelRes, icon) = when {
                    contentMode == ContentMode.READER -> {
                        // In Reader mode, always show "View Original" with OpenInNew icon
                        Pair(R.string.action_view_original, Icons.AutoMirrored.Filled.OpenInNew)
                    }
                    // In Original mode, show type-specific label with type-specific icon
                    uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.ARTICLE -> {
                        Pair(R.string.action_view_article, Icons.Outlined.Description)
                    }
                    uiState.bookmark.type == BookmarkDetailViewModel.Bookmark.Type.PHOTO -> {
                        Pair(R.string.action_view_photo, Icons.Filled.Image)
                    }
                    else -> { // VIDEO
                        Pair(R.string.action_view_video, Icons.Filled.Movie)
                    }
                }

                val isReaderMode = contentMode == ContentMode.READER
                val isEnabled = if (isReaderMode) true else uiState.bookmark.hasContent

                DropdownMenuItem(
                    text = { Text(stringResource(labelRes)) },
                    enabled = isEnabled,
                    onClick = {
                        val newMode = if (contentMode == ContentMode.READER) ContentMode.ORIGINAL else ContentMode.READER
                        onContentModeChange(newMode)
                        expanded = false
                    },
                    leadingIcon = {
                        Icon(
                            imageVector = icon,
                            contentDescription = stringResource(labelRes),
                            tint = if (isEnabled) LocalContentColor.current else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)
                        )
                    }
                )
            }
            DropdownMenuItem(
                text = { Text(stringResource(R.string.action_share)) },
                onClick = {
                    onClickShareBookmark(uiState.bookmark.url)
                    expanded = false
                },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Outlined.Share,
                        contentDescription = stringResource(R.string.action_share)
                    )
                }
            )
            DropdownMenuItem(
                text = { Text(stringResource(R.string.action_delete)) },
                onClick = {
                    onClickDeleteBookmark(uiState.bookmark.bookmarkId)
                    expanded = false
                },
                leadingIcon = {
                    Icon(
                        Icons.Filled.Delete,
                        contentDescription = stringResource(R.string.action_delete)
                    )
                }
            )
        }
    }
}

@Composable
fun BookmarkDetailErrorScreen() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text(stringResource(R.string.error_no_article_content))
    }
}

@Preview(showBackground = true)
@Composable
fun BookmarkDetailScreenPreview() {
    BookmarkDetailScreen(
        modifier = Modifier,
        snackbarHostState = SnackbarHostState(),
        onClickBack = {},
        onClickDeleteBookmark = {},
        onClickToggleFavorite = { _, _ -> },
        onClickToggleRead = { _, _ -> },
        onClickShareBookmark = {_ -> },
        onClickIncreaseZoomFactor = { },
        onClickDecreaseZoomFactor = { },
        onClickToggleArchive = { _, _ -> },
        uiState = BookmarkDetailViewModel.UiState.Success(
            bookmark = sampleBookmark,
            updateBookmarkState = null,
            template = Template.SimpleTemplate("template"),
            zoomFactor = 100
        ),
        onClickOpenUrl = {}
    )
}

@Preview
@Composable
private fun BookmarkDetailContentPreview() {
    Surface {
        BookmarkDetailContent(
            modifier = Modifier,
            uiState = BookmarkDetailViewModel.UiState.Success(
                bookmark = sampleBookmark,
                updateBookmarkState = null,
                template = Template.SimpleTemplate("template"),
                zoomFactor = 100
            ),
            onClickOpenUrl = {}
        )
    }
}

@Preview
@Composable
private fun BookmarkDetailContentErrorPreview() {
    Surface {
        BookmarkDetailErrorScreen()
    }
}

@Preview(showBackground = true)
@Composable
private fun BookmarkDetailHeaderPreview() {
    BookmarkDetailHeader(
        modifier = Modifier,
        uiState = BookmarkDetailViewModel.UiState.Success(
            bookmark = sampleBookmark,
            updateBookmarkState = null,
            template = Template.SimpleTemplate("template"),
            zoomFactor = 100
        ),
        onClickOpenUrl = {}
    )
}


private val sampleBookmark = BookmarkDetailViewModel.Bookmark(
    bookmarkId = "1",
    createdDate = "2024-01-15T10:00:00",
    url = "https://example.com",
    title = "This is a very long title of a small sample bookmark",
    siteName = "Example",
    authors = listOf("John Doe"),
    imgSrc = "https://via.placeholder.com/150",
    isFavorite = false,
    isArchived = false,
    isRead = false,
    type = BookmarkDetailViewModel.Bookmark.Type.ARTICLE,
    articleContent = "articleContent",
    embed = null,
    lang = "en",
    wordCount = 1500,
    readingTime = 7,
    description = "This is a sample description",
    labels = listOf("tech", "android", "kotlin"),
    readProgress = 0,
    hasContent = true
)

enum class ContentMode {
    READER,
    ORIGINAL
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/list/BookmarkCard.kt">
package com.mydeck.app.ui.list

import android.content.Context
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.OpenInNew
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Movie
import androidx.compose.material.icons.filled.Image
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Grade
import androidx.compose.material.icons.filled.Inventory2
import androidx.compose.material.icons.outlined.CheckCircle
import androidx.compose.material.icons.outlined.Grade
import androidx.compose.material.icons.outlined.Inventory2
import androidx.compose.foundation.BorderStroke
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.SuggestionChipDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.SuggestionChip
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.luminance
import coil3.ColorImage
import coil3.compose.AsyncImage
import coil3.compose.AsyncImagePreviewHandler
import coil3.compose.LocalAsyncImagePreviewHandler
import coil3.compose.SubcomposeAsyncImage
import coil3.request.ImageRequest
import coil3.request.crossfade
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import com.mydeck.app.R
import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.BookmarkListItem
import com.mydeck.app.ui.components.ErrorPlaceholderImage
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun BookmarkMosaicCard(
    bookmark: BookmarkListItem,
    onClickCard: (String) -> Unit,
    onClickDelete: (String) -> Unit,
    onClickFavorite: (String, Boolean) -> Unit,
    onClickShareBookmark: (String) -> Unit,
    onClickArchive: (String, Boolean) -> Unit,
    onClickLabel: (String) -> Unit = {},
    onClickOpenUrl: (String) -> Unit = {}
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .height(200.dp)
            .clickable { onClickCard(bookmark.id) },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Box(modifier = Modifier.fillMaxWidth()) {
            // Full height thumbnail as background
            SubcomposeAsyncImage(
                model = ImageRequest.Builder(LocalContext.current).data(bookmark.imageSrc)
                    .crossfade(true).build(),
                contentDescription = stringResource(R.string.common_bookmark_image_content_description),
                contentScale = ContentScale.Crop,
                error = {
                    ErrorPlaceholderImage(
                        modifier = Modifier.fillMaxWidth().height(270.dp),
                        imageContentDescription = stringResource(R.string.common_bookmark_image_content_description)
                    )
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
            )

            // Type icon overlay
            if (bookmark.type is Bookmark.Type.Video || bookmark.type is Bookmark.Type.Picture) {
                Box(
                    modifier = Modifier
                        .align(Alignment.TopStart)
                        .padding(8.dp)
                ) {
                    Icon(
                        imageVector = if (bookmark.type is Bookmark.Type.Video) Icons.Filled.Movie else Icons.Filled.Image,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(24.dp)
                    )
                }
            }

            // Gradient overlay on bottom third for text readability
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .align(Alignment.BottomCenter)
                    .background(
                        brush = androidx.compose.ui.graphics.Brush.verticalGradient(
                            colors = listOf(
                                Color.Transparent,
                                Color.Black.copy(alpha = 0.7f)
                            ),
                            startY = 0f,
                            endY = Float.POSITIVE_INFINITY
                        )
                    )
            )

            // Show progress indicator based on read progress
            if (bookmark.readProgress > 0) {
                Box(
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .padding(top = 8.dp, end = 8.dp)
                        .size(28.dp)
                        .background(
                            color = Color.Gray.copy(alpha = 0.5f),
                            shape = androidx.compose.foundation.shape.CircleShape
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    if (bookmark.readProgress == 100) {
                        // Show bold checkmark for completed
                        Icon(
                            imageVector = Icons.Filled.Check,
                            contentDescription = stringResource(R.string.action_mark_read),
                            tint = Color.White,
                            modifier = Modifier.size(20.dp)
                        )
                    } else {
                        // Show circular progress indicator that grows clockwise
                        CircularProgressIndicator(
                            progress = bookmark.readProgress,
                            modifier = Modifier.size(24.dp)
                        )
                    }
                }
            }

            // Content overlay at bottom
            Column(
                modifier = Modifier
                    .align(Alignment.BottomStart)
                    .fillMaxWidth()
                    .padding(8.dp)
            ) {
                // Title
                Text(
                    text = bookmark.title,
                    style = MaterialTheme.typography.titleMedium,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    color = Color.White
                )

                // Labels Row with clickable chips
                if (bookmark.labels.isNotEmpty()) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(top = 4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            painter = painterResource(R.drawable.ic_label_24px),
                            contentDescription = "labels",
                            tint = Color.White
                        )
                        Spacer(Modifier.width(8.dp))
                        FlowRow(
                            horizontalArrangement = Arrangement.spacedBy(6.dp),
                            verticalArrangement = Arrangement.spacedBy(4.dp),
                            modifier = Modifier.weight(1f)
                        ) {
                            bookmark.labels.forEach { label ->
                                SuggestionChip(
                                    onClick = { onClickLabel(label) },
                                    label = {
                                        Text(
                                            text = label,
                                            style = MaterialTheme.typography.labelMedium,
                                            color = Color.White
                                        )
                                    },
                                    colors = SuggestionChipDefaults.suggestionChipColors(
                                        containerColor = Color.White.copy(alpha = 0.2f),
                                        labelColor = Color.White
                                    ),
                                    border = BorderStroke(
                                        width = 1.dp,
                                        color = Color.White.copy(alpha = 0.3f)
                                    )
                                )
                            }
                        }
                    }
                }

                // Action Icons Row
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 0.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row(horizontalArrangement = Arrangement.Start) {
                        // Favorite Button
                        IconButton(
                            onClick = { onClickFavorite(bookmark.id, !bookmark.isMarked) },
                            modifier = Modifier
                                .width(48.dp)
                                .height(48.dp)
                        ) {
                            Icon(
                                imageVector = if (bookmark.isMarked) Icons.Filled.Grade else Icons.Outlined.Grade,
                                contentDescription = stringResource(R.string.action_favorite),
                                tint = Color.White
                            )
                        }

                        // Archive Button
                        IconButton(
                            onClick = { onClickArchive(bookmark.id, !bookmark.isArchived) },
                            modifier = Modifier
                                .width(48.dp)
                                .height(48.dp)
                        ) {
                            Icon(
                                imageVector = if (bookmark.isArchived) Icons.Filled.Inventory2 else Icons.Outlined.Inventory2,
                                contentDescription = stringResource(R.string.action_archive),
                                tint = Color.White
                            )
                        }

                        // Open Original Button
                        IconButton(
                            onClick = { onClickOpenUrl(bookmark.id) },
                            modifier = Modifier
                                .width(48.dp)
                                .height(48.dp)
                        ) {
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.OpenInNew,
                                contentDescription = stringResource(R.string.action_view_original),
                                tint = Color.White,
                                modifier = Modifier.size(20.dp)
                            )
                        }
                    }

                    // Delete Button (right side)
                    IconButton(
                        onClick = { onClickDelete(bookmark.id) },
                        modifier = Modifier
                            .width(48.dp)
                            .height(48.dp)
                    ) {
                        Icon(
                            Icons.Filled.Delete,
                            contentDescription = stringResource(R.string.action_delete),
                            tint = Color.White
                        )
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun BookmarkGridCard(
    bookmark: BookmarkListItem,
    onClickCard: (String) -> Unit,
    onClickDelete: (String) -> Unit,
    onClickFavorite: (String, Boolean) -> Unit,
    onClickShareBookmark: (String) -> Unit,
    onClickArchive: (String, Boolean) -> Unit,
    onClickLabel: (String) -> Unit = {},
    onClickOpenUrl: (String) -> Unit = {}
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 12.dp, vertical = 8.dp)
            .clickable { onClickCard(bookmark.id) }
    ) {
        Row(
            modifier = Modifier.fillMaxWidth()
        ) {
            // Thumbnail
            Box {
                SubcomposeAsyncImage(
                    model = ImageRequest.Builder(LocalContext.current).data(bookmark.thumbnailSrc)
                        .crossfade(true).build(),
                    contentDescription = stringResource(R.string.common_bookmark_image_content_description),
                    contentScale = ContentScale.Crop,
                    error = {
                        ErrorPlaceholderImage(
                            modifier = Modifier
                                .width(100.dp)
                                .height(80.dp),
                            imageContentDescription = stringResource(R.string.common_bookmark_image_content_description)
                        )
                    },
                    modifier = Modifier
                        .width(100.dp)
                        .height(80.dp)
                )

                // Type icon overlay for Grid
                if (bookmark.type is Bookmark.Type.Video || bookmark.type is Bookmark.Type.Picture) {
                    Box(
                        modifier = Modifier
                            .align(Alignment.TopStart)
                            .padding(6.dp)
                    ) {
                        Icon(
                            imageVector = if (bookmark.type is Bookmark.Type.Video) Icons.Filled.Movie else Icons.Filled.Image,
                            contentDescription = null,
                            tint = Color.White,
                            modifier = Modifier.size(16.dp)
                        )
                    }
                }
                // Read progress indicator
                if (bookmark.readProgress > 0) {
                    Box(
                        modifier = Modifier
                            .size(28.dp)
                            .align(Alignment.TopEnd)
                            .padding(4.dp)
                            .background(
                                color = Color.Gray.copy(alpha = 0.5f),
                                shape = CircleShape
                            ),
                        contentAlignment = Alignment.Center
                    ) {
                        if (bookmark.readProgress == 100) {
                            Icon(
                                imageVector = Icons.Filled.Check,
                                contentDescription = stringResource(R.string.action_mark_read),
                                tint = Color.White,
                                modifier = Modifier.size(16.dp)
                            )
                        } else {
                            Canvas(
                                modifier = Modifier.size(20.dp)
                            ) {
                                val progressColor = Color.White
                                val strokeWidth = 2.dp.toPx()
                                val diameter = size.minDimension
                                val sweepAngle = (bookmark.readProgress / 100f) * 360f
                                drawArc(
                                    color = progressColor,
                                    startAngle = -90f,
                                    sweepAngle = sweepAngle,
                                    useCenter = false,
                                    size = Size(diameter - strokeWidth, diameter - strokeWidth),
                                    style = Stroke(width = strokeWidth, cap = StrokeCap.Round)
                                )
                            }
                        }
                    }
                }
            }

            // Content
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(8.dp)
            ) {
                // Title
                Text(
                    text = bookmark.title,
                    style = MaterialTheme.typography.titleSmall,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.padding(bottom = 4.dp)
                )

                // Site and read time
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    AsyncImage(
                        model = ImageRequest.Builder(LocalContext.current).data(bookmark.iconSrc)
                            .crossfade(true).build(),
                        contentDescription = "site icon",
                        contentScale = ContentScale.Fit,
                        modifier = Modifier
                            .width(16.dp)
                            .height(16.dp),
                    )
                    Spacer(Modifier.width(4.dp))
                    Text(
                        text = bookmark.siteName,
                        style = MaterialTheme.typography.labelMedium,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis,
                        modifier = Modifier.weight(1f)
                    )
                    bookmark.readingTime?.let {
                        Text(
                            text = "  ",
                            style = MaterialTheme.typography.labelMedium
                        )
                        Text(
                            text = "$it min",
                            style = MaterialTheme.typography.labelMedium
                        )
                    }
                }

                // Labels row
                if (bookmark.labels.isNotEmpty()) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(top = 4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            painter = painterResource(R.drawable.ic_label_24px),
                            contentDescription = "labels",
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(Modifier.width(4.dp))
                        val labels = bookmark.labels.joinToString(", ")
                        Text(
                            text = labels,
                            style = MaterialTheme.typography.labelMedium,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                    }
                }

                // Action buttons
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 4.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Row(horizontalArrangement = Arrangement.Start) {
                        IconButton(
                            onClick = { onClickFavorite(bookmark.id, !bookmark.isMarked) },
                            modifier = Modifier.size(36.dp)
                        ) {
                            Icon(
                                imageVector = if (bookmark.isMarked) Icons.Filled.Grade else Icons.Outlined.Grade,
                                contentDescription = stringResource(R.string.action_favorite),
                                modifier = Modifier.size(20.dp)
                            )
                        }
                        IconButton(
                            onClick = { onClickArchive(bookmark.id, !bookmark.isArchived) },
                            modifier = Modifier.size(36.dp)
                        ) {
                            Icon(
                                imageVector = if (bookmark.isArchived) Icons.Filled.Inventory2 else Icons.Outlined.Inventory2,
                                contentDescription = stringResource(R.string.action_archive),
                                modifier = Modifier.size(20.dp)
                            )
                        }
                        IconButton(
                            onClick = { onClickOpenUrl(bookmark.id) },
                            modifier = Modifier.size(36.dp)
                        ) {
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.OpenInNew,
                                contentDescription = stringResource(R.string.action_view_original),
                                modifier = Modifier.size(20.dp)
                            )
                        }
                    }
                    IconButton(
                        onClick = { onClickDelete(bookmark.id) },
                        modifier = Modifier.size(36.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Delete,
                            contentDescription = stringResource(R.string.action_delete),
                            modifier = Modifier.size(20.dp)
                        )
                    }
                }
            }
        }
        HorizontalDivider()
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun BookmarkCompactCard(
    bookmark: BookmarkListItem,
    onClickCard: (String) -> Unit,
    onClickDelete: (String) -> Unit,
    onClickFavorite: (String, Boolean) -> Unit,
    onClickShareBookmark: (String) -> Unit,
    onClickArchive: (String, Boolean) -> Unit,
    onClickLabel: (String) -> Unit = {},
    onClickOpenUrl: (String) -> Unit = {}
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClickCard(bookmark.id) }
            .padding(horizontal = 16.dp, vertical = 8.dp)
    ) {
        // Title row with favicon aligned to top
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.Top
        ) {
            // Favicon
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current).data(bookmark.iconSrc)
                    .crossfade(true).build(),
                contentDescription = "site icon",
                contentScale = ContentScale.Fit,
                modifier = Modifier
                    .padding(top = 2.dp)
                    .width(24.dp)
                    .height(24.dp),
            )

            Spacer(Modifier.width(12.dp))

            // Title
            Text(
                text = bookmark.title,
                style = MaterialTheme.typography.bodyMedium,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis,
                modifier = Modifier.weight(1f)
            )
        }

        // Site row with progress indicator
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(start = 36.dp, top = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Read progress indicator (theme-aware)
            if (bookmark.readProgress > 0 && bookmark.readProgress < 100) {
                val progressColor = if (MaterialTheme.colorScheme.background.luminance() > 0.5f) {
                    Color.DarkGray // Light theme - dark icon
                } else {
                    Color.LightGray // Dark theme - light icon
                }
                Box(
                    modifier = Modifier
                        .size(20.dp)
                        .background(
                            color = Color.Gray.copy(alpha = 0.3f),
                            shape = CircleShape
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Canvas(
                        modifier = Modifier.size(14.dp)
                    ) {
                        val strokeWidth = 2.dp.toPx()
                        val diameter = size.minDimension
                        val sweepAngle = (bookmark.readProgress / 100f) * 360f
                        drawArc(
                            color = progressColor,
                            startAngle = -90f,
                            sweepAngle = sweepAngle,
                            useCenter = false,
                            size = Size(diameter - strokeWidth, diameter - strokeWidth),
                            style = Stroke(width = strokeWidth, cap = StrokeCap.Round)
                        )
                    }
                }
                Spacer(Modifier.width(8.dp))
            }

            Text(
                text = bookmark.siteName,
                style = MaterialTheme.typography.labelSmall
            )
            bookmark.readingTime?.let {
                Text(
                    text = "  ",
                    style = MaterialTheme.typography.labelSmall
                )
                Text(
                    text = "$it min",
                    style = MaterialTheme.typography.labelSmall
                )
            }
        }

        // Labels row
        if (bookmark.labels.isNotEmpty()) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(start = 36.dp, top = 4.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    painter = painterResource(R.drawable.ic_label_24px),
                    contentDescription = "labels",
                    modifier = Modifier.size(14.dp)
                )
                Spacer(Modifier.width(4.dp))
                val labels = bookmark.labels.joinToString(", ")
                Text(
                    text = labels,
                    style = MaterialTheme.typography.labelSmall,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }
        }

        // Action buttons (same arrangement as Grid)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(start = 36.dp, top = 4.dp),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Row(horizontalArrangement = Arrangement.Start) {
                IconButton(
                    onClick = { onClickFavorite(bookmark.id, !bookmark.isMarked) },
                    modifier = Modifier.size(32.dp)
                ) {
                    Icon(
                        imageVector = if (bookmark.isMarked) Icons.Filled.Grade else Icons.Outlined.Grade,
                        contentDescription = stringResource(R.string.action_favorite),
                        modifier = Modifier.size(18.dp)
                    )
                }
                IconButton(
                    onClick = { onClickArchive(bookmark.id, !bookmark.isArchived) },
                    modifier = Modifier.size(32.dp)
                ) {
                    Icon(
                        imageVector = if (bookmark.isArchived) Icons.Filled.Inventory2 else Icons.Outlined.Inventory2,
                        contentDescription = stringResource(R.string.action_archive),
                        modifier = Modifier.size(18.dp)
                    )
                }
                IconButton(
                    onClick = { onClickOpenUrl(bookmark.id) },
                    modifier = Modifier.size(32.dp)
                ) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.OpenInNew,
                        contentDescription = stringResource(R.string.action_view_original),
                        modifier = Modifier.size(18.dp)
                    )
                }
            }
            IconButton(
                onClick = { onClickDelete(bookmark.id) },
                modifier = Modifier.size(32.dp)
            ) {
                Icon(
                    imageVector = Icons.Filled.Delete,
                    contentDescription = stringResource(R.string.action_delete),
                    modifier = Modifier.size(18.dp)
                )
            }
        }
    }
    HorizontalDivider()
}

@Composable
fun CircularProgressIndicator(
    progress: Int,
    modifier: Modifier = Modifier
) {
    val progressColor = Color.White

    Canvas(modifier = modifier) {
        val strokeWidth = 3.dp.toPx()
        val diameter = size.minDimension
        val radius = (diameter - strokeWidth) / 2f
        val topLeft = Offset(
            x = (size.width - diameter) / 2f + strokeWidth / 2f,
            y = (size.height - diameter) / 2f + strokeWidth / 2f
        )
        val arcSize = Size(diameter - strokeWidth, diameter - strokeWidth)

        // Calculate sweep angle based on progress (0-100)
        // Start at -90 degrees (12 o'clock position) and sweep clockwise
        val sweepAngle = (progress / 100f) * 360f

        // Draw the circular arc
        drawArc(
            color = progressColor,
            startAngle = -90f,
            sweepAngle = sweepAngle,
            useCenter = false,
            topLeft = topLeft,
            size = arcSize,
            style = Stroke(
                width = strokeWidth,
                cap = StrokeCap.Round
            )
        )
    }
}

@Preview(showBackground = true)
@Composable
fun BookmarkCardPreview() {
    val previewHandler = AsyncImagePreviewHandler {
        ColorImage(Color.Red.toArgb())
    }
    val sampleBookmark = BookmarkListItem(
        id = "1",
        url = "https://example.com",
        title = "Sample Bookmark",
        siteName = "Example",
        type = Bookmark.Type.Article,
        isMarked = false,
        isArchived = false,
        labels = listOf(
            "one",
            "two",
            "three",
            "fourhundretandtwentyone",
            "threethousendtwohundretandfive"
        ),
        isRead = true,
        readProgress = 100,
        iconSrc = "https://picsum.photos/seed/picsum/640/480",
        imageSrc = "https://picsum.photos/seed/picsum/640/480",
        thumbnailSrc = "https://picsum.photos/seed/picsum/640/480",
        readingTime = 8,
        created = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()),
        wordCount = 2000,
        published = null
    )
    CompositionLocalProvider(LocalAsyncImagePreviewHandler provides previewHandler) {
        BookmarkMosaicCard(
            bookmark = sampleBookmark,
            onClickCard = {},
            onClickDelete = {},
            onClickFavorite = { _, _ -> },
            onClickArchive = { _, _ -> },
            onClickShareBookmark = {_ -> }
        )
    }
}
</file>

<file path="app/src/main/java/com/mydeck/app/ui/list/BookmarkListScreen.kt">
package com.mydeck.app.ui.list

import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material.icons.filled.CloudOff
import androidx.compose.material.icons.filled.Grade
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Sort
import androidx.compose.material.icons.filled.GridView
import androidx.compose.material.icons.filled.Apps
import androidx.compose.material.icons.automirrored.filled.List
import androidx.compose.material.icons.automirrored.filled.ViewList
import androidx.compose.material.icons.outlined.Info
import androidx.compose.material.icons.outlined.Inventory2
import androidx.compose.material.icons.outlined.Label
import androidx.compose.material.icons.outlined.Settings
import androidx.compose.material.icons.outlined.TaskAlt
import androidx.compose.material3.AlertDialog
import androidx.compose.foundation.BorderStroke
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.RadioButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.NavigationDrawerItem
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SuggestionChip
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.material3.pulltorefresh.rememberPullToRefreshState
import androidx.compose.material3.rememberDrawerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.platform.LocalClipboardManager
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import androidx.navigation.compose.rememberNavController
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import com.mydeck.app.R
import com.mydeck.app.domain.model.Bookmark
import com.mydeck.app.domain.model.BookmarkListItem
import com.mydeck.app.domain.model.LayoutMode
import com.mydeck.app.domain.model.SortOption
import com.mydeck.app.ui.components.ShareBookmarkChooser
import com.mydeck.app.ui.navigation.AboutRoute
import com.mydeck.app.ui.navigation.BookmarkDetailRoute
import com.mydeck.app.ui.navigation.SettingsRoute
import com.mydeck.app.util.openUrlInCustomTab
import kotlinx.coroutines.launch
import androidx.compose.material3.Badge
import com.mydeck.app.ui.theme.Typography

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BookmarkListScreen(navHostController: NavHostController) {
    val viewModel: BookmarkListViewModel = hiltViewModel()
    val navigationEvent = viewModel.navigationEvent.collectAsState()
    val openUrlEvent = viewModel.openUrlEvent.collectAsState()
    val uiState = viewModel.uiState.collectAsState().value
    val createBookmarkUiState = viewModel.createBookmarkUiState.collectAsState().value
    val bookmarkCounts = viewModel.bookmarkCounts.collectAsState()
    val labelsWithCounts = viewModel.labelsWithCounts.collectAsState()

    // Collect filter states
    val filterState = viewModel.filterState.collectAsState()
    val isSearchActive = viewModel.isSearchActive.collectAsState()
    val searchQuery = viewModel.searchQuery.collectAsState()
    val layoutMode = viewModel.layoutMode.collectAsState()
    val sortOption = viewModel.sortOption.collectAsState()
    val isOnline = viewModel.isOnline.collectAsState()

    var showLayoutMenu by remember { androidx.compose.runtime.mutableStateOf(false) }
    var showSortMenu by remember { androidx.compose.runtime.mutableStateOf(false) }

    // Label edit/delete state
    var isEditingLabel by remember { mutableStateOf(false) }
    var editedLabelName by remember { mutableStateOf("") }
    var pendingDeleteLabel by remember { mutableStateOf<String?>(null) }
    var deleteLabelJob by remember { mutableStateOf<kotlinx.coroutines.Job?>(null) }
    val labelEditFocusRequester = remember { FocusRequester() }

    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()
    val snackbarHostState = remember { SnackbarHostState() }

    val pullToRefreshState = rememberPullToRefreshState()
    val isLoading by viewModel.loadBookmarksIsRunning.collectAsState()

    // UI event handlers (pass filter update functions)
    val onClickFilterMyList: () -> Unit = { viewModel.onClickMyList() }
    val onClickFilterArchive: () -> Unit = { viewModel.onClickArchive() }
    val onClickFilterFavorite: () -> Unit = { viewModel.onClickFavorite() }
    val onClickSettings: () -> Unit = { viewModel.onClickSettings() }
    val onClickBookmark: (String) -> Unit = { bookmarkId -> viewModel.onClickBookmark(bookmarkId) }
    val onClickDelete: (String) -> Unit = { bookmarkId ->
        viewModel.onDeleteBookmark(bookmarkId)
        scope.launch {
            val result = snackbarHostState.showSnackbar(
                message = "Bookmark deleted",
                actionLabel = "UNDO",
                duration = SnackbarDuration.Long
            )
            if (result == androidx.compose.material3.SnackbarResult.ActionPerformed) {
                viewModel.onCancelDeleteBookmark()
            }
        }
    }
    val onClickFavorite: (String, Boolean) -> Unit = { bookmarkId, isFavorite -> viewModel.onToggleFavoriteBookmark(bookmarkId, isFavorite) }
    val onClickArchive: (String, Boolean) -> Unit = { bookmarkId, isArchived -> viewModel.onToggleArchiveBookmark(bookmarkId, isArchived) }
    val onClickShareBookmark: (String) -> Unit = { url -> viewModel.onClickShareBookmark(url) }
    val onClickOpenUrl: (String) -> Unit = { bookmarkId ->
        viewModel.onClickBookmarkOpenOriginal(bookmarkId)
    }

    LaunchedEffect(key1 = navigationEvent.value) {
        navigationEvent.value?.let { event ->
            when (event) {
                is BookmarkListViewModel.NavigationEvent.NavigateToSettings -> {
                    navHostController.navigate(SettingsRoute)
                    scope.launch { drawerState.close() }
                }

                is BookmarkListViewModel.NavigationEvent.NavigateToAbout -> {
                    navHostController.navigate(AboutRoute)
                    scope.launch { drawerState.close() }
                }

                is BookmarkListViewModel.NavigationEvent.NavigateToBookmarkDetail -> {
                    navHostController.navigate(BookmarkDetailRoute(event.bookmarkId, event.showOriginal))
                }
            }
            viewModel.onNavigationEventConsumed() // Consume the event
        }
    }

    val context = LocalContext.current
    LaunchedEffect(key1 = openUrlEvent.value) {
        openUrlInCustomTab(context, openUrlEvent.value)
        viewModel.onOpenUrlEventConsumed()
    }

    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            ModalDrawerSheet {
                Column(
                    modifier = Modifier
                        .padding(horizontal = 16.dp)
                        .verticalScroll(rememberScrollState())
                ) {
                    Spacer(Modifier.height(12.dp))
                    Row(
                        modifier = Modifier.padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            stringResource(id = R.string.app_name),
                            style = MaterialTheme.typography.titleLarge
                        )
                        if (!isOnline.value) {
                            Spacer(Modifier.width(8.dp))
                            Icon(
                                imageVector = Icons.Default.CloudOff,
                                contentDescription = stringResource(R.string.offline_tooltip),
                                modifier = Modifier.size(18.dp),
                                tint = MaterialTheme.colorScheme.error
                            )
                        }
                    }
                    HorizontalDivider()
                    NavigationDrawerItem(
                        label = { Text(
                            style = Typography.labelLarge,
                            text = stringResource(id = R.string.my_list)
                        ) },
                        icon = { Icon(imageVector = Icons.Outlined.TaskAlt, contentDescription = null)},
                        badge = {
                            val myListCount = bookmarkCounts.value.total - bookmarkCounts.value.archived
                            if (myListCount > 0) {
                                Badge(containerColor = MaterialTheme.colorScheme.secondaryContainer) {
                                    Text(
                                        text = myListCount.toString()
                                    )
                                }
                            }
                        },
                        selected = filterState.value.archived == false,
                        onClick = {
                            onClickFilterMyList()
                            scope.launch { drawerState.close() }
                        }
                    )
                    NavigationDrawerItem(
                        label = { Text(
                            style = Typography.labelLarge,
                            text = stringResource(id = R.string.archive)
                        ) },
                        icon = { Icon(imageVector = Icons.Outlined.Inventory2, contentDescription = null) },
                        badge = {
                            bookmarkCounts.value.archived.let { count ->
                                if (count > 0) {
                                    Badge(containerColor = MaterialTheme.colorScheme.secondaryContainer) {
                                        Text(
                                            text = count.toString()
                                        )
                                    }
                                }
                            }
                        },
                        selected = filterState.value.archived == true,
                        onClick = {
                            onClickFilterArchive()
                            scope.launch { drawerState.close() }
                        }
                    )
                    HorizontalDivider()
                    NavigationDrawerItem(
                        label = { Text(
                            style = Typography.labelLarge,
                            text = stringResource(id = R.string.favorites)
                        ) },
                        icon = { Icon(imageVector = Icons.Filled.Grade, contentDescription = null) },
                        badge = {
                            bookmarkCounts.value.favorite.let { count ->
                                if (count > 0) {
                                    Badge(containerColor = MaterialTheme.colorScheme.secondaryContainer) {
                                        Text(
                                            text = count.toString()
                                        )
                                    }
                                }
                            }
                        },
                        selected = filterState.value.favorite == true,
                        onClick = {
                            onClickFilterFavorite()
                            scope.launch { drawerState.close() }
                        }
                    )
                    NavigationDrawerItem(
                        label = { Text(
                            style = Typography.labelLarge,
                            text = stringResource(id = R.string.labels)
                        ) },
                        icon = { Icon(Icons.Outlined.Label, contentDescription = null) },
                        badge = {
                            if (labelsWithCounts.value.isNotEmpty()) {
                                Badge(containerColor = MaterialTheme.colorScheme.secondaryContainer) {
                                    Text(
                                        text = labelsWithCounts.value.size.toString()
                                    )
                                }
                            }
                        },
                        selected = filterState.value.viewingLabelsList || filterState.value.label != null,
                        onClick = {
                            viewModel.onClickLabelsView()
                            scope.launch { drawerState.close() }
                        }
                    )
                    HorizontalDivider()
                    NavigationDrawerItem(
                        label = { Text(
                            style = Typography.labelLarge,
                            text = stringResource(id = R.string.settings)
                        ) },
                        icon = { Icon(imageVector = Icons.Outlined.Settings, contentDescription = null) },
                        selected = false,
                        onClick = {
                            onClickSettings()
                            scope.launch { drawerState.close() }
                        }
                    )
                    NavigationDrawerItem(
                        label = { Text(
                            style = Typography.labelLarge,
                            text = stringResource(id = R.string.about_title)
                        ) },
                        icon = { Icon(imageVector = Icons.Outlined.Info, contentDescription = null) },
                        selected = false,
                        onClick = {
                            viewModel.onClickAbout()
                            scope.launch { drawerState.close() }
                        }
                    )
                }
            }
        }
    ) {
        Scaffold(
            snackbarHost = { SnackbarHost(snackbarHostState) },
            topBar = {
                // Determine the current view title based on filter state
                val currentViewTitle = when {
                    filterState.value.viewingLabelsList -> stringResource(id = R.string.select_label)
                    filterState.value.label != null -> "Label..."
                    filterState.value.archived == false -> stringResource(id = R.string.my_list)
                    filterState.value.archived == true -> stringResource(id = R.string.archive)
                    filterState.value.favorite == true -> stringResource(id = R.string.favorites)
                    else -> stringResource(id = R.string.my_list) // Default to My List
                }

                val searchFocusRequester = remember { FocusRequester() }

                LaunchedEffect(isSearchActive.value) {
                    if (isSearchActive.value) {
                        searchFocusRequester.requestFocus()
                    }
                }

                TopAppBar(
                    title = {
                        if (isSearchActive.value) {
                            OutlinedTextField(
                                value = searchQuery.value,
                                onValueChange = { viewModel.onSearchQueryChange(it) },
                                placeholder = {
                                    Text(stringResource(R.string.search_bookmarks))
                                },
                                leadingIcon = {
                                    Icon(Icons.Filled.Search, contentDescription = null)
                                },
                                trailingIcon = {
                                    if (searchQuery.value.isNotEmpty()) {
                                        IconButton(onClick = { viewModel.onClearSearch() }) {
                                            Icon(Icons.Filled.Clear, contentDescription = stringResource(R.string.clear_search))
                                        }
                                    }
                                },
                                singleLine = true,
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .focusRequester(searchFocusRequester)
                            )
                        } else {
                            Text(currentViewTitle)
                        }
                    },
                    navigationIcon = {
                        if (isSearchActive.value) {
                            IconButton(onClick = { viewModel.onSearchActiveChange(false) }) {
                                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = stringResource(R.string.close_search))
                            }
                        } else {
                            IconButton(
                                onClick = { scope.launch { drawerState.open() } }
                            ) {
                                Icon(
                                    imageVector = Icons.Filled.Menu,
                                    contentDescription = stringResource(id = R.string.menu)
                                )
                            }
                        }
                    },
                    actions = {
                        if (!isSearchActive.value && !filterState.value.viewingLabelsList) {
                            // Sort button with dropdown
                            Box {
                                IconButton(onClick = { showSortMenu = true }) {
                                    Icon(Icons.Filled.Sort, contentDescription = "Sort")
                                }
                                DropdownMenu(
                                    expanded = showSortMenu,
                                    onDismissRequest = { showSortMenu = false }
                                ) {
                                    SortOption.entries.forEach { option ->
                                        DropdownMenuItem(
                                            text = {
                                                Text(
                                                    text = option.displayName,
                                                    fontWeight = if (option == sortOption.value) androidx.compose.ui.text.font.FontWeight.Bold else androidx.compose.ui.text.font.FontWeight.Normal
                                                )
                                            },
                                            onClick = {
                                                viewModel.onSortOptionSelected(option)
                                                showSortMenu = false
                                            }
                                        )
                                    }
                                }
                            }

                            // Layout button with dropdown
                            Box {
                                IconButton(onClick = { showLayoutMenu = true }) {
                                    Icon(Icons.Filled.GridView, contentDescription = "Layout")
                                }
                                DropdownMenu(
                                    expanded = showLayoutMenu,
                                    onDismissRequest = { showLayoutMenu = false }
                                ) {
                                    LayoutMode.entries.forEach { mode ->
                                        DropdownMenuItem(
                                            leadingIcon = {
                                                Icon(
                                                    imageVector = when (mode) {
                                                        LayoutMode.GRID -> Icons.Filled.Apps
                                                        LayoutMode.COMPACT -> Icons.AutoMirrored.Filled.List
                                                        LayoutMode.MOSAIC -> Icons.Filled.GridView
                                                    },
                                                    contentDescription = null
                                                )
                                            },
                                            text = {
                                                Text(
                                                    text = mode.displayName,
                                                    fontWeight = if (mode == layoutMode.value) androidx.compose.ui.text.font.FontWeight.Bold else androidx.compose.ui.text.font.FontWeight.Normal
                                                )
                                            },
                                            onClick = {
                                                viewModel.onLayoutModeSelected(mode)
                                                showLayoutMenu = false
                                            }
                                        )
                                    }
                                }
                            }

                            // Search button
                            IconButton(onClick = { viewModel.onSearchActiveChange(true) }) {
                                Icon(Icons.Filled.Search, contentDescription = stringResource(R.string.search))
                            }
                        }
                    }
                )
            },
            floatingActionButton = {
                val clipboardManager = LocalClipboardManager.current
                FloatingActionButton(
                    onClick = {
                        val clipboardText = clipboardManager.getText()?.text
                        viewModel.openCreateBookmarkDialog(clipboardText)
                    }
                ) {
                    Icon(
                        imageVector = Icons.Filled.Add,
                        contentDescription = stringResource(id = R.string.add_bookmark)
                    )
                }
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .padding(padding)
                    .fillMaxWidth()
            ) {
                // Subheader with label name, edit icon, and delete icon when filtering by label
                if (filterState.value.label != null) {
                    val labelDeletedMessageFormat = stringResource(R.string.label_deleted)
                    val currentLabel = filterState.value.label!!

                    // Focus on edit field when entering edit mode and set cursor at end
                    LaunchedEffect(isEditingLabel) {
                        if (isEditingLabel) {
                            labelEditFocusRequester.requestFocus()
                        }
                    }

                    Column(
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp, vertical = 4.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            if (isEditingLabel) {
                                TextField(
                                    value = editedLabelName,
                                    onValueChange = { editedLabelName = it },
                                    singleLine = true,
                                    textStyle = MaterialTheme.typography.titleMedium.copy(
                                        color = MaterialTheme.colorScheme.onSurface
                                    ),
                                    colors = TextFieldDefaults.colors(
                                        focusedContainerColor = MaterialTheme.colorScheme.surface,
                                        unfocusedContainerColor = MaterialTheme.colorScheme.surface,
                                        focusedIndicatorColor = MaterialTheme.colorScheme.primary,
                                        unfocusedIndicatorColor = MaterialTheme.colorScheme.outline,
                                        focusedTextColor = MaterialTheme.colorScheme.onSurface,
                                        unfocusedTextColor = MaterialTheme.colorScheme.onSurface,
                                        focusedLabelColor = MaterialTheme.colorScheme.primary
                                    ),
                                    modifier = Modifier
                                        .weight(1f)
                                        .focusRequester(labelEditFocusRequester),
                                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),
                                    keyboardActions = KeyboardActions(
                                        onDone = {
                                            if (editedLabelName.isNotBlank() && editedLabelName != currentLabel) {
                                                viewModel.onRenameLabel(currentLabel, editedLabelName)
                                            }
                                            isEditingLabel = false
                                        }
                                    )
                                )
                                IconButton(
                                    onClick = {
                                        // Save the edited label
                                        if (editedLabelName.isNotBlank() && editedLabelName != currentLabel) {
                                            viewModel.onRenameLabel(currentLabel, editedLabelName)
                                        }
                                        isEditingLabel = false
                                    },
                                    modifier = Modifier.size(40.dp)
                                ) {
                                    Icon(
                                        Icons.Filled.Check,
                                        contentDescription = "Save",
                                        modifier = Modifier.size(20.dp)
                                    )
                                }
                            } else {
                                Box(
                                    modifier = Modifier
                                        .weight(1f)
                                        .border(
                                            width = 1.dp,
                                            color = MaterialTheme.colorScheme.outline,
                                            shape = RoundedCornerShape(8.dp)
                                        )
                                        .padding(horizontal = 12.dp, vertical = 8.dp),
                                    contentAlignment = Alignment.CenterStart
                                ) {
                                    Text(
                                        currentLabel,
                                        style = MaterialTheme.typography.titleMedium
                                    )
                                }
                                IconButton(
                                    onClick = {
                                        editedLabelName = currentLabel
                                        isEditingLabel = true
                                    },
                                    modifier = Modifier.size(40.dp)
                                ) {
                                    Icon(
                                        Icons.Filled.Edit,
                                        contentDescription = stringResource(id = R.string.edit_label),
                                        modifier = Modifier.size(20.dp)
                                    )
                                }
                                IconButton(
                                    onClick = {
                                        // Cancel any existing delete operation
                                        deleteLabelJob?.cancel()

                                        // Set pending delete
                                        pendingDeleteLabel = currentLabel

                                        // Show snackbar with undo option
                                        scope.launch {
                                            val result = snackbarHostState.showSnackbar(
                                                message = labelDeletedMessageFormat.format(currentLabel),
                                                actionLabel = "UNDO",
                                                duration = SnackbarDuration.Long
                                            )

                                            if (result == androidx.compose.material3.SnackbarResult.ActionPerformed) {
                                                // User clicked undo, cancel the deletion
                                                deleteLabelJob?.cancel()
                                                pendingDeleteLabel = null
                                            }
                                        }

                                        // Schedule the actual deletion after 10 seconds
                                        deleteLabelJob = scope.launch {
                                            kotlinx.coroutines.delay(10000)
                                            if (pendingDeleteLabel == currentLabel) {
                                                viewModel.onDeleteLabel(currentLabel)
                                                pendingDeleteLabel = null
                                            }
                                        }
                                    },
                                    modifier = Modifier.size(40.dp)
                                ) {
                                    Icon(
                                        Icons.Filled.Delete,
                                        contentDescription = stringResource(id = R.string.delete_label),
                                        modifier = Modifier.size(20.dp)
                                    )
                                }
                            }
                        }
                        HorizontalDivider()
                    }
                }

                PullToRefreshBox(
                    isRefreshing = isLoading,
                    onRefresh = { viewModel.onPullToRefresh() },
                    state = pullToRefreshState,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // Show labels list if viewing labels, otherwise show bookmarks list
                    if (filterState.value.viewingLabelsList) {
                    LabelsListView(
                        labels = labelsWithCounts.value,
                        onLabelSelected = { label ->
                            viewModel.onClickLabel(label)
                        }
                    )
                } else {
                    when (uiState) {
                        is BookmarkListViewModel.UiState.Empty -> {
                            EmptyScreen(messageResource = uiState.messageResource)
                        }
                        is BookmarkListViewModel.UiState.Success -> {
                            LaunchedEffect(key1 = uiState.updateBookmarkState) {
                                uiState.updateBookmarkState?.let { result ->
                                    val message = when (result) {
                                        is BookmarkListViewModel.UpdateBookmarkState.Success -> {
                                            "success"
                                        }

                                        is BookmarkListViewModel.UpdateBookmarkState.Error -> {
                                            result.message
                                        }
                                    }
                                    snackbarHostState.showSnackbar(
                                        message = message,
                                        duration = SnackbarDuration.Short
                                    )
                                }
                            }
                            BookmarkListView(
                                layoutMode = layoutMode.value,
                                bookmarks = uiState.bookmarks,
                                onClickBookmark = onClickBookmark,
                                onClickDelete = onClickDelete,
                                onClickArchive = onClickArchive,
                                onClickFavorite = onClickFavorite,
                                onClickShareBookmark = onClickShareBookmark,
                                onClickLabel = { label -> viewModel.onClickLabel(label) },
                                onClickOpenUrl = onClickOpenUrl
                            )
                            // Consumes a shareIntent and creates the corresponding share dialog
                            ShareBookmarkChooser(
                                context = LocalContext.current,
                                intent = viewModel.shareIntent.collectAsState().value,
                                onShareIntentConsumed = { viewModel.onShareIntentConsumed() }
                            )
                        }
                    }
                }
                }
            }

            // Show the CreateBookmarkDialog based on the state
            when (createBookmarkUiState) {
                is BookmarkListViewModel.CreateBookmarkUiState.Open -> {
                    CreateBookmarkDialog(
                        onDismiss = { viewModel.closeCreateBookmarkDialog() },
                        title = createBookmarkUiState.title,
                        url = createBookmarkUiState.url,
                        urlError = createBookmarkUiState.urlError,
                        isCreateEnabled = createBookmarkUiState.isCreateEnabled,
                        labels = createBookmarkUiState.labels,
                        onTitleChange = { viewModel.updateCreateBookmarkTitle(it) },
                        onUrlChange = { viewModel.updateCreateBookmarkUrl(it) },
                        onLabelsChange = { viewModel.updateCreateBookmarkLabels(it) },
                        onCreateBookmark = { viewModel.createBookmark() }
                    )
                }

                is BookmarkListViewModel.CreateBookmarkUiState.Loading -> {
                    // Show a loading indicator
                    Dialog(onDismissRequest = { viewModel.closeCreateBookmarkDialog() }) {
                        CircularProgressIndicator()
                    }
                }

                is BookmarkListViewModel.CreateBookmarkUiState.Success -> {
                    // Optionally show a success message
                    LaunchedEffect(key1 = createBookmarkUiState) {
                        // Dismiss the dialog after a short delay
                        scope.launch {
                            kotlinx.coroutines.delay(1000)
                            viewModel.closeCreateBookmarkDialog()
                        }
                    }
                }

                is BookmarkListViewModel.CreateBookmarkUiState.Error -> {
                    // Show an error message
                    AlertDialog(
                        onDismissRequest = { viewModel.closeCreateBookmarkDialog() },
                        title = { Text(stringResource(id = R.string.error)) },
                        text = { Text(createBookmarkUiState.message) },
                        confirmButton = {
                            TextButton(onClick = { viewModel.closeCreateBookmarkDialog() }) {
                                Text(stringResource(id = R.string.ok))
                            }
                        }
                    )
                }

                is BookmarkListViewModel.CreateBookmarkUiState.Closed -> {
                    // Do nothing when the dialog is closed
                }
            }

        }
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun CreateBookmarkDialog(
    onDismiss: () -> Unit,
    title: String,
    url: String,
    urlError: Int?,
    isCreateEnabled: Boolean,
    labels: List<String>,
    onTitleChange: (String) -> Unit,
    onUrlChange: (String) -> Unit,
    onLabelsChange: (List<String>) -> Unit,
    onCreateBookmark: () -> Unit
) {
    var newLabelInput by remember { mutableStateOf("") }
    val keyboardController = LocalSoftwareKeyboardController.current

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(stringResource(id = R.string.add_new_bookmark)) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                // URL field
                OutlinedTextField(
                    value = url,
                    onValueChange = { onUrlChange(it) },
                    isError = urlError != null,
                    label = { Text(stringResource(id = R.string.url)) },
                    supportingText = {
                        urlError?.let {
                            Text(text = stringResource(it))
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )

                // Title field
                OutlinedTextField(
                    value = title,
                    onValueChange = { onTitleChange(it) },
                    label = { Text(stringResource(id = R.string.title)) },
                    modifier = Modifier.fillMaxWidth()
                )

                // Labels Section
                CreateBookmarkLabelsSection(
                    labels = labels,
                    newLabelInput = newLabelInput,
                    onNewLabelChange = { newLabelInput = it },
                    onAddLabel = {
                        if (newLabelInput.isNotBlank()) {
                            // Split on commas and trim each label
                            val newLabels = newLabelInput.split(',')
                                .map { it.trim() }
                                .filter { it.isNotBlank() && !labels.contains(it) }

                            if (newLabels.isNotEmpty()) {
                                onLabelsChange(labels + newLabels)
                            }
                            newLabelInput = ""
                            keyboardController?.hide()
                        }
                    },
                    onRemoveLabel = { label ->
                        onLabelsChange(labels.filter { it != label })
                    }
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    // Process any pending label input before creating
                    if (newLabelInput.isNotBlank()) {
                        val newLabels = newLabelInput.split(',')
                            .map { it.trim() }
                            .filter { it.isNotBlank() && !labels.contains(it) }

                        if (newLabels.isNotEmpty()) {
                            onLabelsChange(labels + newLabels)
                        }
                    }
                    onCreateBookmark()
                },
                enabled = isCreateEnabled
            ) {
                Text(stringResource(id = R.string.create))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(stringResource(id = R.string.cancel))
            }
        }
    )
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun CreateBookmarkLabelsSection(
    labels: List<String>,
    newLabelInput: String,
    onNewLabelChange: (String) -> Unit,
    onAddLabel: () -> Unit,
    onRemoveLabel: (String) -> Unit
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(
            text = stringResource(R.string.detail_labels),
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        // Existing labels
        if (labels.isNotEmpty()) {
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                labels.forEach { label ->
                    LabelChip(
                        label = label,
                        onRemove = { onRemoveLabel(label) }
                    )
                }
            }
        }

        // Input field for new label
        OutlinedTextField(
            value = newLabelInput,
            onValueChange = onNewLabelChange,
            placeholder = { Text(stringResource(R.string.detail_label_placeholder)) },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),
            keyboardActions = KeyboardActions(
                onDone = { onAddLabel() }
            ),
            textStyle = MaterialTheme.typography.bodySmall
        )
    }
}

@Composable
private fun LabelChip(
    label: String,
    onRemove: () -> Unit = {}
) {
    Card(
        modifier = Modifier.padding(4.dp),
        shape = RoundedCornerShape(16.dp)
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = label,
                style = MaterialTheme.typography.labelSmall,
                modifier = Modifier.weight(1f, fill = false)
            )
            IconButton(
                onClick = onRemove,
                modifier = Modifier.size(20.dp)
            ) {
                Icon(
                    imageVector = Icons.Filled.Close,
                    contentDescription = "Remove label",
                    modifier = Modifier.size(16.dp)
                )
            }
        }
    }
}

@Composable
fun EmptyScreen(
    modifier: Modifier = Modifier,
    messageResource: Int
) {
    Surface(
        modifier = modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.surface
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier.fillMaxSize()
        ) {
            Text(stringResource(id = messageResource))
        }
    }
}

@Composable
fun LabelsListView(
    modifier: Modifier = Modifier,
    labels: Map<String, Int>,
    onLabelSelected: (String) -> Unit
) {
    if (labels.isEmpty()) {
        Column(
            modifier = modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = stringResource(R.string.list_view_empty_nothing_to_see),
                style = MaterialTheme.typography.bodyMedium
            )
        }
    } else {
        LazyColumn(
            modifier = modifier.fillMaxWidth()
        ) {
            item {
                Text(
                    text = stringResource(R.string.labels_description),
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp)
                )
            }
            items(
                items = labels.entries.sortedBy { it.key }.toList(),
                key = { it.key }
            ) { (label, count) ->
                NavigationDrawerItem(
                    modifier = Modifier
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                        .border(
                            width = 1.dp,
                            color = MaterialTheme.colorScheme.outlineVariant,
                            shape = MaterialTheme.shapes.medium
                        ),
                    label = {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(label)
                            Badge(
                                containerColor = MaterialTheme.colorScheme.surfaceVariant
                            ) {
                                Text(count.toString())
                            }
                        }
                    },
                    selected = false,
                    onClick = {
                        onLabelSelected(label)
                    }
                )
            }
        }
    }
}

@Composable
fun BookmarkListView(
    modifier: Modifier = Modifier,
    layoutMode: LayoutMode = LayoutMode.GRID,
    bookmarks: List<BookmarkListItem>,
    onClickBookmark: (String) -> Unit,
    onClickDelete: (String) -> Unit,
    onClickFavorite: (String, Boolean) -> Unit,
    onClickArchive: (String, Boolean) -> Unit,
    onClickShareBookmark: (String) -> Unit,
    onClickLabel: (String) -> Unit = {},
    onClickOpenUrl: (String) -> Unit = {}
) {
    LazyColumn(modifier = modifier) {
        items(bookmarks) { bookmark ->
            when (layoutMode) {
                LayoutMode.GRID -> BookmarkGridCard(
                    bookmark = bookmark,
                    onClickCard = onClickBookmark,
                    onClickDelete = onClickDelete,
                    onClickArchive = onClickArchive,
                    onClickFavorite = onClickFavorite,
                    onClickShareBookmark = onClickShareBookmark,
                    onClickLabel = onClickLabel,
                    onClickOpenUrl = onClickOpenUrl
                )
                LayoutMode.COMPACT -> BookmarkCompactCard(
                    bookmark = bookmark,
                    onClickCard = onClickBookmark,
                    onClickDelete = onClickDelete,
                    onClickArchive = onClickArchive,
                    onClickFavorite = onClickFavorite,
                    onClickShareBookmark = onClickShareBookmark,
                    onClickLabel = onClickLabel,
                    onClickOpenUrl = onClickOpenUrl
                )
                LayoutMode.MOSAIC -> BookmarkMosaicCard(
                    bookmark = bookmark,
                    onClickCard = onClickBookmark,
                    onClickDelete = onClickDelete,
                    onClickArchive = onClickArchive,
                    onClickFavorite = onClickFavorite,
                    onClickShareBookmark = onClickShareBookmark,
                    onClickLabel = onClickLabel,
                    onClickOpenUrl = onClickOpenUrl
                )
            }
        }
    }
}

@Preview
@Composable
fun EmptyScreenPreview() {
    EmptyScreen(messageResource = R.string.list_view_empty_nothing_to_see)
}

@Preview(showBackground = true)
@Composable
fun BookmarkListViewPreview() {
    val sampleBookmark = BookmarkListItem(
        id = "1",
        url = "https://example.com",
        title = "Sample Bookmark",
        siteName = "Example",
        type = Bookmark.Type.Article,
        isMarked = false,
        isArchived = false,
        labels = listOf(
            "one",
            "two",
            "three",
            "fourhundretandtwentyone",
            "threethousendtwohundretandfive"
        ),
        isRead = true,
        readProgress = 100,
        iconSrc = "https://picsum.photos/seed/picsum/640/480",
        imageSrc = "https://picsum.photos/seed/picsum/640/480",
        thumbnailSrc = "https://picsum.photos/seed/picsum/640/480",
        readingTime = 8,
        created = Clock.System.now().toLocalDateTime(TimeZone.currentSystemDefault()),
        wordCount = 2000,
        published = null
    )
    val bookmarks = listOf(sampleBookmark)

    // Provide a dummy NavHostController for the preview
    val navController = rememberNavController()
    BookmarkListView(
        modifier = Modifier,
        layoutMode = LayoutMode.GRID,
        bookmarks = bookmarks,
        onClickBookmark = {},
        onClickDelete = {},
        onClickArchive = { _, _ -> },
        onClickFavorite = { _, _ -> },
        onClickShareBookmark = {_ -> },
        onClickLabel = {}
    )
}
</file>

</files>
